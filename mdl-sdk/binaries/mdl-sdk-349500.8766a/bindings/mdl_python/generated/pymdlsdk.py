# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _pymdlsdk
else:
    import _pymdlsdk

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


ADD_STANDALONE_SUPPORT = _pymdlsdk.ADD_STANDALONE_SUPPORT

from enum import Enum

class Uuid(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_id1 = property(_pymdlsdk.Uuid_m_id1_get, _pymdlsdk.Uuid_m_id1_set, doc=r""" First  value.""")
    m_id2 = property(_pymdlsdk.Uuid_m_id2_get, _pymdlsdk.Uuid_m_id2_set, doc=r""" Second value.""")
    m_id3 = property(_pymdlsdk.Uuid_m_id3_get, _pymdlsdk.Uuid_m_id3_set, doc=r""" Third  value.""")
    m_id4 = property(_pymdlsdk.Uuid_m_id4_get, _pymdlsdk.Uuid_m_id4_set, doc=r""" Fourth value.""")

    def __init__(self):
        _pymdlsdk.Uuid_swiginit(self, _pymdlsdk.new_Uuid())
    __swig_destroy__ = _pymdlsdk.delete_Uuid

# Register Uuid in _pymdlsdk:
_pymdlsdk.Uuid_swigregister(Uuid)

class Color_struct(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    r = property(_pymdlsdk.Color_struct_r_get, _pymdlsdk.Color_struct_r_set, doc=r""" Red color component""")
    g = property(_pymdlsdk.Color_struct_g_get, _pymdlsdk.Color_struct_g_set, doc=r""" Green color component""")
    b = property(_pymdlsdk.Color_struct_b_get, _pymdlsdk.Color_struct_b_set, doc=r""" Blue color component""")
    a = property(_pymdlsdk.Color_struct_a_get, _pymdlsdk.Color_struct_a_set, doc=r""" Alpha value, 0.0 is fully transparent and 1.0 is opaque; value can lie outside that range.""")

    def __init__(self):
        _pymdlsdk.Color_struct_swiginit(self, _pymdlsdk.new_Color_struct())
    __swig_destroy__ = _pymdlsdk.delete_Color_struct

# Register Color_struct in _pymdlsdk:
_pymdlsdk.Color_struct_swigregister(Color_struct)

class IInterface(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IInterface_swiginit(self, _pymdlsdk.new_IInterface(*args))
    __swig_destroy__ = _pymdlsdk.delete_IInterface

    def __deref__(self):
        return _pymdlsdk.IInterface___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IInterface___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IInterface_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IInterface___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IInterface___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IInterface_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IInterface_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IInterface__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface.

        :rtype: boolean
        :return: ``true`` if ``iid`` == #mi::base::IInterface::IID(), and ``false`` otherwise.
        """
        return _pymdlsdk.IInterface_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IInterface__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IInterface__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IInterface_get_iid(self)

# Register IInterface in _pymdlsdk:
_pymdlsdk.IInterface_swigregister(IInterface)

def IInterface_IID():
    return _pymdlsdk.IInterface_IID()

def IInterface__get_interface(iface):
    return _pymdlsdk.IInterface__get_interface(iface)

class Interface_declare_IData(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IData_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IData

# Register Interface_declare_IData in _pymdlsdk:
_pymdlsdk.Interface_declare_IData_swigregister(Interface_declare_IData)

def Interface_declare_IData_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IData_compare_iid(iid)

class _IData(Interface_declare_IData):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk._IData_get_type_name(self)

# Register _IData in _pymdlsdk:
_pymdlsdk._IData_swigregister(_IData)

class Interface_declare_IData_simple(_IData):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IData_simple_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IData_simple

# Register Interface_declare_IData_simple in _pymdlsdk:
_pymdlsdk.Interface_declare_IData_simple_swigregister(Interface_declare_IData_simple)

def Interface_declare_IData_simple_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IData_simple_compare_iid(iid)

class _IData_simple(Interface_declare_IData_simple):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IData_simple in _pymdlsdk:
_pymdlsdk._IData_simple_swigregister(_IData_simple)

class Interface_declare_IData_collection(_IData):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IData_collection_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IData_collection

# Register Interface_declare_IData_collection in _pymdlsdk:
_pymdlsdk.Interface_declare_IData_collection_swigregister(Interface_declare_IData_collection)

def Interface_declare_IData_collection_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IData_collection_compare_iid(iid)

class _IData_collection(Interface_declare_IData_collection):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_length(self):
        r""" Returns the number of values."""
        return _pymdlsdk._IData_collection_get_length(self)

    def get_key(self, index):
        r"""
        Returns the key corresponding to ``index``.

        :rtype: string
        :return: The key, or ``NULL`` in case of failure.
        """
        return _pymdlsdk._IData_collection_get_key(self, index)

    def has_key(self, key):
        r""" Indicates whether the key ``key`` exists or not."""
        return _pymdlsdk._IData_collection_has_key(self, key)

    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value for key ``key``.

        Notes: If a literal ``0`` is passed for ``key``, the call is ambiguous. You need to
                  explicitly cast the argument to ``const`` ``char*``.

        |

        *Overload 2:*
        Returns the value for key ``key``.

        Notes: If a literal ``0`` is passed for ``key``, the call is ambiguous. You need to
                  explicitly cast the argument to ``const`` ``char*``.

        |

        *Overload 3:*
        Returns the value for index ``index``.

        Notes: If a literal ``0`` is passed for ``index``, the call is ambiguous. You need to
                  explicitly cast the argument to #mi::Size.

        |

        *Overload 4:*
        Returns the value for index ``index``.

        Notes: If a literal ``0`` is passed for ``index``, the call is ambiguous. You need to
                  explicitly cast the argument to #mi::Size.
        """
        return _pymdlsdk._IData_collection_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Stores the value for key ``key``.

        Note that it is not possible to create new keys.

        Notes: If a literal ``0`` is passed for ``key``, the call is ambiguous. You need to
                  explicitly cast the argument to ``const`` ``char*``.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: Invalid key.
                      - -3: ``value`` has the wrong type.

        |

        *Overload 2:*
        Stores the value for index ``index``.

        Note that it is not possible to create new indices.

        Notes: If a literal ``0`` is passed for ``index``, the call is ambiguous. You need to
                  explicitly cast the argument to #mi::Size.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: Invalid index.
                      - -3: ``value`` has the wrong type.
        """
        return _pymdlsdk._IData_collection_set_value(self, *args)

# Register _IData_collection in _pymdlsdk:
_pymdlsdk._IData_collection_swigregister(_IData_collection)

class Interface_declare_IVoid(_IData_simple):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IVoid_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IVoid

# Register Interface_declare_IVoid in _pymdlsdk:
_pymdlsdk.Interface_declare_IVoid_swigregister(Interface_declare_IVoid)

def Interface_declare_IVoid_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IVoid_compare_iid(iid)

class _IVoid(Interface_declare_IVoid):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IVoid in _pymdlsdk:
_pymdlsdk._IVoid_swigregister(_IVoid)

class Interface_declare_IString(_IData_simple):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IString_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IString

# Register Interface_declare_IString in _pymdlsdk:
_pymdlsdk.Interface_declare_IString_swigregister(Interface_declare_IString)

def Interface_declare_IString_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IString_compare_iid(iid)

class _IString(Interface_declare_IString):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_c_str(self):
        r"""
        Returns the content as a C-style string.

        :rtype: string
        :return: The stored string as a C-style string. Never returns ``NULL``.
        """
        return _pymdlsdk._IString_get_c_str(self)

    def set_c_str(self, str):
        r"""
        Sets the content via a C-style string.

        :type str: string
        :param str:   The string to store as a C-style string. The value ``NULL`` is treated as the
                         empty string.
        """
        return _pymdlsdk._IString_set_c_str(self, str)

# Register _IString in _pymdlsdk:
_pymdlsdk._IString_swigregister(_IString)

class Interface_declare_IArray(_IData_collection):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IArray_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IArray

# Register Interface_declare_IArray in _pymdlsdk:
_pymdlsdk.Interface_declare_IArray_swigregister(Interface_declare_IArray)

def Interface_declare_IArray_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IArray_compare_iid(iid)

class _IArray(Interface_declare_IArray):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_length(self):
        r"""
        Returns the size of the array.

        The size of an array is the number of elements in the array.
        """
        return _pymdlsdk._IArray_get_length(self)

    def get_element(self, *args):
        r"""
        *Overload 1:*
        Returns the ``index`` -th element of the array.

        :type index: int
        :param index:   The index of the requested element.
        :rtype: mi::base::IInterface
        :return: The requested element, or ``NULL`` if ``index`` is equal to or larger than
                           the size of the array.

        |

        *Overload 2:*
        Returns the ``index`` -th element of the array.

        :type index: int
        :param index:   The index of the requested element.
        :rtype: mi::base::IInterface
        :return: The requested element, or ``NULL`` if ``index`` is equal to or larger than
                           the size of the array.
        """
        return _pymdlsdk._IArray_get_element(self, *args)

    def set_element(self, index, element):
        r"""
        Sets the ``index`` -th element of the array.

        The object ``element`` is stored as ``index`` -th element of the array.

        :type index: int
        :param index:        The index where the object should be stored. The method call gets
                                ignored if ``index`` is equal to or larger than the size of the array.
        :type element: mi::base::IInterface
        :param element:      The object to be stored.
        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: ``index`` is out of bounds.
                                - -2: ``element`` is ``NULL`` or has the wrong type.
        """
        return _pymdlsdk._IArray_set_element(self, index, element)

    def empty(self):
        r"""
        Checks whether the array is empty.

        Equivalent to #get_length() == 0.
        """
        return _pymdlsdk._IArray_empty(self)

# Register _IArray in _pymdlsdk:
_pymdlsdk._IArray_swigregister(_IArray)

class Interface_declare_INumber(_IData_simple):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_INumber_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_INumber

# Register Interface_declare_INumber in _pymdlsdk:
_pymdlsdk.Interface_declare_INumber_swigregister(Interface_declare_INumber)

def Interface_declare_INumber_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_INumber_compare_iid(iid)

class _INumber(Interface_declare_INumber):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value of the object as bool.

        |

        *Overload 2:*
        Returns the value of the object as #mi::Uint8.

        |

        *Overload 3:*
        Returns the value of the object as #mi::Uint16.

        |

        *Overload 4:*
        Returns the value of the object as #mi::Uint32.

        |

        *Overload 5:*
        Returns the value of the object as #mi::Uint64.

        |

        *Overload 6:*
        Returns the value of the object as #mi::Sint8.

        |

        *Overload 7:*
        Returns the value of the object as #mi::Sint16.

        |

        *Overload 8:*
        Returns the value of the object as #mi::Sint32.

        |

        *Overload 9:*
        Returns the value of the object as #mi::Sint64.

        |

        *Overload 10:*
        Returns the value of the object as #mi::Float32.

        |

        *Overload 11:*
        Returns the value of the object as #mi::Float64.
        """
        return _pymdlsdk._INumber_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the value of the object via a parameter of type bool.

        |

        *Overload 2:*
        Sets the value of the object via a parameter of type #mi::Uint8.

        |

        *Overload 3:*
        Sets the value of the object via a parameter of type #mi::Uint16.

        |

        *Overload 4:*
        Sets the value of the object via a parameter of type #mi::Uint32.

        |

        *Overload 5:*
        Sets the value of the object via a parameter of type #mi::Uint64.

        |

        *Overload 6:*
        Sets the value of the object via a parameter of type #mi::Sint8.

        |

        *Overload 7:*
        Sets the value of the object via a parameter of type #mi::Sint16.

        |

        *Overload 8:*
        Sets the value of the object via a parameter of type #mi::Sint32.

        |

        *Overload 9:*
        Sets the value of the object via a parameter of type #mi::Sint64.

        |

        *Overload 10:*
        Sets the value of the object via a parameter of type #mi::Float32.

        |

        *Overload 11:*
        Sets the value of the object via a parameter of type #mi::Float64.
        """
        return _pymdlsdk._INumber_set_value(self, *args)

# Register _INumber in _pymdlsdk:
_pymdlsdk._INumber_swigregister(_INumber)

class Interface_declare_IBoolean(_INumber):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IBoolean_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IBoolean

# Register Interface_declare_IBoolean in _pymdlsdk:
_pymdlsdk.Interface_declare_IBoolean_swigregister(Interface_declare_IBoolean)

def Interface_declare_IBoolean_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IBoolean_compare_iid(iid)

class _IBoolean(Interface_declare_IBoolean):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IBoolean in _pymdlsdk:
_pymdlsdk._IBoolean_swigregister(_IBoolean)

class Interface_declare_IUint8(_INumber):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IUint8_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IUint8

# Register Interface_declare_IUint8 in _pymdlsdk:
_pymdlsdk.Interface_declare_IUint8_swigregister(Interface_declare_IUint8)

def Interface_declare_IUint8_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IUint8_compare_iid(iid)

class _IUint8(Interface_declare_IUint8):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IUint8 in _pymdlsdk:
_pymdlsdk._IUint8_swigregister(_IUint8)

class Interface_declare_IUint16(_INumber):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IUint16_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IUint16

# Register Interface_declare_IUint16 in _pymdlsdk:
_pymdlsdk.Interface_declare_IUint16_swigregister(Interface_declare_IUint16)

def Interface_declare_IUint16_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IUint16_compare_iid(iid)

class _IUint16(Interface_declare_IUint16):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IUint16 in _pymdlsdk:
_pymdlsdk._IUint16_swigregister(_IUint16)

class Interface_declare_IUint32(_INumber):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IUint32_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IUint32

# Register Interface_declare_IUint32 in _pymdlsdk:
_pymdlsdk.Interface_declare_IUint32_swigregister(Interface_declare_IUint32)

def Interface_declare_IUint32_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IUint32_compare_iid(iid)

class _IUint32(Interface_declare_IUint32):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IUint32 in _pymdlsdk:
_pymdlsdk._IUint32_swigregister(_IUint32)

class Interface_declare_IUint64(_INumber):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IUint64_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IUint64

# Register Interface_declare_IUint64 in _pymdlsdk:
_pymdlsdk.Interface_declare_IUint64_swigregister(Interface_declare_IUint64)

def Interface_declare_IUint64_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IUint64_compare_iid(iid)

class _IUint64(Interface_declare_IUint64):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IUint64 in _pymdlsdk:
_pymdlsdk._IUint64_swigregister(_IUint64)

class Interface_declare_ISint8(_INumber):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_ISint8_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_ISint8

# Register Interface_declare_ISint8 in _pymdlsdk:
_pymdlsdk.Interface_declare_ISint8_swigregister(Interface_declare_ISint8)

def Interface_declare_ISint8_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_ISint8_compare_iid(iid)

class _ISint8(Interface_declare_ISint8):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _ISint8 in _pymdlsdk:
_pymdlsdk._ISint8_swigregister(_ISint8)

class Interface_declare_ISint16(_INumber):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_ISint16_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_ISint16

# Register Interface_declare_ISint16 in _pymdlsdk:
_pymdlsdk.Interface_declare_ISint16_swigregister(Interface_declare_ISint16)

def Interface_declare_ISint16_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_ISint16_compare_iid(iid)

class _ISint16(Interface_declare_ISint16):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _ISint16 in _pymdlsdk:
_pymdlsdk._ISint16_swigregister(_ISint16)

class Interface_declare_ISint32(_INumber):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_ISint32_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_ISint32

# Register Interface_declare_ISint32 in _pymdlsdk:
_pymdlsdk.Interface_declare_ISint32_swigregister(Interface_declare_ISint32)

def Interface_declare_ISint32_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_ISint32_compare_iid(iid)

class _ISint32(Interface_declare_ISint32):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _ISint32 in _pymdlsdk:
_pymdlsdk._ISint32_swigregister(_ISint32)

class Interface_declare_ISint64(_INumber):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_ISint64_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_ISint64

# Register Interface_declare_ISint64 in _pymdlsdk:
_pymdlsdk.Interface_declare_ISint64_swigregister(Interface_declare_ISint64)

def Interface_declare_ISint64_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_ISint64_compare_iid(iid)

class _ISint64(Interface_declare_ISint64):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _ISint64 in _pymdlsdk:
_pymdlsdk._ISint64_swigregister(_ISint64)

class Interface_declare_IFloat32(_INumber):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IFloat32_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IFloat32

# Register Interface_declare_IFloat32 in _pymdlsdk:
_pymdlsdk.Interface_declare_IFloat32_swigregister(Interface_declare_IFloat32)

def Interface_declare_IFloat32_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IFloat32_compare_iid(iid)

class _IFloat32(Interface_declare_IFloat32):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_value(self):
        return _pymdlsdk._IFloat32_get_value(self)

# Register _IFloat32 in _pymdlsdk:
_pymdlsdk._IFloat32_swigregister(_IFloat32)

class Interface_declare_IFloat64(_INumber):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IFloat64_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IFloat64

# Register Interface_declare_IFloat64 in _pymdlsdk:
_pymdlsdk.Interface_declare_IFloat64_swigregister(Interface_declare_IFloat64)

def Interface_declare_IFloat64_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IFloat64_compare_iid(iid)

class _IFloat64(Interface_declare_IFloat64):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IFloat64 in _pymdlsdk:
_pymdlsdk._IFloat64_swigregister(_IFloat64)

class Interface_declare_ISize(_INumber):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_ISize_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_ISize

# Register Interface_declare_ISize in _pymdlsdk:
_pymdlsdk.Interface_declare_ISize_swigregister(Interface_declare_ISize)

def Interface_declare_ISize_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_ISize_compare_iid(iid)

class _ISize(Interface_declare_ISize):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _ISize in _pymdlsdk:
_pymdlsdk._ISize_swigregister(_ISize)

class Interface_declare_IDifference(_INumber):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IDifference_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IDifference

# Register Interface_declare_IDifference in _pymdlsdk:
_pymdlsdk.Interface_declare_IDifference_swigregister(Interface_declare_IDifference)

def Interface_declare_IDifference_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IDifference_compare_iid(iid)

class _IDifference(Interface_declare_IDifference):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IDifference in _pymdlsdk:
_pymdlsdk._IDifference_swigregister(_IDifference)

class Interface_declare_ICompound(_IData_collection):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_ICompound_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_ICompound

# Register Interface_declare_ICompound in _pymdlsdk:
_pymdlsdk.Interface_declare_ICompound_swigregister(Interface_declare_ICompound)

def Interface_declare_ICompound_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_ICompound_compare_iid(iid)

class _ICompound(Interface_declare_ICompound):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_number_of_rows(self):
        r""" Returns the number of rows of the represented matrix or vector."""
        return _pymdlsdk._ICompound_get_number_of_rows(self)

    def get_number_of_columns(self):
        r"""
        Returns the number of columns of the represented matrix.

        Always returns 1 in case of vectors.
        """
        return _pymdlsdk._ICompound_get_number_of_columns(self)

    def get_length(self):
        r"""
        Returns the total number of elements.

        This value is the product of #get_number_of_rows() and #get_number_of_columns().
        """
        return _pymdlsdk._ICompound_get_length(self)

    def get_element_type_name(self):
        r""" Returns the type name of elements of the compound."""
        return _pymdlsdk._ICompound_get_element_type_name(self)

    def get_values(self, *args):
        r"""
        *Overload 1:*
        Accesses the elements of the compound.

        :type values: boolean
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk._ICompound_get_values(self, *args)

    def set_values(self, *args):
        r"""
        *Overload 1:*
        Sets the elements of the compound.

        :type values: boolean
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk._ICompound_set_values(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Stores the value for key ``key``.

        Note that it is not possible to create new keys.

        Notes: If a literal ``0`` is passed for ``key``, the call is ambiguous. You need to
                  explicitly cast the argument to ``const`` ``char*``.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: Invalid key.
                      - -3: ``value`` has the wrong type.

        |

        *Overload 7:*
        Stores the value for index ``index``.

        Note that it is not possible to create new indices.

        Notes: If a literal ``0`` is passed for ``index``, the call is ambiguous. You need to
                  explicitly cast the argument to #mi::Size.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: Invalid index.
                      - -3: ``value`` has the wrong type.
        """
        return _pymdlsdk._ICompound_set_value(self, *args)

# Register _ICompound in _pymdlsdk:
_pymdlsdk._ICompound_swigregister(_ICompound)

class Interface_declare_IBoolean_2(_ICompound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IBoolean_2_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IBoolean_2

# Register Interface_declare_IBoolean_2 in _pymdlsdk:
_pymdlsdk.Interface_declare_IBoolean_2_swigregister(Interface_declare_IBoolean_2)

def Interface_declare_IBoolean_2_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IBoolean_2_compare_iid(iid)

class _IBoolean_2(Interface_declare_IBoolean_2):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk._IBoolean_2_set_value(self, *args)

# Register _IBoolean_2 in _pymdlsdk:
_pymdlsdk._IBoolean_2_swigregister(_IBoolean_2)

class Interface_declare_IBoolean_3(_ICompound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IBoolean_3_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IBoolean_3

# Register Interface_declare_IBoolean_3 in _pymdlsdk:
_pymdlsdk.Interface_declare_IBoolean_3_swigregister(Interface_declare_IBoolean_3)

def Interface_declare_IBoolean_3_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IBoolean_3_compare_iid(iid)

class _IBoolean_3(Interface_declare_IBoolean_3):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk._IBoolean_3_set_value(self, *args)

# Register _IBoolean_3 in _pymdlsdk:
_pymdlsdk._IBoolean_3_swigregister(_IBoolean_3)

class Interface_declare_IBoolean_4(_ICompound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IBoolean_4_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IBoolean_4

# Register Interface_declare_IBoolean_4 in _pymdlsdk:
_pymdlsdk.Interface_declare_IBoolean_4_swigregister(Interface_declare_IBoolean_4)

def Interface_declare_IBoolean_4_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IBoolean_4_compare_iid(iid)

class _IBoolean_4(Interface_declare_IBoolean_4):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk._IBoolean_4_set_value(self, *args)

# Register _IBoolean_4 in _pymdlsdk:
_pymdlsdk._IBoolean_4_swigregister(_IBoolean_4)

class Interface_declare_ISint32_2(_ICompound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_ISint32_2_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_ISint32_2

# Register Interface_declare_ISint32_2 in _pymdlsdk:
_pymdlsdk.Interface_declare_ISint32_2_swigregister(Interface_declare_ISint32_2)

def Interface_declare_ISint32_2_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_ISint32_2_compare_iid(iid)

class _ISint32_2(Interface_declare_ISint32_2):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk._ISint32_2_set_value(self, *args)

# Register _ISint32_2 in _pymdlsdk:
_pymdlsdk._ISint32_2_swigregister(_ISint32_2)

class Interface_declare_ISint32_3(_ICompound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_ISint32_3_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_ISint32_3

# Register Interface_declare_ISint32_3 in _pymdlsdk:
_pymdlsdk.Interface_declare_ISint32_3_swigregister(Interface_declare_ISint32_3)

def Interface_declare_ISint32_3_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_ISint32_3_compare_iid(iid)

class _ISint32_3(Interface_declare_ISint32_3):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk._ISint32_3_set_value(self, *args)

# Register _ISint32_3 in _pymdlsdk:
_pymdlsdk._ISint32_3_swigregister(_ISint32_3)

class Interface_declare_ISint32_4(_ICompound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_ISint32_4_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_ISint32_4

# Register Interface_declare_ISint32_4 in _pymdlsdk:
_pymdlsdk.Interface_declare_ISint32_4_swigregister(Interface_declare_ISint32_4)

def Interface_declare_ISint32_4_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_ISint32_4_compare_iid(iid)

class _ISint32_4(Interface_declare_ISint32_4):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk._ISint32_4_set_value(self, *args)

# Register _ISint32_4 in _pymdlsdk:
_pymdlsdk._ISint32_4_swigregister(_ISint32_4)

class Interface_declare_IUint32_2(_ICompound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IUint32_2_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IUint32_2

# Register Interface_declare_IUint32_2 in _pymdlsdk:
_pymdlsdk.Interface_declare_IUint32_2_swigregister(Interface_declare_IUint32_2)

def Interface_declare_IUint32_2_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IUint32_2_compare_iid(iid)

class _IUint32_2(Interface_declare_IUint32_2):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk._IUint32_2_set_value(self, *args)

# Register _IUint32_2 in _pymdlsdk:
_pymdlsdk._IUint32_2_swigregister(_IUint32_2)

class Interface_declare_IUint32_3(_ICompound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IUint32_3_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IUint32_3

# Register Interface_declare_IUint32_3 in _pymdlsdk:
_pymdlsdk.Interface_declare_IUint32_3_swigregister(Interface_declare_IUint32_3)

def Interface_declare_IUint32_3_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IUint32_3_compare_iid(iid)

class _IUint32_3(Interface_declare_IUint32_3):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk._IUint32_3_set_value(self, *args)

# Register _IUint32_3 in _pymdlsdk:
_pymdlsdk._IUint32_3_swigregister(_IUint32_3)

class Interface_declare_IUint32_4(_ICompound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IUint32_4_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IUint32_4

# Register Interface_declare_IUint32_4 in _pymdlsdk:
_pymdlsdk.Interface_declare_IUint32_4_swigregister(Interface_declare_IUint32_4)

def Interface_declare_IUint32_4_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IUint32_4_compare_iid(iid)

class _IUint32_4(Interface_declare_IUint32_4):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk._IUint32_4_set_value(self, *args)

# Register _IUint32_4 in _pymdlsdk:
_pymdlsdk._IUint32_4_swigregister(_IUint32_4)

class Interface_declare_IFloat32_2(_ICompound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IFloat32_2_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IFloat32_2

# Register Interface_declare_IFloat32_2 in _pymdlsdk:
_pymdlsdk.Interface_declare_IFloat32_2_swigregister(Interface_declare_IFloat32_2)

def Interface_declare_IFloat32_2_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IFloat32_2_compare_iid(iid)

class _IFloat32_2(Interface_declare_IFloat32_2):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk._IFloat32_2_set_value(self, *args)

# Register _IFloat32_2 in _pymdlsdk:
_pymdlsdk._IFloat32_2_swigregister(_IFloat32_2)

class Interface_declare_IFloat32_3(_ICompound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IFloat32_3_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IFloat32_3

# Register Interface_declare_IFloat32_3 in _pymdlsdk:
_pymdlsdk.Interface_declare_IFloat32_3_swigregister(Interface_declare_IFloat32_3)

def Interface_declare_IFloat32_3_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IFloat32_3_compare_iid(iid)

class _IFloat32_3(Interface_declare_IFloat32_3):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk._IFloat32_3_set_value(self, *args)

# Register _IFloat32_3 in _pymdlsdk:
_pymdlsdk._IFloat32_3_swigregister(_IFloat32_3)

class Interface_declare_IFloat32_4(_ICompound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IFloat32_4_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IFloat32_4

# Register Interface_declare_IFloat32_4 in _pymdlsdk:
_pymdlsdk.Interface_declare_IFloat32_4_swigregister(Interface_declare_IFloat32_4)

def Interface_declare_IFloat32_4_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IFloat32_4_compare_iid(iid)

class _IFloat32_4(Interface_declare_IFloat32_4):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk._IFloat32_4_set_value(self, *args)

# Register _IFloat32_4 in _pymdlsdk:
_pymdlsdk._IFloat32_4_swigregister(_IFloat32_4)

class Interface_declare_IFloat64_2(_ICompound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IFloat64_2_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IFloat64_2

# Register Interface_declare_IFloat64_2 in _pymdlsdk:
_pymdlsdk.Interface_declare_IFloat64_2_swigregister(Interface_declare_IFloat64_2)

def Interface_declare_IFloat64_2_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IFloat64_2_compare_iid(iid)

class _IFloat64_2(Interface_declare_IFloat64_2):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk._IFloat64_2_set_value(self, *args)

# Register _IFloat64_2 in _pymdlsdk:
_pymdlsdk._IFloat64_2_swigregister(_IFloat64_2)

class Interface_declare_IFloat64_3(_ICompound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IFloat64_3_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IFloat64_3

# Register Interface_declare_IFloat64_3 in _pymdlsdk:
_pymdlsdk.Interface_declare_IFloat64_3_swigregister(Interface_declare_IFloat64_3)

def Interface_declare_IFloat64_3_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IFloat64_3_compare_iid(iid)

class _IFloat64_3(Interface_declare_IFloat64_3):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk._IFloat64_3_set_value(self, *args)

# Register _IFloat64_3 in _pymdlsdk:
_pymdlsdk._IFloat64_3_swigregister(_IFloat64_3)

class Interface_declare_IFloat64_4(_ICompound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IFloat64_4_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IFloat64_4

# Register Interface_declare_IFloat64_4 in _pymdlsdk:
_pymdlsdk.Interface_declare_IFloat64_4_swigregister(Interface_declare_IFloat64_4)

def Interface_declare_IFloat64_4_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IFloat64_4_compare_iid(iid)

class _IFloat64_4(Interface_declare_IFloat64_4):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk._IFloat64_4_set_value(self, *args)

# Register _IFloat64_4 in _pymdlsdk:
_pymdlsdk._IFloat64_4_swigregister(_IFloat64_4)

class IArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IArray_swiginit(self, _pymdlsdk.new_IArray(*args))
    __swig_destroy__ = _pymdlsdk.delete_IArray

    def __deref__(self):
        return _pymdlsdk.IArray___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IArray___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IArray_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IArray___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IArray___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IArray_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IArray_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IArray__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_length(self):
        r"""
        Returns the size of the array.

        The size of an array is the number of elements in the array.
        """
        return _pymdlsdk.IArray_get_length(self)

    def get_element(self, *args):
        r"""
        *Overload 1:*
        Returns the ``index`` -th element of the array.

        :type index: int
        :param index:   The index of the requested element.
        :rtype: mi::base::IInterface
        :return: The requested element, or ``NULL`` if ``index`` is equal to or larger than
                           the size of the array.

        |

        *Overload 2:*
        Returns the ``index`` -th element of the array.

        :type index: int
        :param index:   The index of the requested element.
        :rtype: mi::base::IInterface
        :return: The requested element, or ``NULL`` if ``index`` is equal to or larger than
                           the size of the array.
        """
        return _pymdlsdk.IArray_get_element(self, *args)

    def set_element(self, index, element):
        r"""
        Sets the ``index`` -th element of the array.

        The object ``element`` is stored as ``index`` -th element of the array.

        :type index: int
        :param index:        The index where the object should be stored. The method call gets
                                ignored if ``index`` is equal to or larger than the size of the array.
        :type element: mi::base::IInterface
        :param element:      The object to be stored.
        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: ``index`` is out of bounds.
                                - -2: ``element`` is ``NULL`` or has the wrong type.
        """
        return _pymdlsdk.IArray_set_element(self, index, element)

    def empty(self):
        r"""
        Checks whether the array is empty.

        Equivalent to #get_length() == 0.
        """
        return _pymdlsdk.IArray_empty(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IArray_compare_iid(self, iid)

    def get_key(self, index):
        r"""
        Returns the key corresponding to ``index``.

        :rtype: string
        :return: The key, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IArray_get_key(self, index)

    def has_key(self, key):
        r""" Indicates whether the key ``key`` exists or not."""
        return _pymdlsdk.IArray_has_key(self, key)

    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value for key ``key``.

        Notes: If a literal ``0`` is passed for ``key``, the call is ambiguous. You need to
                  explicitly cast the argument to ``const`` ``char*``.

        |

        *Overload 2:*
        Returns the value for key ``key``.

        Notes: If a literal ``0`` is passed for ``key``, the call is ambiguous. You need to
                  explicitly cast the argument to ``const`` ``char*``.

        |

        *Overload 3:*
        Returns the value for index ``index``.

        Notes: If a literal ``0`` is passed for ``index``, the call is ambiguous. You need to
                  explicitly cast the argument to #mi::Size.

        |

        *Overload 4:*
        Returns the value for index ``index``.

        Notes: If a literal ``0`` is passed for ``index``, the call is ambiguous. You need to
                  explicitly cast the argument to #mi::Size.
        """
        return _pymdlsdk.IArray_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Stores the value for key ``key``.

        Note that it is not possible to create new keys.

        Notes: If a literal ``0`` is passed for ``key``, the call is ambiguous. You need to
                  explicitly cast the argument to ``const`` ``char*``.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: Invalid key.
                      - -3: ``value`` has the wrong type.

        |

        *Overload 2:*
        Stores the value for index ``index``.

        Note that it is not possible to create new indices.

        Notes: If a literal ``0`` is passed for ``index``, the call is ambiguous. You need to
                  explicitly cast the argument to #mi::Size.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: Invalid index.
                      - -3: ``value`` has the wrong type.
        """
        return _pymdlsdk.IArray_set_value(self, *args)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IArray_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IArray__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IArray__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IArray_get_iid(self)

# Register IArray in _pymdlsdk:
_pymdlsdk.IArray_swigregister(IArray)

def IArray_IID():
    return _pymdlsdk.IArray_IID()

def IArray__get_interface(iface):
    return _pymdlsdk.IArray__get_interface(iface)

class ICompound(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.ICompound_swiginit(self, _pymdlsdk.new_ICompound(*args))
    __swig_destroy__ = _pymdlsdk.delete_ICompound

    def __deref__(self):
        return _pymdlsdk.ICompound___deref__(self)

    def __ref__(self):
        return _pymdlsdk.ICompound___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.ICompound_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.ICompound___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.ICompound___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.ICompound_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.ICompound_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.ICompound__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_number_of_rows(self):
        r""" Returns the number of rows of the represented matrix or vector."""
        return _pymdlsdk.ICompound_get_number_of_rows(self)

    def get_number_of_columns(self):
        r"""
        Returns the number of columns of the represented matrix.

        Always returns 1 in case of vectors.
        """
        return _pymdlsdk.ICompound_get_number_of_columns(self)

    def get_length(self):
        r"""
        Returns the total number of elements.

        This value is the product of #get_number_of_rows() and #get_number_of_columns().
        """
        return _pymdlsdk.ICompound_get_length(self)

    def get_element_type_name(self):
        r""" Returns the type name of elements of the compound."""
        return _pymdlsdk.ICompound_get_element_type_name(self)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Stores the value for key ``key``.

        Note that it is not possible to create new keys.

        Notes: If a literal ``0`` is passed for ``key``, the call is ambiguous. You need to
                  explicitly cast the argument to ``const`` ``char*``.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: Invalid key.
                      - -3: ``value`` has the wrong type.

        |

        *Overload 7:*
        Stores the value for index ``index``.

        Note that it is not possible to create new indices.

        Notes: If a literal ``0`` is passed for ``index``, the call is ambiguous. You need to
                  explicitly cast the argument to #mi::Size.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: Invalid index.
                      - -3: ``value`` has the wrong type.
        """
        return _pymdlsdk.ICompound_set_value(self, *args)

    def get_values(self, *args):
        r"""
        *Overload 1:*
        Accesses the elements of the compound.

        :type values: boolean
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.ICompound_get_values(self, *args)

    def set_values(self, *args):
        r"""
        *Overload 1:*
        Sets the elements of the compound.

        :type values: boolean
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.ICompound_set_values(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.ICompound_compare_iid(self, iid)

    def get_key(self, index):
        r"""
        Returns the key corresponding to ``index``.

        :rtype: string
        :return: The key, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.ICompound_get_key(self, index)

    def has_key(self, key):
        r""" Indicates whether the key ``key`` exists or not."""
        return _pymdlsdk.ICompound_has_key(self, key)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.ICompound_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.ICompound__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.ICompound__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.ICompound_get_iid(self)

# Register ICompound in _pymdlsdk:
_pymdlsdk.ICompound_swigregister(ICompound)

def ICompound_IID():
    return _pymdlsdk.ICompound_IID()

def ICompound__get_interface(iface):
    return _pymdlsdk.ICompound__get_interface(iface)

class IBoolean(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IBoolean_swiginit(self, _pymdlsdk.new_IBoolean(*args))
    __swig_destroy__ = _pymdlsdk.delete_IBoolean

    def __deref__(self):
        return _pymdlsdk.IBoolean___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IBoolean___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IBoolean_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IBoolean___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IBoolean___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IBoolean_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IBoolean_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IBoolean__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IBoolean_compare_iid(self, iid)

    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value of the object as bool.

        |

        *Overload 2:*
        Returns the value of the object as #mi::Uint8.

        |

        *Overload 3:*
        Returns the value of the object as #mi::Uint16.

        |

        *Overload 4:*
        Returns the value of the object as #mi::Uint32.

        |

        *Overload 5:*
        Returns the value of the object as #mi::Uint64.

        |

        *Overload 6:*
        Returns the value of the object as #mi::Sint8.

        |

        *Overload 7:*
        Returns the value of the object as #mi::Sint16.

        |

        *Overload 8:*
        Returns the value of the object as #mi::Sint32.

        |

        *Overload 9:*
        Returns the value of the object as #mi::Sint64.

        |

        *Overload 10:*
        Returns the value of the object as #mi::Float32.

        |

        *Overload 11:*
        Returns the value of the object as #mi::Float64.
        """
        return _pymdlsdk.IBoolean_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the value of the object via a parameter of type bool.

        |

        *Overload 2:*
        Sets the value of the object via a parameter of type #mi::Uint8.

        |

        *Overload 3:*
        Sets the value of the object via a parameter of type #mi::Uint16.

        |

        *Overload 4:*
        Sets the value of the object via a parameter of type #mi::Uint32.

        |

        *Overload 5:*
        Sets the value of the object via a parameter of type #mi::Uint64.

        |

        *Overload 6:*
        Sets the value of the object via a parameter of type #mi::Sint8.

        |

        *Overload 7:*
        Sets the value of the object via a parameter of type #mi::Sint16.

        |

        *Overload 8:*
        Sets the value of the object via a parameter of type #mi::Sint32.

        |

        *Overload 9:*
        Sets the value of the object via a parameter of type #mi::Sint64.

        |

        *Overload 10:*
        Sets the value of the object via a parameter of type #mi::Float32.

        |

        *Overload 11:*
        Sets the value of the object via a parameter of type #mi::Float64.
        """
        return _pymdlsdk.IBoolean_set_value(self, *args)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IBoolean_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IBoolean__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IBoolean__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IBoolean_get_iid(self)

# Register IBoolean in _pymdlsdk:
_pymdlsdk.IBoolean_swigregister(IBoolean)

def IBoolean_IID():
    return _pymdlsdk.IBoolean_IID()

def IBoolean__get_interface(iface):
    return _pymdlsdk.IBoolean__get_interface(iface)

class IBoolean_2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IBoolean_2_swiginit(self, _pymdlsdk.new_IBoolean_2(*args))
    __swig_destroy__ = _pymdlsdk.delete_IBoolean_2

    def __deref__(self):
        return _pymdlsdk.IBoolean_2___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IBoolean_2___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IBoolean_2_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IBoolean_2___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IBoolean_2___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IBoolean_2_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IBoolean_2_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IBoolean_2__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk.IBoolean_2_set_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IBoolean_2_compare_iid(self, iid)

    def get_number_of_rows(self):
        r""" Returns the number of rows of the represented matrix or vector."""
        return _pymdlsdk.IBoolean_2_get_number_of_rows(self)

    def get_number_of_columns(self):
        r"""
        Returns the number of columns of the represented matrix.

        Always returns 1 in case of vectors.
        """
        return _pymdlsdk.IBoolean_2_get_number_of_columns(self)

    def get_length(self):
        r"""
        Returns the total number of elements.

        This value is the product of #get_number_of_rows() and #get_number_of_columns().
        """
        return _pymdlsdk.IBoolean_2_get_length(self)

    def get_element_type_name(self):
        r""" Returns the type name of elements of the compound."""
        return _pymdlsdk.IBoolean_2_get_element_type_name(self)

    def get_values(self, *args):
        r"""
        *Overload 1:*
        Accesses the elements of the compound.

        :type values: boolean
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IBoolean_2_get_values(self, *args)

    def set_values(self, *args):
        r"""
        *Overload 1:*
        Sets the elements of the compound.

        :type values: boolean
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IBoolean_2_set_values(self, *args)

    def get_key(self, index):
        r"""
        Returns the key corresponding to ``index``.

        :rtype: string
        :return: The key, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IBoolean_2_get_key(self, index)

    def has_key(self, key):
        r""" Indicates whether the key ``key`` exists or not."""
        return _pymdlsdk.IBoolean_2_has_key(self, key)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IBoolean_2_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IBoolean_2__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IBoolean_2__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IBoolean_2_get_iid(self)

# Register IBoolean_2 in _pymdlsdk:
_pymdlsdk.IBoolean_2_swigregister(IBoolean_2)

def IBoolean_2_IID():
    return _pymdlsdk.IBoolean_2_IID()

def IBoolean_2__get_interface(iface):
    return _pymdlsdk.IBoolean_2__get_interface(iface)

class IBoolean_3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IBoolean_3_swiginit(self, _pymdlsdk.new_IBoolean_3(*args))
    __swig_destroy__ = _pymdlsdk.delete_IBoolean_3

    def __deref__(self):
        return _pymdlsdk.IBoolean_3___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IBoolean_3___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IBoolean_3_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IBoolean_3___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IBoolean_3___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IBoolean_3_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IBoolean_3_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IBoolean_3__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk.IBoolean_3_set_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IBoolean_3_compare_iid(self, iid)

    def get_number_of_rows(self):
        r""" Returns the number of rows of the represented matrix or vector."""
        return _pymdlsdk.IBoolean_3_get_number_of_rows(self)

    def get_number_of_columns(self):
        r"""
        Returns the number of columns of the represented matrix.

        Always returns 1 in case of vectors.
        """
        return _pymdlsdk.IBoolean_3_get_number_of_columns(self)

    def get_length(self):
        r"""
        Returns the total number of elements.

        This value is the product of #get_number_of_rows() and #get_number_of_columns().
        """
        return _pymdlsdk.IBoolean_3_get_length(self)

    def get_element_type_name(self):
        r""" Returns the type name of elements of the compound."""
        return _pymdlsdk.IBoolean_3_get_element_type_name(self)

    def get_values(self, *args):
        r"""
        *Overload 1:*
        Accesses the elements of the compound.

        :type values: boolean
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IBoolean_3_get_values(self, *args)

    def set_values(self, *args):
        r"""
        *Overload 1:*
        Sets the elements of the compound.

        :type values: boolean
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IBoolean_3_set_values(self, *args)

    def get_key(self, index):
        r"""
        Returns the key corresponding to ``index``.

        :rtype: string
        :return: The key, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IBoolean_3_get_key(self, index)

    def has_key(self, key):
        r""" Indicates whether the key ``key`` exists or not."""
        return _pymdlsdk.IBoolean_3_has_key(self, key)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IBoolean_3_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IBoolean_3__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IBoolean_3__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IBoolean_3_get_iid(self)

# Register IBoolean_3 in _pymdlsdk:
_pymdlsdk.IBoolean_3_swigregister(IBoolean_3)

def IBoolean_3_IID():
    return _pymdlsdk.IBoolean_3_IID()

def IBoolean_3__get_interface(iface):
    return _pymdlsdk.IBoolean_3__get_interface(iface)

class IBoolean_4(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IBoolean_4_swiginit(self, _pymdlsdk.new_IBoolean_4(*args))
    __swig_destroy__ = _pymdlsdk.delete_IBoolean_4

    def __deref__(self):
        return _pymdlsdk.IBoolean_4___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IBoolean_4___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IBoolean_4_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IBoolean_4___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IBoolean_4___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IBoolean_4_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IBoolean_4_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IBoolean_4__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk.IBoolean_4_set_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IBoolean_4_compare_iid(self, iid)

    def get_number_of_rows(self):
        r""" Returns the number of rows of the represented matrix or vector."""
        return _pymdlsdk.IBoolean_4_get_number_of_rows(self)

    def get_number_of_columns(self):
        r"""
        Returns the number of columns of the represented matrix.

        Always returns 1 in case of vectors.
        """
        return _pymdlsdk.IBoolean_4_get_number_of_columns(self)

    def get_length(self):
        r"""
        Returns the total number of elements.

        This value is the product of #get_number_of_rows() and #get_number_of_columns().
        """
        return _pymdlsdk.IBoolean_4_get_length(self)

    def get_element_type_name(self):
        r""" Returns the type name of elements of the compound."""
        return _pymdlsdk.IBoolean_4_get_element_type_name(self)

    def get_values(self, *args):
        r"""
        *Overload 1:*
        Accesses the elements of the compound.

        :type values: boolean
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IBoolean_4_get_values(self, *args)

    def set_values(self, *args):
        r"""
        *Overload 1:*
        Sets the elements of the compound.

        :type values: boolean
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IBoolean_4_set_values(self, *args)

    def get_key(self, index):
        r"""
        Returns the key corresponding to ``index``.

        :rtype: string
        :return: The key, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IBoolean_4_get_key(self, index)

    def has_key(self, key):
        r""" Indicates whether the key ``key`` exists or not."""
        return _pymdlsdk.IBoolean_4_has_key(self, key)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IBoolean_4_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IBoolean_4__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IBoolean_4__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IBoolean_4_get_iid(self)

# Register IBoolean_4 in _pymdlsdk:
_pymdlsdk.IBoolean_4_swigregister(IBoolean_4)

def IBoolean_4_IID():
    return _pymdlsdk.IBoolean_4_IID()

def IBoolean_4__get_interface(iface):
    return _pymdlsdk.IBoolean_4__get_interface(iface)

class ISint32_2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.ISint32_2_swiginit(self, _pymdlsdk.new_ISint32_2(*args))
    __swig_destroy__ = _pymdlsdk.delete_ISint32_2

    def __deref__(self):
        return _pymdlsdk.ISint32_2___deref__(self)

    def __ref__(self):
        return _pymdlsdk.ISint32_2___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.ISint32_2_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.ISint32_2___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.ISint32_2___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.ISint32_2_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.ISint32_2_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.ISint32_2__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk.ISint32_2_set_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.ISint32_2_compare_iid(self, iid)

    def get_number_of_rows(self):
        r""" Returns the number of rows of the represented matrix or vector."""
        return _pymdlsdk.ISint32_2_get_number_of_rows(self)

    def get_number_of_columns(self):
        r"""
        Returns the number of columns of the represented matrix.

        Always returns 1 in case of vectors.
        """
        return _pymdlsdk.ISint32_2_get_number_of_columns(self)

    def get_length(self):
        r"""
        Returns the total number of elements.

        This value is the product of #get_number_of_rows() and #get_number_of_columns().
        """
        return _pymdlsdk.ISint32_2_get_length(self)

    def get_element_type_name(self):
        r""" Returns the type name of elements of the compound."""
        return _pymdlsdk.ISint32_2_get_element_type_name(self)

    def get_values(self, *args):
        r"""
        *Overload 1:*
        Accesses the elements of the compound.

        :type values: boolean
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.ISint32_2_get_values(self, *args)

    def set_values(self, *args):
        r"""
        *Overload 1:*
        Sets the elements of the compound.

        :type values: boolean
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.ISint32_2_set_values(self, *args)

    def get_key(self, index):
        r"""
        Returns the key corresponding to ``index``.

        :rtype: string
        :return: The key, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.ISint32_2_get_key(self, index)

    def has_key(self, key):
        r""" Indicates whether the key ``key`` exists or not."""
        return _pymdlsdk.ISint32_2_has_key(self, key)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.ISint32_2_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.ISint32_2__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.ISint32_2__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.ISint32_2_get_iid(self)

# Register ISint32_2 in _pymdlsdk:
_pymdlsdk.ISint32_2_swigregister(ISint32_2)

def ISint32_2_IID():
    return _pymdlsdk.ISint32_2_IID()

def ISint32_2__get_interface(iface):
    return _pymdlsdk.ISint32_2__get_interface(iface)

class ISint32_3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.ISint32_3_swiginit(self, _pymdlsdk.new_ISint32_3(*args))
    __swig_destroy__ = _pymdlsdk.delete_ISint32_3

    def __deref__(self):
        return _pymdlsdk.ISint32_3___deref__(self)

    def __ref__(self):
        return _pymdlsdk.ISint32_3___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.ISint32_3_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.ISint32_3___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.ISint32_3___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.ISint32_3_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.ISint32_3_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.ISint32_3__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk.ISint32_3_set_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.ISint32_3_compare_iid(self, iid)

    def get_number_of_rows(self):
        r""" Returns the number of rows of the represented matrix or vector."""
        return _pymdlsdk.ISint32_3_get_number_of_rows(self)

    def get_number_of_columns(self):
        r"""
        Returns the number of columns of the represented matrix.

        Always returns 1 in case of vectors.
        """
        return _pymdlsdk.ISint32_3_get_number_of_columns(self)

    def get_length(self):
        r"""
        Returns the total number of elements.

        This value is the product of #get_number_of_rows() and #get_number_of_columns().
        """
        return _pymdlsdk.ISint32_3_get_length(self)

    def get_element_type_name(self):
        r""" Returns the type name of elements of the compound."""
        return _pymdlsdk.ISint32_3_get_element_type_name(self)

    def get_values(self, *args):
        r"""
        *Overload 1:*
        Accesses the elements of the compound.

        :type values: boolean
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.ISint32_3_get_values(self, *args)

    def set_values(self, *args):
        r"""
        *Overload 1:*
        Sets the elements of the compound.

        :type values: boolean
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.ISint32_3_set_values(self, *args)

    def get_key(self, index):
        r"""
        Returns the key corresponding to ``index``.

        :rtype: string
        :return: The key, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.ISint32_3_get_key(self, index)

    def has_key(self, key):
        r""" Indicates whether the key ``key`` exists or not."""
        return _pymdlsdk.ISint32_3_has_key(self, key)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.ISint32_3_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.ISint32_3__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.ISint32_3__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.ISint32_3_get_iid(self)

# Register ISint32_3 in _pymdlsdk:
_pymdlsdk.ISint32_3_swigregister(ISint32_3)

def ISint32_3_IID():
    return _pymdlsdk.ISint32_3_IID()

def ISint32_3__get_interface(iface):
    return _pymdlsdk.ISint32_3__get_interface(iface)

class ISint32_4(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.ISint32_4_swiginit(self, _pymdlsdk.new_ISint32_4(*args))
    __swig_destroy__ = _pymdlsdk.delete_ISint32_4

    def __deref__(self):
        return _pymdlsdk.ISint32_4___deref__(self)

    def __ref__(self):
        return _pymdlsdk.ISint32_4___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.ISint32_4_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.ISint32_4___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.ISint32_4___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.ISint32_4_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.ISint32_4_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.ISint32_4__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk.ISint32_4_set_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.ISint32_4_compare_iid(self, iid)

    def get_number_of_rows(self):
        r""" Returns the number of rows of the represented matrix or vector."""
        return _pymdlsdk.ISint32_4_get_number_of_rows(self)

    def get_number_of_columns(self):
        r"""
        Returns the number of columns of the represented matrix.

        Always returns 1 in case of vectors.
        """
        return _pymdlsdk.ISint32_4_get_number_of_columns(self)

    def get_length(self):
        r"""
        Returns the total number of elements.

        This value is the product of #get_number_of_rows() and #get_number_of_columns().
        """
        return _pymdlsdk.ISint32_4_get_length(self)

    def get_element_type_name(self):
        r""" Returns the type name of elements of the compound."""
        return _pymdlsdk.ISint32_4_get_element_type_name(self)

    def get_values(self, *args):
        r"""
        *Overload 1:*
        Accesses the elements of the compound.

        :type values: boolean
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.ISint32_4_get_values(self, *args)

    def set_values(self, *args):
        r"""
        *Overload 1:*
        Sets the elements of the compound.

        :type values: boolean
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.ISint32_4_set_values(self, *args)

    def get_key(self, index):
        r"""
        Returns the key corresponding to ``index``.

        :rtype: string
        :return: The key, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.ISint32_4_get_key(self, index)

    def has_key(self, key):
        r""" Indicates whether the key ``key`` exists or not."""
        return _pymdlsdk.ISint32_4_has_key(self, key)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.ISint32_4_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.ISint32_4__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.ISint32_4__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.ISint32_4_get_iid(self)

# Register ISint32_4 in _pymdlsdk:
_pymdlsdk.ISint32_4_swigregister(ISint32_4)

def ISint32_4_IID():
    return _pymdlsdk.ISint32_4_IID()

def ISint32_4__get_interface(iface):
    return _pymdlsdk.ISint32_4__get_interface(iface)

class IUint32_2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IUint32_2_swiginit(self, _pymdlsdk.new_IUint32_2(*args))
    __swig_destroy__ = _pymdlsdk.delete_IUint32_2

    def __deref__(self):
        return _pymdlsdk.IUint32_2___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IUint32_2___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IUint32_2_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IUint32_2___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IUint32_2___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IUint32_2_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IUint32_2_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IUint32_2__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk.IUint32_2_set_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IUint32_2_compare_iid(self, iid)

    def get_number_of_rows(self):
        r""" Returns the number of rows of the represented matrix or vector."""
        return _pymdlsdk.IUint32_2_get_number_of_rows(self)

    def get_number_of_columns(self):
        r"""
        Returns the number of columns of the represented matrix.

        Always returns 1 in case of vectors.
        """
        return _pymdlsdk.IUint32_2_get_number_of_columns(self)

    def get_length(self):
        r"""
        Returns the total number of elements.

        This value is the product of #get_number_of_rows() and #get_number_of_columns().
        """
        return _pymdlsdk.IUint32_2_get_length(self)

    def get_element_type_name(self):
        r""" Returns the type name of elements of the compound."""
        return _pymdlsdk.IUint32_2_get_element_type_name(self)

    def get_values(self, *args):
        r"""
        *Overload 1:*
        Accesses the elements of the compound.

        :type values: boolean
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IUint32_2_get_values(self, *args)

    def set_values(self, *args):
        r"""
        *Overload 1:*
        Sets the elements of the compound.

        :type values: boolean
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IUint32_2_set_values(self, *args)

    def get_key(self, index):
        r"""
        Returns the key corresponding to ``index``.

        :rtype: string
        :return: The key, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IUint32_2_get_key(self, index)

    def has_key(self, key):
        r""" Indicates whether the key ``key`` exists or not."""
        return _pymdlsdk.IUint32_2_has_key(self, key)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IUint32_2_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IUint32_2__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IUint32_2__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IUint32_2_get_iid(self)

# Register IUint32_2 in _pymdlsdk:
_pymdlsdk.IUint32_2_swigregister(IUint32_2)

def IUint32_2_IID():
    return _pymdlsdk.IUint32_2_IID()

def IUint32_2__get_interface(iface):
    return _pymdlsdk.IUint32_2__get_interface(iface)

class IUint32_3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IUint32_3_swiginit(self, _pymdlsdk.new_IUint32_3(*args))
    __swig_destroy__ = _pymdlsdk.delete_IUint32_3

    def __deref__(self):
        return _pymdlsdk.IUint32_3___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IUint32_3___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IUint32_3_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IUint32_3___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IUint32_3___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IUint32_3_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IUint32_3_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IUint32_3__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk.IUint32_3_set_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IUint32_3_compare_iid(self, iid)

    def get_number_of_rows(self):
        r""" Returns the number of rows of the represented matrix or vector."""
        return _pymdlsdk.IUint32_3_get_number_of_rows(self)

    def get_number_of_columns(self):
        r"""
        Returns the number of columns of the represented matrix.

        Always returns 1 in case of vectors.
        """
        return _pymdlsdk.IUint32_3_get_number_of_columns(self)

    def get_length(self):
        r"""
        Returns the total number of elements.

        This value is the product of #get_number_of_rows() and #get_number_of_columns().
        """
        return _pymdlsdk.IUint32_3_get_length(self)

    def get_element_type_name(self):
        r""" Returns the type name of elements of the compound."""
        return _pymdlsdk.IUint32_3_get_element_type_name(self)

    def get_values(self, *args):
        r"""
        *Overload 1:*
        Accesses the elements of the compound.

        :type values: boolean
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IUint32_3_get_values(self, *args)

    def set_values(self, *args):
        r"""
        *Overload 1:*
        Sets the elements of the compound.

        :type values: boolean
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IUint32_3_set_values(self, *args)

    def get_key(self, index):
        r"""
        Returns the key corresponding to ``index``.

        :rtype: string
        :return: The key, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IUint32_3_get_key(self, index)

    def has_key(self, key):
        r""" Indicates whether the key ``key`` exists or not."""
        return _pymdlsdk.IUint32_3_has_key(self, key)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IUint32_3_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IUint32_3__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IUint32_3__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IUint32_3_get_iid(self)

# Register IUint32_3 in _pymdlsdk:
_pymdlsdk.IUint32_3_swigregister(IUint32_3)

def IUint32_3_IID():
    return _pymdlsdk.IUint32_3_IID()

def IUint32_3__get_interface(iface):
    return _pymdlsdk.IUint32_3__get_interface(iface)

class IUint32_4(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IUint32_4_swiginit(self, _pymdlsdk.new_IUint32_4(*args))
    __swig_destroy__ = _pymdlsdk.delete_IUint32_4

    def __deref__(self):
        return _pymdlsdk.IUint32_4___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IUint32_4___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IUint32_4_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IUint32_4___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IUint32_4___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IUint32_4_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IUint32_4_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IUint32_4__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk.IUint32_4_set_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IUint32_4_compare_iid(self, iid)

    def get_number_of_rows(self):
        r""" Returns the number of rows of the represented matrix or vector."""
        return _pymdlsdk.IUint32_4_get_number_of_rows(self)

    def get_number_of_columns(self):
        r"""
        Returns the number of columns of the represented matrix.

        Always returns 1 in case of vectors.
        """
        return _pymdlsdk.IUint32_4_get_number_of_columns(self)

    def get_length(self):
        r"""
        Returns the total number of elements.

        This value is the product of #get_number_of_rows() and #get_number_of_columns().
        """
        return _pymdlsdk.IUint32_4_get_length(self)

    def get_element_type_name(self):
        r""" Returns the type name of elements of the compound."""
        return _pymdlsdk.IUint32_4_get_element_type_name(self)

    def get_values(self, *args):
        r"""
        *Overload 1:*
        Accesses the elements of the compound.

        :type values: boolean
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IUint32_4_get_values(self, *args)

    def set_values(self, *args):
        r"""
        *Overload 1:*
        Sets the elements of the compound.

        :type values: boolean
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IUint32_4_set_values(self, *args)

    def get_key(self, index):
        r"""
        Returns the key corresponding to ``index``.

        :rtype: string
        :return: The key, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IUint32_4_get_key(self, index)

    def has_key(self, key):
        r""" Indicates whether the key ``key`` exists or not."""
        return _pymdlsdk.IUint32_4_has_key(self, key)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IUint32_4_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IUint32_4__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IUint32_4__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IUint32_4_get_iid(self)

# Register IUint32_4 in _pymdlsdk:
_pymdlsdk.IUint32_4_swigregister(IUint32_4)

def IUint32_4_IID():
    return _pymdlsdk.IUint32_4_IID()

def IUint32_4__get_interface(iface):
    return _pymdlsdk.IUint32_4__get_interface(iface)

class IFloat32_2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IFloat32_2_swiginit(self, _pymdlsdk.new_IFloat32_2(*args))
    __swig_destroy__ = _pymdlsdk.delete_IFloat32_2

    def __deref__(self):
        return _pymdlsdk.IFloat32_2___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IFloat32_2___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IFloat32_2_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IFloat32_2___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IFloat32_2___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IFloat32_2_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IFloat32_2_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IFloat32_2__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk.IFloat32_2_set_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IFloat32_2_compare_iid(self, iid)

    def get_number_of_rows(self):
        r""" Returns the number of rows of the represented matrix or vector."""
        return _pymdlsdk.IFloat32_2_get_number_of_rows(self)

    def get_number_of_columns(self):
        r"""
        Returns the number of columns of the represented matrix.

        Always returns 1 in case of vectors.
        """
        return _pymdlsdk.IFloat32_2_get_number_of_columns(self)

    def get_length(self):
        r"""
        Returns the total number of elements.

        This value is the product of #get_number_of_rows() and #get_number_of_columns().
        """
        return _pymdlsdk.IFloat32_2_get_length(self)

    def get_element_type_name(self):
        r""" Returns the type name of elements of the compound."""
        return _pymdlsdk.IFloat32_2_get_element_type_name(self)

    def get_values(self, *args):
        r"""
        *Overload 1:*
        Accesses the elements of the compound.

        :type values: boolean
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IFloat32_2_get_values(self, *args)

    def set_values(self, *args):
        r"""
        *Overload 1:*
        Sets the elements of the compound.

        :type values: boolean
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IFloat32_2_set_values(self, *args)

    def get_key(self, index):
        r"""
        Returns the key corresponding to ``index``.

        :rtype: string
        :return: The key, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IFloat32_2_get_key(self, index)

    def has_key(self, key):
        r""" Indicates whether the key ``key`` exists or not."""
        return _pymdlsdk.IFloat32_2_has_key(self, key)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IFloat32_2_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IFloat32_2__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IFloat32_2__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IFloat32_2_get_iid(self)

# Register IFloat32_2 in _pymdlsdk:
_pymdlsdk.IFloat32_2_swigregister(IFloat32_2)

def IFloat32_2_IID():
    return _pymdlsdk.IFloat32_2_IID()

def IFloat32_2__get_interface(iface):
    return _pymdlsdk.IFloat32_2__get_interface(iface)

class IFloat32_3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IFloat32_3_swiginit(self, _pymdlsdk.new_IFloat32_3(*args))
    __swig_destroy__ = _pymdlsdk.delete_IFloat32_3

    def __deref__(self):
        return _pymdlsdk.IFloat32_3___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IFloat32_3___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IFloat32_3_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IFloat32_3___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IFloat32_3___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IFloat32_3_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IFloat32_3_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IFloat32_3__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk.IFloat32_3_set_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IFloat32_3_compare_iid(self, iid)

    def get_number_of_rows(self):
        r""" Returns the number of rows of the represented matrix or vector."""
        return _pymdlsdk.IFloat32_3_get_number_of_rows(self)

    def get_number_of_columns(self):
        r"""
        Returns the number of columns of the represented matrix.

        Always returns 1 in case of vectors.
        """
        return _pymdlsdk.IFloat32_3_get_number_of_columns(self)

    def get_length(self):
        r"""
        Returns the total number of elements.

        This value is the product of #get_number_of_rows() and #get_number_of_columns().
        """
        return _pymdlsdk.IFloat32_3_get_length(self)

    def get_element_type_name(self):
        r""" Returns the type name of elements of the compound."""
        return _pymdlsdk.IFloat32_3_get_element_type_name(self)

    def get_values(self, *args):
        r"""
        *Overload 1:*
        Accesses the elements of the compound.

        :type values: boolean
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IFloat32_3_get_values(self, *args)

    def set_values(self, *args):
        r"""
        *Overload 1:*
        Sets the elements of the compound.

        :type values: boolean
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IFloat32_3_set_values(self, *args)

    def get_key(self, index):
        r"""
        Returns the key corresponding to ``index``.

        :rtype: string
        :return: The key, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IFloat32_3_get_key(self, index)

    def has_key(self, key):
        r""" Indicates whether the key ``key`` exists or not."""
        return _pymdlsdk.IFloat32_3_has_key(self, key)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IFloat32_3_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IFloat32_3__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IFloat32_3__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IFloat32_3_get_iid(self)

# Register IFloat32_3 in _pymdlsdk:
_pymdlsdk.IFloat32_3_swigregister(IFloat32_3)

def IFloat32_3_IID():
    return _pymdlsdk.IFloat32_3_IID()

def IFloat32_3__get_interface(iface):
    return _pymdlsdk.IFloat32_3__get_interface(iface)

class IFloat32_4(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IFloat32_4_swiginit(self, _pymdlsdk.new_IFloat32_4(*args))
    __swig_destroy__ = _pymdlsdk.delete_IFloat32_4

    def __deref__(self):
        return _pymdlsdk.IFloat32_4___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IFloat32_4___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IFloat32_4_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IFloat32_4___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IFloat32_4___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IFloat32_4_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IFloat32_4_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IFloat32_4__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk.IFloat32_4_set_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IFloat32_4_compare_iid(self, iid)

    def get_number_of_rows(self):
        r""" Returns the number of rows of the represented matrix or vector."""
        return _pymdlsdk.IFloat32_4_get_number_of_rows(self)

    def get_number_of_columns(self):
        r"""
        Returns the number of columns of the represented matrix.

        Always returns 1 in case of vectors.
        """
        return _pymdlsdk.IFloat32_4_get_number_of_columns(self)

    def get_length(self):
        r"""
        Returns the total number of elements.

        This value is the product of #get_number_of_rows() and #get_number_of_columns().
        """
        return _pymdlsdk.IFloat32_4_get_length(self)

    def get_element_type_name(self):
        r""" Returns the type name of elements of the compound."""
        return _pymdlsdk.IFloat32_4_get_element_type_name(self)

    def get_values(self, *args):
        r"""
        *Overload 1:*
        Accesses the elements of the compound.

        :type values: boolean
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IFloat32_4_get_values(self, *args)

    def set_values(self, *args):
        r"""
        *Overload 1:*
        Sets the elements of the compound.

        :type values: boolean
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IFloat32_4_set_values(self, *args)

    def get_key(self, index):
        r"""
        Returns the key corresponding to ``index``.

        :rtype: string
        :return: The key, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IFloat32_4_get_key(self, index)

    def has_key(self, key):
        r""" Indicates whether the key ``key`` exists or not."""
        return _pymdlsdk.IFloat32_4_has_key(self, key)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IFloat32_4_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IFloat32_4__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IFloat32_4__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IFloat32_4_get_iid(self)

# Register IFloat32_4 in _pymdlsdk:
_pymdlsdk.IFloat32_4_swigregister(IFloat32_4)

def IFloat32_4_IID():
    return _pymdlsdk.IFloat32_4_IID()

def IFloat32_4__get_interface(iface):
    return _pymdlsdk.IFloat32_4__get_interface(iface)

class IFloat64_2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IFloat64_2_swiginit(self, _pymdlsdk.new_IFloat64_2(*args))
    __swig_destroy__ = _pymdlsdk.delete_IFloat64_2

    def __deref__(self):
        return _pymdlsdk.IFloat64_2___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IFloat64_2___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IFloat64_2_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IFloat64_2___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IFloat64_2___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IFloat64_2_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IFloat64_2_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IFloat64_2__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk.IFloat64_2_set_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IFloat64_2_compare_iid(self, iid)

    def get_number_of_rows(self):
        r""" Returns the number of rows of the represented matrix or vector."""
        return _pymdlsdk.IFloat64_2_get_number_of_rows(self)

    def get_number_of_columns(self):
        r"""
        Returns the number of columns of the represented matrix.

        Always returns 1 in case of vectors.
        """
        return _pymdlsdk.IFloat64_2_get_number_of_columns(self)

    def get_length(self):
        r"""
        Returns the total number of elements.

        This value is the product of #get_number_of_rows() and #get_number_of_columns().
        """
        return _pymdlsdk.IFloat64_2_get_length(self)

    def get_element_type_name(self):
        r""" Returns the type name of elements of the compound."""
        return _pymdlsdk.IFloat64_2_get_element_type_name(self)

    def get_values(self, *args):
        r"""
        *Overload 1:*
        Accesses the elements of the compound.

        :type values: boolean
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IFloat64_2_get_values(self, *args)

    def set_values(self, *args):
        r"""
        *Overload 1:*
        Sets the elements of the compound.

        :type values: boolean
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IFloat64_2_set_values(self, *args)

    def get_key(self, index):
        r"""
        Returns the key corresponding to ``index``.

        :rtype: string
        :return: The key, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IFloat64_2_get_key(self, index)

    def has_key(self, key):
        r""" Indicates whether the key ``key`` exists or not."""
        return _pymdlsdk.IFloat64_2_has_key(self, key)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IFloat64_2_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IFloat64_2__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IFloat64_2__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IFloat64_2_get_iid(self)

# Register IFloat64_2 in _pymdlsdk:
_pymdlsdk.IFloat64_2_swigregister(IFloat64_2)

def IFloat64_2_IID():
    return _pymdlsdk.IFloat64_2_IID()

def IFloat64_2__get_interface(iface):
    return _pymdlsdk.IFloat64_2__get_interface(iface)

class IFloat64_3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IFloat64_3_swiginit(self, _pymdlsdk.new_IFloat64_3(*args))
    __swig_destroy__ = _pymdlsdk.delete_IFloat64_3

    def __deref__(self):
        return _pymdlsdk.IFloat64_3___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IFloat64_3___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IFloat64_3_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IFloat64_3___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IFloat64_3___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IFloat64_3_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IFloat64_3_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IFloat64_3__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk.IFloat64_3_set_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IFloat64_3_compare_iid(self, iid)

    def get_number_of_rows(self):
        r""" Returns the number of rows of the represented matrix or vector."""
        return _pymdlsdk.IFloat64_3_get_number_of_rows(self)

    def get_number_of_columns(self):
        r"""
        Returns the number of columns of the represented matrix.

        Always returns 1 in case of vectors.
        """
        return _pymdlsdk.IFloat64_3_get_number_of_columns(self)

    def get_length(self):
        r"""
        Returns the total number of elements.

        This value is the product of #get_number_of_rows() and #get_number_of_columns().
        """
        return _pymdlsdk.IFloat64_3_get_length(self)

    def get_element_type_name(self):
        r""" Returns the type name of elements of the compound."""
        return _pymdlsdk.IFloat64_3_get_element_type_name(self)

    def get_values(self, *args):
        r"""
        *Overload 1:*
        Accesses the elements of the compound.

        :type values: boolean
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IFloat64_3_get_values(self, *args)

    def set_values(self, *args):
        r"""
        *Overload 1:*
        Sets the elements of the compound.

        :type values: boolean
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IFloat64_3_set_values(self, *args)

    def get_key(self, index):
        r"""
        Returns the key corresponding to ``index``.

        :rtype: string
        :return: The key, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IFloat64_3_get_key(self, index)

    def has_key(self, key):
        r""" Indicates whether the key ``key`` exists or not."""
        return _pymdlsdk.IFloat64_3_has_key(self, key)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IFloat64_3_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IFloat64_3__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IFloat64_3__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IFloat64_3_get_iid(self)

# Register IFloat64_3 in _pymdlsdk:
_pymdlsdk.IFloat64_3_swigregister(IFloat64_3)

def IFloat64_3_IID():
    return _pymdlsdk.IFloat64_3_IID()

def IFloat64_3__get_interface(iface):
    return _pymdlsdk.IFloat64_3__get_interface(iface)

class IFloat64_4(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IFloat64_4_swiginit(self, _pymdlsdk.new_IFloat64_4(*args))
    __swig_destroy__ = _pymdlsdk.delete_IFloat64_4

    def __deref__(self):
        return _pymdlsdk.IFloat64_4___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IFloat64_4___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IFloat64_4_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IFloat64_4___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IFloat64_4___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IFloat64_4_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IFloat64_4_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IFloat64_4__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the vector represented by this interface.

        |

        *Overload 2:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 3:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 4:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 5:*
        Sets the (``row``, ``column)-th`` element to ``value``.


        |

        *Overload 6:*
        Sets the (``row``, ``column)-th`` element to ``value``.
        """
        return _pymdlsdk.IFloat64_4_set_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IFloat64_4_compare_iid(self, iid)

    def get_number_of_rows(self):
        r""" Returns the number of rows of the represented matrix or vector."""
        return _pymdlsdk.IFloat64_4_get_number_of_rows(self)

    def get_number_of_columns(self):
        r"""
        Returns the number of columns of the represented matrix.

        Always returns 1 in case of vectors.
        """
        return _pymdlsdk.IFloat64_4_get_number_of_columns(self)

    def get_length(self):
        r"""
        Returns the total number of elements.

        This value is the product of #get_number_of_rows() and #get_number_of_columns().
        """
        return _pymdlsdk.IFloat64_4_get_length(self)

    def get_element_type_name(self):
        r""" Returns the type name of elements of the compound."""
        return _pymdlsdk.IFloat64_4_get_element_type_name(self)

    def get_values(self, *args):
        r"""
        *Overload 1:*
        Accesses the elements of the compound.

        :type values: boolean
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Accesses the elements of the compound.

        :type values: int
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Accesses the elements of the compound.

        :type values: float
        :param values:   The values of the compound elements are written to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IFloat64_4_get_values(self, *args)

    def set_values(self, *args):
        r"""
        *Overload 1:*
        Sets the elements of the compound.

        :type values: boolean
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(bool)``.

        |

        *Overload 2:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Sint32)``.

        |

        *Overload 3:*
        Sets the elements of the compound.

        :type values: int
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Uint32)``.

        |

        *Overload 4:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float32)``.

        |

        *Overload 5:*
        Sets the elements of the compound.

        :type values: float
        :param values:   The new values of the compound elements are read to this buffer. The size of
                            the buffer has to be at least #get_length() times ``sizeof(Float64)``.
        """
        return _pymdlsdk.IFloat64_4_set_values(self, *args)

    def get_key(self, index):
        r"""
        Returns the key corresponding to ``index``.

        :rtype: string
        :return: The key, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IFloat64_4_get_key(self, index)

    def has_key(self, key):
        r""" Indicates whether the key ``key`` exists or not."""
        return _pymdlsdk.IFloat64_4_has_key(self, key)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IFloat64_4_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IFloat64_4__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IFloat64_4__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IFloat64_4_get_iid(self)

# Register IFloat64_4 in _pymdlsdk:
_pymdlsdk.IFloat64_4_swigregister(IFloat64_4)

def IFloat64_4_IID():
    return _pymdlsdk.IFloat64_4_IID()

def IFloat64_4__get_interface(iface):
    return _pymdlsdk.IFloat64_4__get_interface(iface)

class IDifference(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IDifference_swiginit(self, _pymdlsdk.new_IDifference(*args))
    __swig_destroy__ = _pymdlsdk.delete_IDifference

    def __deref__(self):
        return _pymdlsdk.IDifference___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IDifference___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IDifference_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IDifference___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IDifference___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IDifference_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IDifference_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IDifference__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IDifference_compare_iid(self, iid)

    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value of the object as bool.

        |

        *Overload 2:*
        Returns the value of the object as #mi::Uint8.

        |

        *Overload 3:*
        Returns the value of the object as #mi::Uint16.

        |

        *Overload 4:*
        Returns the value of the object as #mi::Uint32.

        |

        *Overload 5:*
        Returns the value of the object as #mi::Uint64.

        |

        *Overload 6:*
        Returns the value of the object as #mi::Sint8.

        |

        *Overload 7:*
        Returns the value of the object as #mi::Sint16.

        |

        *Overload 8:*
        Returns the value of the object as #mi::Sint32.

        |

        *Overload 9:*
        Returns the value of the object as #mi::Sint64.

        |

        *Overload 10:*
        Returns the value of the object as #mi::Float32.

        |

        *Overload 11:*
        Returns the value of the object as #mi::Float64.
        """
        return _pymdlsdk.IDifference_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the value of the object via a parameter of type bool.

        |

        *Overload 2:*
        Sets the value of the object via a parameter of type #mi::Uint8.

        |

        *Overload 3:*
        Sets the value of the object via a parameter of type #mi::Uint16.

        |

        *Overload 4:*
        Sets the value of the object via a parameter of type #mi::Uint32.

        |

        *Overload 5:*
        Sets the value of the object via a parameter of type #mi::Uint64.

        |

        *Overload 6:*
        Sets the value of the object via a parameter of type #mi::Sint8.

        |

        *Overload 7:*
        Sets the value of the object via a parameter of type #mi::Sint16.

        |

        *Overload 8:*
        Sets the value of the object via a parameter of type #mi::Sint32.

        |

        *Overload 9:*
        Sets the value of the object via a parameter of type #mi::Sint64.

        |

        *Overload 10:*
        Sets the value of the object via a parameter of type #mi::Float32.

        |

        *Overload 11:*
        Sets the value of the object via a parameter of type #mi::Float64.
        """
        return _pymdlsdk.IDifference_set_value(self, *args)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IDifference_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IDifference__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IDifference__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IDifference_get_iid(self)

# Register IDifference in _pymdlsdk:
_pymdlsdk.IDifference_swigregister(IDifference)

def IDifference_IID():
    return _pymdlsdk.IDifference_IID()

def IDifference__get_interface(iface):
    return _pymdlsdk.IDifference__get_interface(iface)

class IString(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IString_swiginit(self, _pymdlsdk.new_IString(*args))
    __swig_destroy__ = _pymdlsdk.delete_IString

    def __deref__(self):
        return _pymdlsdk.IString___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IString___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IString_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IString___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IString___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IString_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IString_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IString__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_c_str(self):
        r"""
        Returns the content as a C-style string.

        :rtype: string
        :return: The stored string as a C-style string. Never returns ``NULL``.
        """
        return _pymdlsdk.IString_get_c_str(self)

    def set_c_str(self, str):
        r"""
        Sets the content via a C-style string.

        :type str: string
        :param str:   The string to store as a C-style string. The value ``NULL`` is treated as the
                         empty string.
        """
        return _pymdlsdk.IString_set_c_str(self, str)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IString_compare_iid(self, iid)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IString_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IString__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IString__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IString_get_iid(self)

# Register IString in _pymdlsdk:
_pymdlsdk.IString_swigregister(IString)

def IString_IID():
    return _pymdlsdk.IString_IID()

def IString__get_interface(iface):
    return _pymdlsdk.IString__get_interface(iface)

class IData(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IData_swiginit(self, _pymdlsdk.new_IData(*args))
    __swig_destroy__ = _pymdlsdk.delete_IData

    def __deref__(self):
        return _pymdlsdk.IData___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IData___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IData_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IData___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IData___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IData_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IData_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IData__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IData_get_type_name(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IData_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IData__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IData__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IData_get_iid(self)

# Register IData in _pymdlsdk:
_pymdlsdk.IData_swigregister(IData)

def IData_IID():
    return _pymdlsdk.IData_IID()

def IData__get_interface(iface):
    return _pymdlsdk.IData__get_interface(iface)

class IData_simple(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IData_simple_swiginit(self, _pymdlsdk.new_IData_simple(*args))
    __swig_destroy__ = _pymdlsdk.delete_IData_simple

    def __deref__(self):
        return _pymdlsdk.IData_simple___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IData_simple___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IData_simple_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IData_simple___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IData_simple___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IData_simple_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IData_simple_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IData_simple__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IData_simple_compare_iid(self, iid)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IData_simple_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IData_simple__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IData_simple__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IData_simple_get_iid(self)

# Register IData_simple in _pymdlsdk:
_pymdlsdk.IData_simple_swigregister(IData_simple)

def IData_simple_IID():
    return _pymdlsdk.IData_simple_IID()

def IData_simple__get_interface(iface):
    return _pymdlsdk.IData_simple__get_interface(iface)

class IData_collection(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IData_collection_swiginit(self, _pymdlsdk.new_IData_collection(*args))
    __swig_destroy__ = _pymdlsdk.delete_IData_collection

    def __deref__(self):
        return _pymdlsdk.IData_collection___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IData_collection___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IData_collection_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IData_collection___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IData_collection___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IData_collection_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IData_collection_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IData_collection__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_length(self):
        r""" Returns the number of values."""
        return _pymdlsdk.IData_collection_get_length(self)

    def get_key(self, index):
        r"""
        Returns the key corresponding to ``index``.

        :rtype: string
        :return: The key, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IData_collection_get_key(self, index)

    def has_key(self, key):
        r""" Indicates whether the key ``key`` exists or not."""
        return _pymdlsdk.IData_collection_has_key(self, key)

    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value for key ``key``.

        Notes: If a literal ``0`` is passed for ``key``, the call is ambiguous. You need to
                  explicitly cast the argument to ``const`` ``char*``.

        |

        *Overload 2:*
        Returns the value for key ``key``.

        Notes: If a literal ``0`` is passed for ``key``, the call is ambiguous. You need to
                  explicitly cast the argument to ``const`` ``char*``.

        |

        *Overload 3:*
        Returns the value for index ``index``.

        Notes: If a literal ``0`` is passed for ``index``, the call is ambiguous. You need to
                  explicitly cast the argument to #mi::Size.

        |

        *Overload 4:*
        Returns the value for index ``index``.

        Notes: If a literal ``0`` is passed for ``index``, the call is ambiguous. You need to
                  explicitly cast the argument to #mi::Size.
        """
        return _pymdlsdk.IData_collection_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Stores the value for key ``key``.

        Note that it is not possible to create new keys.

        Notes: If a literal ``0`` is passed for ``key``, the call is ambiguous. You need to
                  explicitly cast the argument to ``const`` ``char*``.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: Invalid key.
                      - -3: ``value`` has the wrong type.

        |

        *Overload 2:*
        Stores the value for index ``index``.

        Note that it is not possible to create new indices.

        Notes: If a literal ``0`` is passed for ``index``, the call is ambiguous. You need to
                  explicitly cast the argument to #mi::Size.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: Invalid index.
                      - -3: ``value`` has the wrong type.
        """
        return _pymdlsdk.IData_collection_set_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IData_collection_compare_iid(self, iid)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IData_collection_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IData_collection__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IData_collection__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IData_collection_get_iid(self)

# Register IData_collection in _pymdlsdk:
_pymdlsdk.IData_collection_swigregister(IData_collection)

def IData_collection_IID():
    return _pymdlsdk.IData_collection_IID()

def IData_collection__get_interface(iface):
    return _pymdlsdk.IData_collection__get_interface(iface)

class IFloat32(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IFloat32_swiginit(self, _pymdlsdk.new_IFloat32(*args))
    __swig_destroy__ = _pymdlsdk.delete_IFloat32

    def __deref__(self):
        return _pymdlsdk.IFloat32___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IFloat32___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IFloat32_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IFloat32___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IFloat32___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IFloat32_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IFloat32_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IFloat32__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_value(self):
        return _pymdlsdk.IFloat32_get_value(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IFloat32_compare_iid(self, iid)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the value of the object via a parameter of type bool.

        |

        *Overload 2:*
        Sets the value of the object via a parameter of type #mi::Uint8.

        |

        *Overload 3:*
        Sets the value of the object via a parameter of type #mi::Uint16.

        |

        *Overload 4:*
        Sets the value of the object via a parameter of type #mi::Uint32.

        |

        *Overload 5:*
        Sets the value of the object via a parameter of type #mi::Uint64.

        |

        *Overload 6:*
        Sets the value of the object via a parameter of type #mi::Sint8.

        |

        *Overload 7:*
        Sets the value of the object via a parameter of type #mi::Sint16.

        |

        *Overload 8:*
        Sets the value of the object via a parameter of type #mi::Sint32.

        |

        *Overload 9:*
        Sets the value of the object via a parameter of type #mi::Sint64.

        |

        *Overload 10:*
        Sets the value of the object via a parameter of type #mi::Float32.

        |

        *Overload 11:*
        Sets the value of the object via a parameter of type #mi::Float64.
        """
        return _pymdlsdk.IFloat32_set_value(self, *args)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IFloat32_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IFloat32__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IFloat32__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IFloat32_get_iid(self)

# Register IFloat32 in _pymdlsdk:
_pymdlsdk.IFloat32_swigregister(IFloat32)

def IFloat32_IID():
    return _pymdlsdk.IFloat32_IID()

def IFloat32__get_interface(iface):
    return _pymdlsdk.IFloat32__get_interface(iface)

class IFloat64(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IFloat64_swiginit(self, _pymdlsdk.new_IFloat64(*args))
    __swig_destroy__ = _pymdlsdk.delete_IFloat64

    def __deref__(self):
        return _pymdlsdk.IFloat64___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IFloat64___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IFloat64_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IFloat64___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IFloat64___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IFloat64_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IFloat64_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IFloat64__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IFloat64_compare_iid(self, iid)

    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value of the object as bool.

        |

        *Overload 2:*
        Returns the value of the object as #mi::Uint8.

        |

        *Overload 3:*
        Returns the value of the object as #mi::Uint16.

        |

        *Overload 4:*
        Returns the value of the object as #mi::Uint32.

        |

        *Overload 5:*
        Returns the value of the object as #mi::Uint64.

        |

        *Overload 6:*
        Returns the value of the object as #mi::Sint8.

        |

        *Overload 7:*
        Returns the value of the object as #mi::Sint16.

        |

        *Overload 8:*
        Returns the value of the object as #mi::Sint32.

        |

        *Overload 9:*
        Returns the value of the object as #mi::Sint64.

        |

        *Overload 10:*
        Returns the value of the object as #mi::Float32.

        |

        *Overload 11:*
        Returns the value of the object as #mi::Float64.
        """
        return _pymdlsdk.IFloat64_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the value of the object via a parameter of type bool.

        |

        *Overload 2:*
        Sets the value of the object via a parameter of type #mi::Uint8.

        |

        *Overload 3:*
        Sets the value of the object via a parameter of type #mi::Uint16.

        |

        *Overload 4:*
        Sets the value of the object via a parameter of type #mi::Uint32.

        |

        *Overload 5:*
        Sets the value of the object via a parameter of type #mi::Uint64.

        |

        *Overload 6:*
        Sets the value of the object via a parameter of type #mi::Sint8.

        |

        *Overload 7:*
        Sets the value of the object via a parameter of type #mi::Sint16.

        |

        *Overload 8:*
        Sets the value of the object via a parameter of type #mi::Sint32.

        |

        *Overload 9:*
        Sets the value of the object via a parameter of type #mi::Sint64.

        |

        *Overload 10:*
        Sets the value of the object via a parameter of type #mi::Float32.

        |

        *Overload 11:*
        Sets the value of the object via a parameter of type #mi::Float64.
        """
        return _pymdlsdk.IFloat64_set_value(self, *args)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IFloat64_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IFloat64__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IFloat64__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IFloat64_get_iid(self)

# Register IFloat64 in _pymdlsdk:
_pymdlsdk.IFloat64_swigregister(IFloat64)

def IFloat64_IID():
    return _pymdlsdk.IFloat64_IID()

def IFloat64__get_interface(iface):
    return _pymdlsdk.IFloat64__get_interface(iface)

class INumber(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.INumber_swiginit(self, _pymdlsdk.new_INumber(*args))
    __swig_destroy__ = _pymdlsdk.delete_INumber

    def __deref__(self):
        return _pymdlsdk.INumber___deref__(self)

    def __ref__(self):
        return _pymdlsdk.INumber___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.INumber_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.INumber___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.INumber___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.INumber_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.INumber_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.INumber__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value of the object as bool.

        |

        *Overload 2:*
        Returns the value of the object as #mi::Uint8.

        |

        *Overload 3:*
        Returns the value of the object as #mi::Uint16.

        |

        *Overload 4:*
        Returns the value of the object as #mi::Uint32.

        |

        *Overload 5:*
        Returns the value of the object as #mi::Uint64.

        |

        *Overload 6:*
        Returns the value of the object as #mi::Sint8.

        |

        *Overload 7:*
        Returns the value of the object as #mi::Sint16.

        |

        *Overload 8:*
        Returns the value of the object as #mi::Sint32.

        |

        *Overload 9:*
        Returns the value of the object as #mi::Sint64.

        |

        *Overload 10:*
        Returns the value of the object as #mi::Float32.

        |

        *Overload 11:*
        Returns the value of the object as #mi::Float64.
        """
        return _pymdlsdk.INumber_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the value of the object via a parameter of type bool.

        |

        *Overload 2:*
        Sets the value of the object via a parameter of type #mi::Uint8.

        |

        *Overload 3:*
        Sets the value of the object via a parameter of type #mi::Uint16.

        |

        *Overload 4:*
        Sets the value of the object via a parameter of type #mi::Uint32.

        |

        *Overload 5:*
        Sets the value of the object via a parameter of type #mi::Uint64.

        |

        *Overload 6:*
        Sets the value of the object via a parameter of type #mi::Sint8.

        |

        *Overload 7:*
        Sets the value of the object via a parameter of type #mi::Sint16.

        |

        *Overload 8:*
        Sets the value of the object via a parameter of type #mi::Sint32.

        |

        *Overload 9:*
        Sets the value of the object via a parameter of type #mi::Sint64.

        |

        *Overload 10:*
        Sets the value of the object via a parameter of type #mi::Float32.

        |

        *Overload 11:*
        Sets the value of the object via a parameter of type #mi::Float64.
        """
        return _pymdlsdk.INumber_set_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.INumber_compare_iid(self, iid)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.INumber_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.INumber__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.INumber__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.INumber_get_iid(self)

# Register INumber in _pymdlsdk:
_pymdlsdk.INumber_swigregister(INumber)

def INumber_IID():
    return _pymdlsdk.INumber_IID()

def INumber__get_interface(iface):
    return _pymdlsdk.INumber__get_interface(iface)

class ISint8(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.ISint8_swiginit(self, _pymdlsdk.new_ISint8(*args))
    __swig_destroy__ = _pymdlsdk.delete_ISint8

    def __deref__(self):
        return _pymdlsdk.ISint8___deref__(self)

    def __ref__(self):
        return _pymdlsdk.ISint8___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.ISint8_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.ISint8___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.ISint8___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.ISint8_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.ISint8_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.ISint8__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.ISint8_compare_iid(self, iid)

    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value of the object as bool.

        |

        *Overload 2:*
        Returns the value of the object as #mi::Uint8.

        |

        *Overload 3:*
        Returns the value of the object as #mi::Uint16.

        |

        *Overload 4:*
        Returns the value of the object as #mi::Uint32.

        |

        *Overload 5:*
        Returns the value of the object as #mi::Uint64.

        |

        *Overload 6:*
        Returns the value of the object as #mi::Sint8.

        |

        *Overload 7:*
        Returns the value of the object as #mi::Sint16.

        |

        *Overload 8:*
        Returns the value of the object as #mi::Sint32.

        |

        *Overload 9:*
        Returns the value of the object as #mi::Sint64.

        |

        *Overload 10:*
        Returns the value of the object as #mi::Float32.

        |

        *Overload 11:*
        Returns the value of the object as #mi::Float64.
        """
        return _pymdlsdk.ISint8_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the value of the object via a parameter of type bool.

        |

        *Overload 2:*
        Sets the value of the object via a parameter of type #mi::Uint8.

        |

        *Overload 3:*
        Sets the value of the object via a parameter of type #mi::Uint16.

        |

        *Overload 4:*
        Sets the value of the object via a parameter of type #mi::Uint32.

        |

        *Overload 5:*
        Sets the value of the object via a parameter of type #mi::Uint64.

        |

        *Overload 6:*
        Sets the value of the object via a parameter of type #mi::Sint8.

        |

        *Overload 7:*
        Sets the value of the object via a parameter of type #mi::Sint16.

        |

        *Overload 8:*
        Sets the value of the object via a parameter of type #mi::Sint32.

        |

        *Overload 9:*
        Sets the value of the object via a parameter of type #mi::Sint64.

        |

        *Overload 10:*
        Sets the value of the object via a parameter of type #mi::Float32.

        |

        *Overload 11:*
        Sets the value of the object via a parameter of type #mi::Float64.
        """
        return _pymdlsdk.ISint8_set_value(self, *args)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.ISint8_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.ISint8__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.ISint8__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.ISint8_get_iid(self)

# Register ISint8 in _pymdlsdk:
_pymdlsdk.ISint8_swigregister(ISint8)

def ISint8_IID():
    return _pymdlsdk.ISint8_IID()

def ISint8__get_interface(iface):
    return _pymdlsdk.ISint8__get_interface(iface)

class ISint16(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.ISint16_swiginit(self, _pymdlsdk.new_ISint16(*args))
    __swig_destroy__ = _pymdlsdk.delete_ISint16

    def __deref__(self):
        return _pymdlsdk.ISint16___deref__(self)

    def __ref__(self):
        return _pymdlsdk.ISint16___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.ISint16_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.ISint16___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.ISint16___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.ISint16_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.ISint16_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.ISint16__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.ISint16_compare_iid(self, iid)

    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value of the object as bool.

        |

        *Overload 2:*
        Returns the value of the object as #mi::Uint8.

        |

        *Overload 3:*
        Returns the value of the object as #mi::Uint16.

        |

        *Overload 4:*
        Returns the value of the object as #mi::Uint32.

        |

        *Overload 5:*
        Returns the value of the object as #mi::Uint64.

        |

        *Overload 6:*
        Returns the value of the object as #mi::Sint8.

        |

        *Overload 7:*
        Returns the value of the object as #mi::Sint16.

        |

        *Overload 8:*
        Returns the value of the object as #mi::Sint32.

        |

        *Overload 9:*
        Returns the value of the object as #mi::Sint64.

        |

        *Overload 10:*
        Returns the value of the object as #mi::Float32.

        |

        *Overload 11:*
        Returns the value of the object as #mi::Float64.
        """
        return _pymdlsdk.ISint16_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the value of the object via a parameter of type bool.

        |

        *Overload 2:*
        Sets the value of the object via a parameter of type #mi::Uint8.

        |

        *Overload 3:*
        Sets the value of the object via a parameter of type #mi::Uint16.

        |

        *Overload 4:*
        Sets the value of the object via a parameter of type #mi::Uint32.

        |

        *Overload 5:*
        Sets the value of the object via a parameter of type #mi::Uint64.

        |

        *Overload 6:*
        Sets the value of the object via a parameter of type #mi::Sint8.

        |

        *Overload 7:*
        Sets the value of the object via a parameter of type #mi::Sint16.

        |

        *Overload 8:*
        Sets the value of the object via a parameter of type #mi::Sint32.

        |

        *Overload 9:*
        Sets the value of the object via a parameter of type #mi::Sint64.

        |

        *Overload 10:*
        Sets the value of the object via a parameter of type #mi::Float32.

        |

        *Overload 11:*
        Sets the value of the object via a parameter of type #mi::Float64.
        """
        return _pymdlsdk.ISint16_set_value(self, *args)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.ISint16_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.ISint16__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.ISint16__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.ISint16_get_iid(self)

# Register ISint16 in _pymdlsdk:
_pymdlsdk.ISint16_swigregister(ISint16)

def ISint16_IID():
    return _pymdlsdk.ISint16_IID()

def ISint16__get_interface(iface):
    return _pymdlsdk.ISint16__get_interface(iface)

class ISint32(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.ISint32_swiginit(self, _pymdlsdk.new_ISint32(*args))
    __swig_destroy__ = _pymdlsdk.delete_ISint32

    def __deref__(self):
        return _pymdlsdk.ISint32___deref__(self)

    def __ref__(self):
        return _pymdlsdk.ISint32___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.ISint32_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.ISint32___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.ISint32___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.ISint32_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.ISint32_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.ISint32__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.ISint32_compare_iid(self, iid)

    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value of the object as bool.

        |

        *Overload 2:*
        Returns the value of the object as #mi::Uint8.

        |

        *Overload 3:*
        Returns the value of the object as #mi::Uint16.

        |

        *Overload 4:*
        Returns the value of the object as #mi::Uint32.

        |

        *Overload 5:*
        Returns the value of the object as #mi::Uint64.

        |

        *Overload 6:*
        Returns the value of the object as #mi::Sint8.

        |

        *Overload 7:*
        Returns the value of the object as #mi::Sint16.

        |

        *Overload 8:*
        Returns the value of the object as #mi::Sint32.

        |

        *Overload 9:*
        Returns the value of the object as #mi::Sint64.

        |

        *Overload 10:*
        Returns the value of the object as #mi::Float32.

        |

        *Overload 11:*
        Returns the value of the object as #mi::Float64.
        """
        return _pymdlsdk.ISint32_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the value of the object via a parameter of type bool.

        |

        *Overload 2:*
        Sets the value of the object via a parameter of type #mi::Uint8.

        |

        *Overload 3:*
        Sets the value of the object via a parameter of type #mi::Uint16.

        |

        *Overload 4:*
        Sets the value of the object via a parameter of type #mi::Uint32.

        |

        *Overload 5:*
        Sets the value of the object via a parameter of type #mi::Uint64.

        |

        *Overload 6:*
        Sets the value of the object via a parameter of type #mi::Sint8.

        |

        *Overload 7:*
        Sets the value of the object via a parameter of type #mi::Sint16.

        |

        *Overload 8:*
        Sets the value of the object via a parameter of type #mi::Sint32.

        |

        *Overload 9:*
        Sets the value of the object via a parameter of type #mi::Sint64.

        |

        *Overload 10:*
        Sets the value of the object via a parameter of type #mi::Float32.

        |

        *Overload 11:*
        Sets the value of the object via a parameter of type #mi::Float64.
        """
        return _pymdlsdk.ISint32_set_value(self, *args)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.ISint32_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.ISint32__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.ISint32__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.ISint32_get_iid(self)

# Register ISint32 in _pymdlsdk:
_pymdlsdk.ISint32_swigregister(ISint32)

def ISint32_IID():
    return _pymdlsdk.ISint32_IID()

def ISint32__get_interface(iface):
    return _pymdlsdk.ISint32__get_interface(iface)

class ISint64(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.ISint64_swiginit(self, _pymdlsdk.new_ISint64(*args))
    __swig_destroy__ = _pymdlsdk.delete_ISint64

    def __deref__(self):
        return _pymdlsdk.ISint64___deref__(self)

    def __ref__(self):
        return _pymdlsdk.ISint64___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.ISint64_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.ISint64___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.ISint64___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.ISint64_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.ISint64_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.ISint64__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.ISint64_compare_iid(self, iid)

    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value of the object as bool.

        |

        *Overload 2:*
        Returns the value of the object as #mi::Uint8.

        |

        *Overload 3:*
        Returns the value of the object as #mi::Uint16.

        |

        *Overload 4:*
        Returns the value of the object as #mi::Uint32.

        |

        *Overload 5:*
        Returns the value of the object as #mi::Uint64.

        |

        *Overload 6:*
        Returns the value of the object as #mi::Sint8.

        |

        *Overload 7:*
        Returns the value of the object as #mi::Sint16.

        |

        *Overload 8:*
        Returns the value of the object as #mi::Sint32.

        |

        *Overload 9:*
        Returns the value of the object as #mi::Sint64.

        |

        *Overload 10:*
        Returns the value of the object as #mi::Float32.

        |

        *Overload 11:*
        Returns the value of the object as #mi::Float64.
        """
        return _pymdlsdk.ISint64_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the value of the object via a parameter of type bool.

        |

        *Overload 2:*
        Sets the value of the object via a parameter of type #mi::Uint8.

        |

        *Overload 3:*
        Sets the value of the object via a parameter of type #mi::Uint16.

        |

        *Overload 4:*
        Sets the value of the object via a parameter of type #mi::Uint32.

        |

        *Overload 5:*
        Sets the value of the object via a parameter of type #mi::Uint64.

        |

        *Overload 6:*
        Sets the value of the object via a parameter of type #mi::Sint8.

        |

        *Overload 7:*
        Sets the value of the object via a parameter of type #mi::Sint16.

        |

        *Overload 8:*
        Sets the value of the object via a parameter of type #mi::Sint32.

        |

        *Overload 9:*
        Sets the value of the object via a parameter of type #mi::Sint64.

        |

        *Overload 10:*
        Sets the value of the object via a parameter of type #mi::Float32.

        |

        *Overload 11:*
        Sets the value of the object via a parameter of type #mi::Float64.
        """
        return _pymdlsdk.ISint64_set_value(self, *args)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.ISint64_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.ISint64__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.ISint64__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.ISint64_get_iid(self)

# Register ISint64 in _pymdlsdk:
_pymdlsdk.ISint64_swigregister(ISint64)

def ISint64_IID():
    return _pymdlsdk.ISint64_IID()

def ISint64__get_interface(iface):
    return _pymdlsdk.ISint64__get_interface(iface)

class ISize(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.ISize_swiginit(self, _pymdlsdk.new_ISize(*args))
    __swig_destroy__ = _pymdlsdk.delete_ISize

    def __deref__(self):
        return _pymdlsdk.ISize___deref__(self)

    def __ref__(self):
        return _pymdlsdk.ISize___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.ISize_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.ISize___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.ISize___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.ISize_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.ISize_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.ISize__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.ISize_compare_iid(self, iid)

    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value of the object as bool.

        |

        *Overload 2:*
        Returns the value of the object as #mi::Uint8.

        |

        *Overload 3:*
        Returns the value of the object as #mi::Uint16.

        |

        *Overload 4:*
        Returns the value of the object as #mi::Uint32.

        |

        *Overload 5:*
        Returns the value of the object as #mi::Uint64.

        |

        *Overload 6:*
        Returns the value of the object as #mi::Sint8.

        |

        *Overload 7:*
        Returns the value of the object as #mi::Sint16.

        |

        *Overload 8:*
        Returns the value of the object as #mi::Sint32.

        |

        *Overload 9:*
        Returns the value of the object as #mi::Sint64.

        |

        *Overload 10:*
        Returns the value of the object as #mi::Float32.

        |

        *Overload 11:*
        Returns the value of the object as #mi::Float64.
        """
        return _pymdlsdk.ISize_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the value of the object via a parameter of type bool.

        |

        *Overload 2:*
        Sets the value of the object via a parameter of type #mi::Uint8.

        |

        *Overload 3:*
        Sets the value of the object via a parameter of type #mi::Uint16.

        |

        *Overload 4:*
        Sets the value of the object via a parameter of type #mi::Uint32.

        |

        *Overload 5:*
        Sets the value of the object via a parameter of type #mi::Uint64.

        |

        *Overload 6:*
        Sets the value of the object via a parameter of type #mi::Sint8.

        |

        *Overload 7:*
        Sets the value of the object via a parameter of type #mi::Sint16.

        |

        *Overload 8:*
        Sets the value of the object via a parameter of type #mi::Sint32.

        |

        *Overload 9:*
        Sets the value of the object via a parameter of type #mi::Sint64.

        |

        *Overload 10:*
        Sets the value of the object via a parameter of type #mi::Float32.

        |

        *Overload 11:*
        Sets the value of the object via a parameter of type #mi::Float64.
        """
        return _pymdlsdk.ISize_set_value(self, *args)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.ISize_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.ISize__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.ISize__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.ISize_get_iid(self)

# Register ISize in _pymdlsdk:
_pymdlsdk.ISize_swigregister(ISize)

def ISize_IID():
    return _pymdlsdk.ISize_IID()

def ISize__get_interface(iface):
    return _pymdlsdk.ISize__get_interface(iface)

class IUint8(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IUint8_swiginit(self, _pymdlsdk.new_IUint8(*args))
    __swig_destroy__ = _pymdlsdk.delete_IUint8

    def __deref__(self):
        return _pymdlsdk.IUint8___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IUint8___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IUint8_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IUint8___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IUint8___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IUint8_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IUint8_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IUint8__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IUint8_compare_iid(self, iid)

    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value of the object as bool.

        |

        *Overload 2:*
        Returns the value of the object as #mi::Uint8.

        |

        *Overload 3:*
        Returns the value of the object as #mi::Uint16.

        |

        *Overload 4:*
        Returns the value of the object as #mi::Uint32.

        |

        *Overload 5:*
        Returns the value of the object as #mi::Uint64.

        |

        *Overload 6:*
        Returns the value of the object as #mi::Sint8.

        |

        *Overload 7:*
        Returns the value of the object as #mi::Sint16.

        |

        *Overload 8:*
        Returns the value of the object as #mi::Sint32.

        |

        *Overload 9:*
        Returns the value of the object as #mi::Sint64.

        |

        *Overload 10:*
        Returns the value of the object as #mi::Float32.

        |

        *Overload 11:*
        Returns the value of the object as #mi::Float64.
        """
        return _pymdlsdk.IUint8_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the value of the object via a parameter of type bool.

        |

        *Overload 2:*
        Sets the value of the object via a parameter of type #mi::Uint8.

        |

        *Overload 3:*
        Sets the value of the object via a parameter of type #mi::Uint16.

        |

        *Overload 4:*
        Sets the value of the object via a parameter of type #mi::Uint32.

        |

        *Overload 5:*
        Sets the value of the object via a parameter of type #mi::Uint64.

        |

        *Overload 6:*
        Sets the value of the object via a parameter of type #mi::Sint8.

        |

        *Overload 7:*
        Sets the value of the object via a parameter of type #mi::Sint16.

        |

        *Overload 8:*
        Sets the value of the object via a parameter of type #mi::Sint32.

        |

        *Overload 9:*
        Sets the value of the object via a parameter of type #mi::Sint64.

        |

        *Overload 10:*
        Sets the value of the object via a parameter of type #mi::Float32.

        |

        *Overload 11:*
        Sets the value of the object via a parameter of type #mi::Float64.
        """
        return _pymdlsdk.IUint8_set_value(self, *args)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IUint8_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IUint8__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IUint8__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IUint8_get_iid(self)

# Register IUint8 in _pymdlsdk:
_pymdlsdk.IUint8_swigregister(IUint8)

def IUint8_IID():
    return _pymdlsdk.IUint8_IID()

def IUint8__get_interface(iface):
    return _pymdlsdk.IUint8__get_interface(iface)

class IUint16(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IUint16_swiginit(self, _pymdlsdk.new_IUint16(*args))
    __swig_destroy__ = _pymdlsdk.delete_IUint16

    def __deref__(self):
        return _pymdlsdk.IUint16___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IUint16___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IUint16_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IUint16___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IUint16___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IUint16_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IUint16_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IUint16__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IUint16_compare_iid(self, iid)

    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value of the object as bool.

        |

        *Overload 2:*
        Returns the value of the object as #mi::Uint8.

        |

        *Overload 3:*
        Returns the value of the object as #mi::Uint16.

        |

        *Overload 4:*
        Returns the value of the object as #mi::Uint32.

        |

        *Overload 5:*
        Returns the value of the object as #mi::Uint64.

        |

        *Overload 6:*
        Returns the value of the object as #mi::Sint8.

        |

        *Overload 7:*
        Returns the value of the object as #mi::Sint16.

        |

        *Overload 8:*
        Returns the value of the object as #mi::Sint32.

        |

        *Overload 9:*
        Returns the value of the object as #mi::Sint64.

        |

        *Overload 10:*
        Returns the value of the object as #mi::Float32.

        |

        *Overload 11:*
        Returns the value of the object as #mi::Float64.
        """
        return _pymdlsdk.IUint16_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the value of the object via a parameter of type bool.

        |

        *Overload 2:*
        Sets the value of the object via a parameter of type #mi::Uint8.

        |

        *Overload 3:*
        Sets the value of the object via a parameter of type #mi::Uint16.

        |

        *Overload 4:*
        Sets the value of the object via a parameter of type #mi::Uint32.

        |

        *Overload 5:*
        Sets the value of the object via a parameter of type #mi::Uint64.

        |

        *Overload 6:*
        Sets the value of the object via a parameter of type #mi::Sint8.

        |

        *Overload 7:*
        Sets the value of the object via a parameter of type #mi::Sint16.

        |

        *Overload 8:*
        Sets the value of the object via a parameter of type #mi::Sint32.

        |

        *Overload 9:*
        Sets the value of the object via a parameter of type #mi::Sint64.

        |

        *Overload 10:*
        Sets the value of the object via a parameter of type #mi::Float32.

        |

        *Overload 11:*
        Sets the value of the object via a parameter of type #mi::Float64.
        """
        return _pymdlsdk.IUint16_set_value(self, *args)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IUint16_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IUint16__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IUint16__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IUint16_get_iid(self)

# Register IUint16 in _pymdlsdk:
_pymdlsdk.IUint16_swigregister(IUint16)

def IUint16_IID():
    return _pymdlsdk.IUint16_IID()

def IUint16__get_interface(iface):
    return _pymdlsdk.IUint16__get_interface(iface)

class IUint32(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IUint32_swiginit(self, _pymdlsdk.new_IUint32(*args))
    __swig_destroy__ = _pymdlsdk.delete_IUint32

    def __deref__(self):
        return _pymdlsdk.IUint32___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IUint32___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IUint32_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IUint32___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IUint32___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IUint32_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IUint32_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IUint32__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IUint32_compare_iid(self, iid)

    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value of the object as bool.

        |

        *Overload 2:*
        Returns the value of the object as #mi::Uint8.

        |

        *Overload 3:*
        Returns the value of the object as #mi::Uint16.

        |

        *Overload 4:*
        Returns the value of the object as #mi::Uint32.

        |

        *Overload 5:*
        Returns the value of the object as #mi::Uint64.

        |

        *Overload 6:*
        Returns the value of the object as #mi::Sint8.

        |

        *Overload 7:*
        Returns the value of the object as #mi::Sint16.

        |

        *Overload 8:*
        Returns the value of the object as #mi::Sint32.

        |

        *Overload 9:*
        Returns the value of the object as #mi::Sint64.

        |

        *Overload 10:*
        Returns the value of the object as #mi::Float32.

        |

        *Overload 11:*
        Returns the value of the object as #mi::Float64.
        """
        return _pymdlsdk.IUint32_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the value of the object via a parameter of type bool.

        |

        *Overload 2:*
        Sets the value of the object via a parameter of type #mi::Uint8.

        |

        *Overload 3:*
        Sets the value of the object via a parameter of type #mi::Uint16.

        |

        *Overload 4:*
        Sets the value of the object via a parameter of type #mi::Uint32.

        |

        *Overload 5:*
        Sets the value of the object via a parameter of type #mi::Uint64.

        |

        *Overload 6:*
        Sets the value of the object via a parameter of type #mi::Sint8.

        |

        *Overload 7:*
        Sets the value of the object via a parameter of type #mi::Sint16.

        |

        *Overload 8:*
        Sets the value of the object via a parameter of type #mi::Sint32.

        |

        *Overload 9:*
        Sets the value of the object via a parameter of type #mi::Sint64.

        |

        *Overload 10:*
        Sets the value of the object via a parameter of type #mi::Float32.

        |

        *Overload 11:*
        Sets the value of the object via a parameter of type #mi::Float64.
        """
        return _pymdlsdk.IUint32_set_value(self, *args)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IUint32_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IUint32__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IUint32__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IUint32_get_iid(self)

# Register IUint32 in _pymdlsdk:
_pymdlsdk.IUint32_swigregister(IUint32)

def IUint32_IID():
    return _pymdlsdk.IUint32_IID()

def IUint32__get_interface(iface):
    return _pymdlsdk.IUint32__get_interface(iface)

class IUint64(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IUint64_swiginit(self, _pymdlsdk.new_IUint64(*args))
    __swig_destroy__ = _pymdlsdk.delete_IUint64

    def __deref__(self):
        return _pymdlsdk.IUint64___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IUint64___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IUint64_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IUint64___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IUint64___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IUint64_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IUint64_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IUint64__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IUint64_compare_iid(self, iid)

    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value of the object as bool.

        |

        *Overload 2:*
        Returns the value of the object as #mi::Uint8.

        |

        *Overload 3:*
        Returns the value of the object as #mi::Uint16.

        |

        *Overload 4:*
        Returns the value of the object as #mi::Uint32.

        |

        *Overload 5:*
        Returns the value of the object as #mi::Uint64.

        |

        *Overload 6:*
        Returns the value of the object as #mi::Sint8.

        |

        *Overload 7:*
        Returns the value of the object as #mi::Sint16.

        |

        *Overload 8:*
        Returns the value of the object as #mi::Sint32.

        |

        *Overload 9:*
        Returns the value of the object as #mi::Sint64.

        |

        *Overload 10:*
        Returns the value of the object as #mi::Float32.

        |

        *Overload 11:*
        Returns the value of the object as #mi::Float64.
        """
        return _pymdlsdk.IUint64_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the value of the object via a parameter of type bool.

        |

        *Overload 2:*
        Sets the value of the object via a parameter of type #mi::Uint8.

        |

        *Overload 3:*
        Sets the value of the object via a parameter of type #mi::Uint16.

        |

        *Overload 4:*
        Sets the value of the object via a parameter of type #mi::Uint32.

        |

        *Overload 5:*
        Sets the value of the object via a parameter of type #mi::Uint64.

        |

        *Overload 6:*
        Sets the value of the object via a parameter of type #mi::Sint8.

        |

        *Overload 7:*
        Sets the value of the object via a parameter of type #mi::Sint16.

        |

        *Overload 8:*
        Sets the value of the object via a parameter of type #mi::Sint32.

        |

        *Overload 9:*
        Sets the value of the object via a parameter of type #mi::Sint64.

        |

        *Overload 10:*
        Sets the value of the object via a parameter of type #mi::Float32.

        |

        *Overload 11:*
        Sets the value of the object via a parameter of type #mi::Float64.
        """
        return _pymdlsdk.IUint64_set_value(self, *args)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IUint64_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IUint64__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IUint64__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IUint64_get_iid(self)

# Register IUint64 in _pymdlsdk:
_pymdlsdk.IUint64_swigregister(IUint64)

def IUint64_IID():
    return _pymdlsdk.IUint64_IID()

def IUint64__get_interface(iface):
    return _pymdlsdk.IUint64__get_interface(iface)

class IVoid(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IVoid_swiginit(self, _pymdlsdk.new_IVoid(*args))
    __swig_destroy__ = _pymdlsdk.delete_IVoid

    def __deref__(self):
        return _pymdlsdk.IVoid___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IVoid___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IVoid_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IVoid___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IVoid___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IVoid_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IVoid_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IVoid__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IVoid_compare_iid(self, iid)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IVoid_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IVoid__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IVoid__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IVoid_get_iid(self)

# Register IVoid in _pymdlsdk:
_pymdlsdk.IVoid_swigregister(IVoid)

def IVoid_IID():
    return _pymdlsdk.IVoid_IID()

def IVoid__get_interface(iface):
    return _pymdlsdk.IVoid__get_interface(iface)

MI_NEURAYLIB_API_VERSION = _pymdlsdk.MI_NEURAYLIB_API_VERSION
r"""
    Major and minor version number and an optional qualifier.

    See 'mi_neuray_version'
    ABI version number.

    A change in this version number indicates that the binary compatibility
    of the interfaces offered through the shared library have changed.

    Despite the name, this number tracks *ABI* changes, not *API* changes.
    """
MI_NEURAYLIB_VERSION_MAJOR = _pymdlsdk.MI_NEURAYLIB_VERSION_MAJOR
r"""
    MDL SDK APImajor version number

    See also: 'mi_base_intro_versioning'
    """
MI_NEURAYLIB_VERSION_MINOR = _pymdlsdk.MI_NEURAYLIB_VERSION_MINOR
r"""
    MDL SDK APIminor version number

    See also: 'mi_base_intro_versioning'
    """
MI_NEURAYLIB_VERSION_QUALIFIER = _pymdlsdk.MI_NEURAYLIB_VERSION_QUALIFIER
r"""
    MDL SDK APIversion qualifier

    The version qualifier is a string such as ``"alpha"``,
    ``"beta"``, or ``"beta2"``, or the empty string ``""`` if this is a final
    release, in which case the macro ``MI_NEURAYLIB_VERSION_QUALIFIER_EMPTY``
    is defined as well.

    See also: 'mi_base_intro_versioning'
    """
MI_NEURAYLIB_PRODUCT_VERSION_STRING = _pymdlsdk.MI_NEURAYLIB_PRODUCT_VERSION_STRING
r"""
    MDL SDK APImajor and minor version number without qualifier in a
    string representation, such as ``"2.0"``.
    MDL SDK APImajor and minor version number and qualifier in a
    string representation, such as ``"2.0"`` or ``"2.0-beta2"``.
    The MDL SDKproduct version number in a string representation, such as ``"2.0"``.
    """
MI_NEURAYLIB_PLUGIN_TYPE = _pymdlsdk.MI_NEURAYLIB_PLUGIN_TYPE
r"""
    Type of plugins for the MDL SDK API.
    See also: #mi::base::Plugin::get_type().
    """
PROPAGATION_STANDARD = _pymdlsdk.PROPAGATION_STANDARD
r""" Standard inheritance of attributes without any special flags."""
PROPAGATION_OVERRIDE = _pymdlsdk.PROPAGATION_OVERRIDE
r""" The ``override`` flag for attribute inheritance."""
PROPAGATION_FORCE_32_BIT = _pymdlsdk.PROPAGATION_FORCE_32_BIT
class Interface_declare_IAttribute_set(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IAttribute_set_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IAttribute_set

# Register Interface_declare_IAttribute_set in _pymdlsdk:
_pymdlsdk.Interface_declare_IAttribute_set_swigregister(Interface_declare_IAttribute_set)

def Interface_declare_IAttribute_set_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IAttribute_set_compare_iid(iid)

class _IAttribute_set(Interface_declare_IAttribute_set):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk._IAttribute_set_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk._IAttribute_set_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk._IAttribute_set_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk._IAttribute_set_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk._IAttribute_set_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk._IAttribute_set_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk._IAttribute_set_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk._IAttribute_set_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk._IAttribute_set_enumerate_attributes(self, index)

# Register _IAttribute_set in _pymdlsdk:
_pymdlsdk._IAttribute_set_swigregister(_IAttribute_set)

ELEMENT_TYPE_INSTANCE = _pymdlsdk.ELEMENT_TYPE_INSTANCE
r""" #mi::neuraylib::IInstance"""
ELEMENT_TYPE_GROUP = _pymdlsdk.ELEMENT_TYPE_GROUP
r""" #mi::neuraylib::IGroup"""
ELEMENT_TYPE_OPTIONS = _pymdlsdk.ELEMENT_TYPE_OPTIONS
r""" #mi::neuraylib::IOptions"""
ELEMENT_TYPE_CAMERA = _pymdlsdk.ELEMENT_TYPE_CAMERA
r""" #mi::neuraylib::ICamera"""
ELEMENT_TYPE_LIGHT = _pymdlsdk.ELEMENT_TYPE_LIGHT
r""" #mi::neuraylib::ILight"""
ELEMENT_TYPE_LIGHTPROFILE = _pymdlsdk.ELEMENT_TYPE_LIGHTPROFILE
r""" #mi::neuraylib::ILightprofile"""
ELEMENT_TYPE_TEXTURE = _pymdlsdk.ELEMENT_TYPE_TEXTURE
r""" #mi::neuraylib::ITexture"""
ELEMENT_TYPE_IMAGE = _pymdlsdk.ELEMENT_TYPE_IMAGE
r""" #mi::neuraylib::IImage"""
ELEMENT_TYPE_TRIANGLE_MESH = _pymdlsdk.ELEMENT_TYPE_TRIANGLE_MESH
r""" #mi::neuraylib::ITriangle_mesh"""
ELEMENT_TYPE_ATTRIBUTE_CONTAINER = _pymdlsdk.ELEMENT_TYPE_ATTRIBUTE_CONTAINER
r""" #mi::neuraylib::IAttribute_container"""
ELEMENT_TYPE_POLYGON_MESH = _pymdlsdk.ELEMENT_TYPE_POLYGON_MESH
r""" #mi::neuraylib::IPolygon_mesh"""
ELEMENT_TYPE_SUBDIVISION_SURFACE = _pymdlsdk.ELEMENT_TYPE_SUBDIVISION_SURFACE
r""" #mi::neuraylib::ISubdivision_surface"""
ELEMENT_TYPE_FREEFORM_SURFACE = _pymdlsdk.ELEMENT_TYPE_FREEFORM_SURFACE
r""" #mi::neuraylib::IFreeform_surface"""
ELEMENT_TYPE_FIBERS = _pymdlsdk.ELEMENT_TYPE_FIBERS
r""" #mi::neuraylib::IFibers"""
ELEMENT_TYPE_VOLUME = _pymdlsdk.ELEMENT_TYPE_VOLUME
r""" #mi::neuraylib::IVolume"""
ELEMENT_TYPE_VOLUME_DATA = _pymdlsdk.ELEMENT_TYPE_VOLUME_DATA
r""" #mi::neuraylib::IVolume_data"""
ELEMENT_TYPE_MODULE = _pymdlsdk.ELEMENT_TYPE_MODULE
r""" #mi::neuraylib::IModule"""
ELEMENT_TYPE_FUNCTION_DEFINITION = _pymdlsdk.ELEMENT_TYPE_FUNCTION_DEFINITION
r""" #mi::neuraylib::IFunction_definition"""
ELEMENT_TYPE_FUNCTION_CALL = _pymdlsdk.ELEMENT_TYPE_FUNCTION_CALL
r""" #mi::neuraylib::IFunction_call"""
ELEMENT_TYPE_MATERIAL_DEFINITION = _pymdlsdk.ELEMENT_TYPE_MATERIAL_DEFINITION
r"""
    #mi::neuraylib::IMaterial_definition
    See also: mi_mdl_materials_are_functions
    """
ELEMENT_TYPE_MATERIAL_INSTANCE = _pymdlsdk.ELEMENT_TYPE_MATERIAL_INSTANCE
r"""
    #mi::neuraylib::IMaterial_instance
    See also: mi_mdl_materials_are_functions
    """
ELEMENT_TYPE_COMPILED_MATERIAL = _pymdlsdk.ELEMENT_TYPE_COMPILED_MATERIAL
r""" #mi::neuraylib::ICompiled_material"""
ELEMENT_TYPE_BSDF_MEASUREMENT = _pymdlsdk.ELEMENT_TYPE_BSDF_MEASUREMENT
r""" #mi::neuraylib::IBsdf_measurement"""
ELEMENT_TYPE_IRRADIANCE_PROBES = _pymdlsdk.ELEMENT_TYPE_IRRADIANCE_PROBES
r""" #mi::neuraylib::IIrradiance_probes"""
ELEMENT_TYPE_DECAL = _pymdlsdk.ELEMENT_TYPE_DECAL
r""" #mi::neuraylib::IDecal"""
ELEMENT_TYPE_ON_DEMAND_MESH = _pymdlsdk.ELEMENT_TYPE_ON_DEMAND_MESH
r""" #mi::neuraylib::IOn_demand_mesh"""
ELEMENT_TYPE_PROJECTOR = _pymdlsdk.ELEMENT_TYPE_PROJECTOR
r""" #mi::neuraylib::IProjector"""
ELEMENT_TYPE_SECTION_OBJECT = _pymdlsdk.ELEMENT_TYPE_SECTION_OBJECT
r""" #mi::neuraylib::ISection_object"""
ELEMENT_TYPE_PROXY = _pymdlsdk.ELEMENT_TYPE_PROXY
r""" #mi::neuraylib::IProxy"""
ELEMENT_TYPE_FORCE_32_BIT = _pymdlsdk.ELEMENT_TYPE_FORCE_32_BIT
class Interface_declare_IScene_element(_IAttribute_set):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IScene_element_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IScene_element

# Register Interface_declare_IScene_element in _pymdlsdk:
_pymdlsdk.Interface_declare_IScene_element_swigregister(Interface_declare_IScene_element)

def Interface_declare_IScene_element_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IScene_element_compare_iid(iid)

class _IScene_element(Interface_declare_IScene_element):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_element_type(self):
        r""" Indicates the actual scene element represented by interfaces derived from this interface."""
        return _pymdlsdk._IScene_element_get_element_type(self)

# Register _IScene_element in _pymdlsdk:
_pymdlsdk._IScene_element_swigregister(_IScene_element)

class Interface_declare_IDatabase(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IDatabase_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IDatabase

# Register Interface_declare_IDatabase in _pymdlsdk:
_pymdlsdk.Interface_declare_IDatabase_swigregister(Interface_declare_IDatabase)

def Interface_declare_IDatabase_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IDatabase_compare_iid(iid)

class _IDatabase(Interface_declare_IDatabase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_global_scope(self):
        r"""
        Returns the global scope which is the root of a tree of scopes

        :rtype: :py:class:`IScope`
        :return: The global scope which is guaranteed to exist after startup of the
                     system.
        """
        return _pymdlsdk._IDatabase_get_global_scope(self)

    def create_scope(self, parent, privacy_level=0, temp=False):
        r"""
        If not: MDL_SDK_API {
        Creates a new optionally temporary scope at the given privacy level with the
        given parent scope ID.

        Notes: A scope continues to exist if the pointer returned by this method is released. Use
              #remove_scope() to remove a scope.

        :type parent: :py:class:`IScope`
        :param parent:         The parent scope for this scope. If the value is ``NULL`` the created
                                  scope will be a child of the global scope.
        :type privacy_level: mi::Uint8, optional
        :param privacy_level:  The privacy level of the scope. This must be higher than the
                                  privacy level of the parent scope. The privacy level of the global
                                  scope is 0 (and the global scope is the only scope with privacy level
                                  0). The default value of 0 indicates the privacy level of the parent
                                  scope plus 1.
        :type temp: boolean, optional
        :param temp:           A bool indicating if the scope is temporary. If the scope is
                                  temporary, then when the host that created the scope is removed
                                  from the cluster the scope and all data contained in the scope
                                  will be removed. If the scope is not temporary, the default,
                                  then when the creating host is removed from the cluster the
                                  scope and all contained data will remain in the database.
        :rtype: :py:class:`IScope`
        :return: The created scope or ``NULL`` if something went wrong.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk._IDatabase_create_scope(self, parent, privacy_level, temp)

    def get_scope(self, id):
        r"""
        Looks up and returns a scope with a given ID.

        :type id: string
        :param id:             The ID of the scope as returned by #mi::neuraylib::IScope::get_id().
        :rtype: :py:class:`IScope`
        :return: The found scope or ``NULL`` if no such scope exists.
        """
        return _pymdlsdk._IDatabase_get_scope(self, id)

    def remove_scope(self, id):
        r"""
        If not: MDL_SDK_API {
        Removes a scope with the specified ID.

        Note that scopes are reference counted. The actual removal will not happen before all
        elements referencing the scope have been released, e.g., child scopes, transactions,
        database elements, including handles to the scope itself.

        It is not possible to remove the global scope.

        :type id: string
        :param id:             The ID of the scope as returned by #mi::neuraylib::IScope::get_id().
        :rtype: int
        :return: 0, in case of success, -1 in case of failure.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk._IDatabase_remove_scope(self, id)

    def lock(self, lock_id):
        r"""
        If not: MDL_SDK_API {
        Acquires a DB lock.

        The method blocks until the requested lock has been obtained. Recursively locking the
        same lock from within the same thread on the same host is supported.

        If the host holding a lock leaves the cluster, the lock is automatically released.

        :type lock_id: int
        :param lock_id:   The lock to acquire.

        Notes: The locking mechanism is kind of a co-operative locking mechanism: The lock does not
              prevent other threads from accessing or editing the DB. It only prevents other threads
              from obtaining the same lock.

        DB locks are not restricted to threads on a single host, they apply to all threads on
              all hosts in the cluster.

        DB locks are an expensive operation and should only be used when absolutely necessary.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk._IDatabase_lock(self, lock_id)

    def unlock(self, lock_id):
        r"""
        If not: MDL_SDK_API {
        Releases a previously obtained DB lock.

        If the lock has been locked several times from within the same thread on the same host,
        it simply decrements the lock count. If the lock count reaches zero, the lock is released.

        :type lock_id: int
        :param lock_id:   The lock to release.
        :rtype: int
        :return: 0, in case of success, -1 in case of failure, i.e, the lock is not held
                             by this thread on this host
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk._IDatabase_unlock(self, lock_id)

    def create_or_get_named_scope(self, name, parent=None, privacy_level=0):
        r"""
        If not: MDL_SDK_API {
        Creates or retrieves a new named scope at the given privacy level with the given parent
        scope ID.

        :type name: string
        :param name:           A name which can be used to lookup the scope.
                                  If a scope with the same name exists already then it will be returned
                                  if the parent and privacy level are identical. Otherwise
                                  creating the scope will fail.
        :type parent: :py:class:`IScope`, optional
        :param parent:         The parent scope for this scope. If the value is ``NULL`` the created
                                  scope will be a child of the global scope.
        :type privacy_level: mi::Uint8, optional
        :param privacy_level:  The privacy level of the scope. This must be higher than the
                                  privacy level of the parent scope. The privacy level of the global
                                  scope is 0 (and the global scope is the only scope with privacy level
                                  0). The default value of 0 indicates the privacy level of the parent
                                  scope plus 1.
        :rtype: :py:class:`IScope`
        :return: The created scope or ``NULL`` if something went wrong.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk._IDatabase_create_or_get_named_scope(self, name, parent, privacy_level)

    def get_named_scope(self, name):
        r"""
        If not: MDL_SDK_API {
        Looks up and returns a scope with a given name.

        :type name: string
        :param name:           The name of the scope
        :rtype: :py:class:`IScope`
        :return: The found scope or ``NULL`` if no such scope exists.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk._IDatabase_get_named_scope(self, name)
    PRIORITY_LOW = _pymdlsdk._IDatabase_PRIORITY_LOW
    r"""
    Low priority for synchronous garbage collection runs. Use this priority if the
    performance of other concurrent DB operations is more important than a fast synchronous
    garbage collection.
    """
    PRIORITY_MEDIUM = _pymdlsdk._IDatabase_PRIORITY_MEDIUM
    r"""
    Medium priority for synchronous garbage collection runs. This priority attempts to
    maintain a balance between the synchronous garbage collection and other concurrent DB
    operations.
    """
    PRIORITY_HIGH = _pymdlsdk._IDatabase_PRIORITY_HIGH
    r"""
    High priority for synchronous garbage collection runs. Other concurrent DB operations
    will experience a large performance drop. Therefore, this priority should not be used
    in multi-user settings.
    """
    PRIORITY_FORCE_32_BIT = _pymdlsdk._IDatabase_PRIORITY_FORCE_32_BIT

    def garbage_collection(self, *args):
        r"""
        Triggers a synchronous garbage collection run.

        The method sweeps through the entire database and removes all database elements which have
        been marked for removal and are no longer referenced. Note that it is not possible to remove
        database elements if there are open transactions in which such an element is still
        referenced.

        To mark an element for removal use If not: DICE_API { #mi::neuraylib::ITransaction::remove().
        }Else: #mi::neuraylib::IDice_transaction::remove() or {
        #mi::neuraylib::IDice_transaction::store_for_reference_counting(). }

        :type priority: int, optional
        :param priority:   The intended priority of the synchronous garbage collection run.
                          If: MDL_SDK_API { The MDL SDK does not support different priorities, and
                          the synchronous garbage collection always runs at highest priority.
                          }
        """
        return _pymdlsdk._IDatabase_garbage_collection(self, *args)

# Register _IDatabase in _pymdlsdk:
_pymdlsdk._IDatabase_swigregister(_IDatabase)

class Interface_declare_IType(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType

# Register Interface_declare_IType in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_swigregister(Interface_declare_IType)

def Interface_declare_IType_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_compare_iid(iid)

class _IType(Interface_declare_IType):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    TK_ALIAS = _pymdlsdk._IType_TK_ALIAS
    r""" An alias for another type, aka typedef. See #mi::neuraylib::IType_alias."""
    TK_BOOL = _pymdlsdk._IType_TK_BOOL
    r""" The ``boolean`` type. See #mi::neuraylib::IType_bool."""
    TK_INT = _pymdlsdk._IType_TK_INT
    r""" The ``integer`` type. See #mi::neuraylib::IType_int."""
    TK_ENUM = _pymdlsdk._IType_TK_ENUM
    r""" An ``enum`` type. See #mi::neuraylib::IType_enum."""
    TK_FLOAT = _pymdlsdk._IType_TK_FLOAT
    r""" The ``float`` type. See #mi::neuraylib::IType_float."""
    TK_DOUBLE = _pymdlsdk._IType_TK_DOUBLE
    r""" The ``double`` type. See #mi::neuraylib::IType_double."""
    TK_STRING = _pymdlsdk._IType_TK_STRING
    r"""  The ``string`` type. See #mi::neuraylib::IType_string."""
    TK_VECTOR = _pymdlsdk._IType_TK_VECTOR
    r""" A vector type. See #mi::neuraylib::IType_vector."""
    TK_MATRIX = _pymdlsdk._IType_TK_MATRIX
    r""" A matrix type. See #mi::neuraylib::IType_matrix."""
    TK_COLOR = _pymdlsdk._IType_TK_COLOR
    r""" The color type. See #mi::neuraylib::IType_color."""
    TK_ARRAY = _pymdlsdk._IType_TK_ARRAY
    r""" An array type. See #mi::neuraylib::IType_array."""
    TK_STRUCT = _pymdlsdk._IType_TK_STRUCT
    r""" A struct type. See #mi::neuraylib::IType_struct."""
    TK_TEXTURE = _pymdlsdk._IType_TK_TEXTURE
    r""" A texture type. See #mi::neuraylib::IType_texture."""
    TK_LIGHT_PROFILE = _pymdlsdk._IType_TK_LIGHT_PROFILE
    r""" The ``light_profile`` type. See #mi::neuraylib::IType_light_profile."""
    TK_BSDF_MEASUREMENT = _pymdlsdk._IType_TK_BSDF_MEASUREMENT
    r""" The ``bsdf_measurement`` type. See #mi::neuraylib::IType_bsdf_measurement."""
    TK_BSDF = _pymdlsdk._IType_TK_BSDF
    r""" The ``bsdf`` type. See #mi::neuraylib::IType_bsdf."""
    TK_HAIR_BSDF = _pymdlsdk._IType_TK_HAIR_BSDF
    r""" The ``hair_bsdf`` type. See #mi::neuraylib::IType_hair_bsdf."""
    TK_EDF = _pymdlsdk._IType_TK_EDF
    r""" The ``edf`` type. See #mi::neuraylib::IType_edf."""
    TK_VDF = _pymdlsdk._IType_TK_VDF
    r""" The ``vdf`` type. See #mi::neuraylib::IType_vdf."""
    TK_FORCE_32_BIT = _pymdlsdk._IType_TK_FORCE_32_BIT
    MK_NONE = _pymdlsdk._IType_MK_NONE
    r""" No type modifier (mutable, auto-typed)."""
    MK_UNIFORM = _pymdlsdk._IType_MK_UNIFORM
    r""" A uniform type."""
    MK_VARYING = _pymdlsdk._IType_MK_VARYING
    r""" A varying type."""
    MK_FORCE_32_BIT = _pymdlsdk._IType_MK_FORCE_32_BIT

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk._IType__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk._IType_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk._IType_skip_all_type_aliases(self)

# Register _IType in _pymdlsdk:
_pymdlsdk._IType_swigregister(_IType)

class Interface_declare_IType_alias(_IType):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_alias_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_alias

# Register Interface_declare_IType_alias in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_alias_swigregister(Interface_declare_IType_alias)

def Interface_declare_IType_alias_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_alias_compare_iid(iid)

class _IType_alias(Interface_declare_IType_alias):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_aliased_type(self):
        r""" Returns the type aliased by this type."""
        return _pymdlsdk._IType_alias_get_aliased_type(self)

    def get_type_modifiers(self):
        r""" Returns the modifiers of this type."""
        return _pymdlsdk._IType_alias_get_type_modifiers(self)

    def get_symbol(self):
        r""" Returns the qualified name of the type, or ``NULL`` if no such name exists."""
        return _pymdlsdk._IType_alias_get_symbol(self)

# Register _IType_alias in _pymdlsdk:
_pymdlsdk._IType_alias_swigregister(_IType_alias)

class Interface_declare_IType_atomic(_IType):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_atomic_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_atomic

# Register Interface_declare_IType_atomic in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_atomic_swigregister(Interface_declare_IType_atomic)

def Interface_declare_IType_atomic_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_atomic_compare_iid(iid)

class _IType_atomic(Interface_declare_IType_atomic):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_atomic in _pymdlsdk:
_pymdlsdk._IType_atomic_swigregister(_IType_atomic)

class Interface_declare_IType_bool(_IType_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_bool_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_bool

# Register Interface_declare_IType_bool in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_bool_swigregister(Interface_declare_IType_bool)

def Interface_declare_IType_bool_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_bool_compare_iid(iid)

class _IType_bool(Interface_declare_IType_bool):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_bool in _pymdlsdk:
_pymdlsdk._IType_bool_swigregister(_IType_bool)

class Interface_declare_IType_int(_IType_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_int_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_int

# Register Interface_declare_IType_int in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_int_swigregister(Interface_declare_IType_int)

def Interface_declare_IType_int_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_int_compare_iid(iid)

class _IType_int(Interface_declare_IType_int):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_int in _pymdlsdk:
_pymdlsdk._IType_int_swigregister(_IType_int)

class Interface_declare_IType_enum(_IType_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_enum_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_enum

# Register Interface_declare_IType_enum in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_enum_swigregister(Interface_declare_IType_enum)

def Interface_declare_IType_enum_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_enum_compare_iid(iid)

class _IType_enum(Interface_declare_IType_enum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    EID_USER = _pymdlsdk._IType_enum_EID_USER
    r""" A user-defined enum type."""
    EID_TEX_GAMMA_MODE = _pymdlsdk._IType_enum_EID_TEX_GAMMA_MODE
    r""" The ``"::tex::gamma_mode"`` enum type."""
    EID_INTENSITY_MODE = _pymdlsdk._IType_enum_EID_INTENSITY_MODE
    r""" The ``"::intensity_mode"`` enum type."""
    EID_FORCE_32_BIT = _pymdlsdk._IType_enum_EID_FORCE_32_BIT

    def get_symbol(self):
        r""" Returns the qualified name of this enum type."""
        return _pymdlsdk._IType_enum_get_symbol(self)

    def get_size(self):
        r""" Returns the number of values."""
        return _pymdlsdk._IType_enum_get_size(self)

    def get_value_name(self, index):
        r"""
        Returns the name of a value.

        :type index: int
        :param index:         The index of the value.
        :rtype: string
        :return: The unqualified name of the value, or ``NULL`` if ``index`` is invalid.
        """
        return _pymdlsdk._IType_enum_get_value_name(self, index)

    def get_value_code_with_ret(self, index):
        r"""
        Returns the code of a value.

        :type index: int
        :param index:         The index of the value.
        :type errors: int, out, optional
        :param errors:
                                 -  0: Success.
                                 - -1: ``index`` is invalid.
        :rtype: int
        :return: The code of the value, or 0 in case of errors.
        """
        return _pymdlsdk._IType_enum_get_value_code_with_ret(self, index)

    def get_value_code(self, index):
        r"""
        Returns the code of a value.

        :type index: int
        :param index:         The index of the value.
        :param errors:
                                 -  0: Success.
                                 - -1: ``index`` is invalid.
        :rtype: int
        :return: The code of the value, or 0 in case of errors.
        """
        return _pymdlsdk._IType_enum_get_value_code(self, index)

    def find_value(self, *args):
        r"""
        *Overload 1:*
        Returns the index of a value in linear time.

        :type name: string
        :param name:          The unqualified name of the value.
        :rtype: int
        :return: The index of the value, or -1 if there is no such value.

        |

        *Overload 2:*
        Returns the index of a value in linear time.

        :type code: int
        :param code:          The code of the value.
        :rtype: int
        :return: The index of the value, or -1 if there is no such value.
        """
        return _pymdlsdk._IType_enum_find_value(self, *args)

    def get_predefined_id(self):
        r""" If this enum is a predefined one, return its ID, else EID_USER."""
        return _pymdlsdk._IType_enum_get_predefined_id(self)

    def get_annotations(self):
        r"""
        Returns the annotations of the enum type.

        :rtype: :py:class:`IAnnotation_block`
        :return: The annotations of the enum type, or ``NULL`` if there are no
                                 annotations for the enum type.
        """
        return _pymdlsdk._IType_enum_get_annotations(self)

    def get_value_annotations(self, index):
        r"""
        Returns the annotations of a value.

        :type index: int
        :param index:         The index of the value.
        :rtype: :py:class:`IAnnotation_block`
        :return: The annotation of that value, or ``NULL`` if ``index`` is out of bounds,
                                 or there are no annotations for that value.
        """
        return _pymdlsdk._IType_enum_get_value_annotations(self, index)

# Register _IType_enum in _pymdlsdk:
_pymdlsdk._IType_enum_swigregister(_IType_enum)

class Interface_declare_IType_float(_IType_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_float_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_float

# Register Interface_declare_IType_float in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_float_swigregister(Interface_declare_IType_float)

def Interface_declare_IType_float_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_float_compare_iid(iid)

class _IType_float(Interface_declare_IType_float):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_float in _pymdlsdk:
_pymdlsdk._IType_float_swigregister(_IType_float)

class Interface_declare_IType_double(_IType_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_double_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_double

# Register Interface_declare_IType_double in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_double_swigregister(Interface_declare_IType_double)

def Interface_declare_IType_double_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_double_compare_iid(iid)

class _IType_double(Interface_declare_IType_double):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_double in _pymdlsdk:
_pymdlsdk._IType_double_swigregister(_IType_double)

class Interface_declare_IType_string(_IType_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_string_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_string

# Register Interface_declare_IType_string in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_string_swigregister(Interface_declare_IType_string)

def Interface_declare_IType_string_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_string_compare_iid(iid)

class _IType_string(Interface_declare_IType_string):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_string in _pymdlsdk:
_pymdlsdk._IType_string_swigregister(_IType_string)

class Interface_declare_IType_compound(_IType):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_compound_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_compound

# Register Interface_declare_IType_compound in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_compound_swigregister(Interface_declare_IType_compound)

def Interface_declare_IType_compound_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_compound_compare_iid(iid)

class _IType_compound(Interface_declare_IType_compound):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_component_type(self, index):
        r""" Returns the component type at ``index``."""
        return _pymdlsdk._IType_compound_get_component_type(self, index)

    def get_size(self):
        r""" Returns the number of components."""
        return _pymdlsdk._IType_compound_get_size(self)

# Register _IType_compound in _pymdlsdk:
_pymdlsdk._IType_compound_swigregister(_IType_compound)

class Interface_declare_IType_vector(_IType_compound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_vector_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_vector

# Register Interface_declare_IType_vector in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_vector_swigregister(Interface_declare_IType_vector)

def Interface_declare_IType_vector_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_vector_compare_iid(iid)

class _IType_vector(Interface_declare_IType_vector):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_element_type(self):
        r"""
        Returns the type of the vector elements.

        The element type of vectors is either #mi::neuraylib::IType_bool, #mi::neuraylib::IType_int,
        #mi::neuraylib::IType_float, or #mi::neuraylib::IType_double. If the vector is a column
        vector of a matrix, then the element type is either #mi::neuraylib::IType_float or
        #mi::neuraylib::IType_double.
        """
        return _pymdlsdk._IType_vector_get_element_type(self)

# Register _IType_vector in _pymdlsdk:
_pymdlsdk._IType_vector_swigregister(_IType_vector)

class Interface_declare_IType_matrix(_IType_compound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_matrix_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_matrix

# Register Interface_declare_IType_matrix in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_matrix_swigregister(Interface_declare_IType_matrix)

def Interface_declare_IType_matrix_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_matrix_compare_iid(iid)

class _IType_matrix(Interface_declare_IType_matrix):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_element_type(self):
        r""" Returns the type of the matrix elements, i.e., the type of a column vector."""
        return _pymdlsdk._IType_matrix_get_element_type(self)

# Register _IType_matrix in _pymdlsdk:
_pymdlsdk._IType_matrix_swigregister(_IType_matrix)

class Interface_declare_IType_color(_IType_compound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_color_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_color

# Register Interface_declare_IType_color in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_color_swigregister(Interface_declare_IType_color)

def Interface_declare_IType_color_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_color_compare_iid(iid)

class _IType_color(Interface_declare_IType_color):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_color in _pymdlsdk:
_pymdlsdk._IType_color_swigregister(_IType_color)

class Interface_declare_IType_array(_IType_compound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_array_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_array

# Register Interface_declare_IType_array in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_array_swigregister(Interface_declare_IType_array)

def Interface_declare_IType_array_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_array_compare_iid(iid)

class _IType_array(Interface_declare_IType_array):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_element_type(self):
        r""" Returns the type of the array elements."""
        return _pymdlsdk._IType_array_get_element_type(self)

    def is_immediate_sized(self):
        r""" Indicates whether the array is immediate-sized or deferred-sized."""
        return _pymdlsdk._IType_array_is_immediate_sized(self)

    def get_size(self):
        r""" Returns the size of the array in case of immediate-sized arrays, and -1 otherwise."""
        return _pymdlsdk._IType_array_get_size(self)

    def get_deferred_size(self):
        r"""
        Returns the abstract size of the array in case of deferred-sized arrays, and ``NULL``
        otherwise.

        Note that the empty string is a valid return value for deferred-sized arrays.
        """
        return _pymdlsdk._IType_array_get_deferred_size(self)

# Register _IType_array in _pymdlsdk:
_pymdlsdk._IType_array_swigregister(_IType_array)

class Interface_declare_IType_struct(_IType_compound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_struct_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_struct

# Register Interface_declare_IType_struct in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_struct_swigregister(Interface_declare_IType_struct)

def Interface_declare_IType_struct_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_struct_compare_iid(iid)

class _IType_struct(Interface_declare_IType_struct):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    SID_USER = _pymdlsdk._IType_struct_SID_USER
    r""" A user-defined struct type."""
    SID_MATERIAL_EMISSION = _pymdlsdk._IType_struct_SID_MATERIAL_EMISSION
    r""" The ``"::material_emission"`` struct type."""
    SID_MATERIAL_SURFACE = _pymdlsdk._IType_struct_SID_MATERIAL_SURFACE
    r""" The ``"::material_surface"`` struct type."""
    SID_MATERIAL_VOLUME = _pymdlsdk._IType_struct_SID_MATERIAL_VOLUME
    r""" The ``"::material_volume"`` struct type."""
    SID_MATERIAL_GEOMETRY = _pymdlsdk._IType_struct_SID_MATERIAL_GEOMETRY
    r""" The ``"::material_geometry"`` struct type."""
    SID_MATERIAL = _pymdlsdk._IType_struct_SID_MATERIAL
    r""" The ``"::material"`` struct type."""
    SID_FORCE_32_BIT = _pymdlsdk._IType_struct_SID_FORCE_32_BIT

    def get_symbol(self):
        r""" Returns the qualified name of the struct type."""
        return _pymdlsdk._IType_struct_get_symbol(self)

    def get_field_type(self, index):
        r"""
        Returns a field type.

        :type index: int
        :param index:    The index of the field.
        :rtype: :py:class:`IType`
        :return: The type of the field.
        """
        return _pymdlsdk._IType_struct_get_field_type(self, index)

    def get_field_name(self, index):
        r"""
        Returns a field name.

        :type index: int
        :param index:    The index of the field.
        :rtype: string
        :return: The unqualified name of the field.
        """
        return _pymdlsdk._IType_struct_get_field_name(self, index)

    def find_field(self, name):
        r"""
        Returns the index of a field in linear time.

        :type name: string
        :param name:     The unqualified name of the field.
        :rtype: int
        :return: The index of the field, or -1 if there is no such field.
        """
        return _pymdlsdk._IType_struct_find_field(self, name)

    def get_predefined_id(self):
        r""" If this struct is a predefined one, return its ID, else SID_USER."""
        return _pymdlsdk._IType_struct_get_predefined_id(self)

    def get_annotations(self):
        r"""
        Returns the annotations of the struct type.

        :rtype: :py:class:`IAnnotation_block`
        :return: The annotations of the struct type, or ``NULL`` if there are no
                                 annotations for the struct type.
        """
        return _pymdlsdk._IType_struct_get_annotations(self)

    def get_field_annotations(self, index):
        r"""
        Returns the annotations of a field.

        :type index: int
        :param index:         The index of the field.
        :rtype: :py:class:`IAnnotation_block`
        :return: The annotation of that field, or ``NULL`` if ``index`` is out of bounds,
                                 or there are no annotations for that field.
        """
        return _pymdlsdk._IType_struct_get_field_annotations(self, index)

# Register _IType_struct in _pymdlsdk:
_pymdlsdk._IType_struct_swigregister(_IType_struct)

class Interface_declare_IType_reference(_IType):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_reference_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_reference

# Register Interface_declare_IType_reference in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_reference_swigregister(Interface_declare_IType_reference)

def Interface_declare_IType_reference_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_reference_compare_iid(iid)

class _IType_reference(Interface_declare_IType_reference):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_reference in _pymdlsdk:
_pymdlsdk._IType_reference_swigregister(_IType_reference)

class Interface_declare_IType_resource(_IType_reference):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_resource_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_resource

# Register Interface_declare_IType_resource in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_resource_swigregister(Interface_declare_IType_resource)

def Interface_declare_IType_resource_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_resource_compare_iid(iid)

class _IType_resource(Interface_declare_IType_resource):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_resource in _pymdlsdk:
_pymdlsdk._IType_resource_swigregister(_IType_resource)

class Interface_declare_IType_texture(_IType_resource):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_texture_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_texture

# Register Interface_declare_IType_texture in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_texture_swigregister(Interface_declare_IType_texture)

def Interface_declare_IType_texture_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_texture_compare_iid(iid)

class _IType_texture(Interface_declare_IType_texture):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    TS_2D = _pymdlsdk._IType_texture_TS_2D
    r""" Two-dimensional texture."""
    TS_3D = _pymdlsdk._IType_texture_TS_3D
    r""" Three-dimensional texture."""
    TS_CUBE = _pymdlsdk._IType_texture_TS_CUBE
    r""" Cube map texture."""
    TS_PTEX = _pymdlsdk._IType_texture_TS_PTEX
    r""" PTEX texture."""
    TS_BSDF_DATA = _pymdlsdk._IType_texture_TS_BSDF_DATA
    r""" Three-dimensional texture representing"""
    TS_FORCE_32_BIT = _pymdlsdk._IType_texture_TS_FORCE_32_BIT
    r"""  a BSDF data table."""

    def get_shape(self):
        r""" Returns the texture type."""
        return _pymdlsdk._IType_texture_get_shape(self)

# Register _IType_texture in _pymdlsdk:
_pymdlsdk._IType_texture_swigregister(_IType_texture)

class Interface_declare_IType_light_profile(_IType_resource):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_light_profile_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_light_profile

# Register Interface_declare_IType_light_profile in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_light_profile_swigregister(Interface_declare_IType_light_profile)

def Interface_declare_IType_light_profile_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_light_profile_compare_iid(iid)

class _IType_light_profile(Interface_declare_IType_light_profile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_light_profile in _pymdlsdk:
_pymdlsdk._IType_light_profile_swigregister(_IType_light_profile)

class Interface_declare_IType_bsdf_measurement(_IType_resource):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_bsdf_measurement_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_bsdf_measurement

# Register Interface_declare_IType_bsdf_measurement in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_bsdf_measurement_swigregister(Interface_declare_IType_bsdf_measurement)

def Interface_declare_IType_bsdf_measurement_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_bsdf_measurement_compare_iid(iid)

class _IType_bsdf_measurement(Interface_declare_IType_bsdf_measurement):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_bsdf_measurement in _pymdlsdk:
_pymdlsdk._IType_bsdf_measurement_swigregister(_IType_bsdf_measurement)

class Interface_declare_IType_df(_IType_reference):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_df_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_df

# Register Interface_declare_IType_df in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_df_swigregister(Interface_declare_IType_df)

def Interface_declare_IType_df_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_df_compare_iid(iid)

class _IType_df(Interface_declare_IType_df):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_df in _pymdlsdk:
_pymdlsdk._IType_df_swigregister(_IType_df)

class Interface_declare_IType_bsdf(_IType_df):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_bsdf_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_bsdf

# Register Interface_declare_IType_bsdf in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_bsdf_swigregister(Interface_declare_IType_bsdf)

def Interface_declare_IType_bsdf_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_bsdf_compare_iid(iid)

class _IType_bsdf(Interface_declare_IType_bsdf):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_bsdf in _pymdlsdk:
_pymdlsdk._IType_bsdf_swigregister(_IType_bsdf)

class Interface_declare_IType_hair_bsdf(_IType_df):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_hair_bsdf_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_hair_bsdf

# Register Interface_declare_IType_hair_bsdf in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_hair_bsdf_swigregister(Interface_declare_IType_hair_bsdf)

def Interface_declare_IType_hair_bsdf_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_hair_bsdf_compare_iid(iid)

class _IType_hair_bsdf(Interface_declare_IType_hair_bsdf):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_hair_bsdf in _pymdlsdk:
_pymdlsdk._IType_hair_bsdf_swigregister(_IType_hair_bsdf)

class Interface_declare_IType_edf(_IType_df):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_edf_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_edf

# Register Interface_declare_IType_edf in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_edf_swigregister(Interface_declare_IType_edf)

def Interface_declare_IType_edf_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_edf_compare_iid(iid)

class _IType_edf(Interface_declare_IType_edf):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_edf in _pymdlsdk:
_pymdlsdk._IType_edf_swigregister(_IType_edf)

class Interface_declare_IType_vdf(_IType_df):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_vdf_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_vdf

# Register Interface_declare_IType_vdf in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_vdf_swigregister(Interface_declare_IType_vdf)

def Interface_declare_IType_vdf_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_vdf_compare_iid(iid)

class _IType_vdf(Interface_declare_IType_vdf):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_vdf in _pymdlsdk:
_pymdlsdk._IType_vdf_swigregister(_IType_vdf)

class Interface_declare_IType_list(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_list_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_list

# Register Interface_declare_IType_list in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_list_swigregister(Interface_declare_IType_list)

def Interface_declare_IType_list_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_list_compare_iid(iid)

class _IType_list(Interface_declare_IType_list):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_size(self):
        r""" Returns the number of elements."""
        return _pymdlsdk._IType_list_get_size(self)

    def get_index(self, name):
        r""" Returns the index for the given name, or -1 if there is no such type."""
        return _pymdlsdk._IType_list_get_index(self, name)

    def get_name(self, index):
        r""" Returns the name for the given index, or ``NULL`` if there is no such type."""
        return _pymdlsdk._IType_list_get_name(self, index)

    def get_type(self, *args):
        r"""
        *Overload 1:*
        Returns the type for ``index``, or ``NULL`` if there is no such type.

        |

        *Overload 2:*
        Returns the type for ``name``, or ``NULL`` if there is no such type.
        """
        return _pymdlsdk._IType_list_get_type(self, *args)

    def set_type(self, *args):
        r"""
        *Overload 1:*
        Sets a type at a given index.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: ``index`` is out of bounds.

        |

        *Overload 2:*
        Sets a type identified by name.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: There is no type mapped to ``name`` in the list.
        """
        return _pymdlsdk._IType_list_set_type(self, *args)

    def add_type(self, name, type):
        r"""
        Adds a type at the end of the list.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: There is already a type mapped to ``name`` in the list.
        """
        return _pymdlsdk._IType_list_add_type(self, name, type)

# Register _IType_list in _pymdlsdk:
_pymdlsdk._IType_list_swigregister(_IType_list)

class Interface_declare_IType_factory(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_factory_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_factory

# Register Interface_declare_IType_factory in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_factory_swigregister(Interface_declare_IType_factory)

def Interface_declare_IType_factory_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_factory_compare_iid(iid)

class _IType_factory(Interface_declare_IType_factory):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def create_alias(self, type, modifiers, symbol):
        r""" Creates a new instance of the type alias."""
        return _pymdlsdk._IType_factory_create_alias(self, type, modifiers, symbol)

    def create_bool(self):
        r""" Creates a new instance of the type boolean."""
        return _pymdlsdk._IType_factory_create_bool(self)

    def create_int(self):
        r""" Creates a new instance of the type int."""
        return _pymdlsdk._IType_factory_create_int(self)

    def create_enum(self, symbol):
        r""" Returns a registered enum type, or ``NULL`` if ``symbol`` is invalid or unknown."""
        return _pymdlsdk._IType_factory_create_enum(self, symbol)

    def create_float(self):
        r""" Creates a new instance of the float type."""
        return _pymdlsdk._IType_factory_create_float(self)

    def create_double(self):
        r""" Creates a new instance of the double type."""
        return _pymdlsdk._IType_factory_create_double(self)

    def create_string(self):
        r""" Creates a new instance of the string type."""
        return _pymdlsdk._IType_factory_create_string(self)

    def create_vector(self, element_type, size):
        r"""
        Creates a new instance of a vector type.

        :type element_type: :py:class:`IType_atomic`
        :param element_type:   The element type needs to be either #mi::neuraylib::IType_bool,
                                  #mi::neuraylib::IType_int, #mi::neuraylib::IType_float, or
                                  #mi::neuraylib::IType_double.
        :type size: int
        :param size:           The number of elements, either 2, 3, or 4.
        :rtype: :py:class:`IType_vector`
        :return: The corresponding vector type, or ``NULL`` in case of errors.
        """
        return _pymdlsdk._IType_factory_create_vector(self, element_type, size)

    def create_matrix(self, column_type, columns):
        r"""
        Creates a new instance of a matrix type.

        :type column_type: :py:class:`IType_vector`
        :param column_type:    The column type needs to be a vector of either
                                  #mi::neuraylib::IType_float or #mi::neuraylib::IType_double.
        :type columns: int
        :param columns:        The number of columns, either 2, 3, or 4.
        :rtype: :py:class:`IType_matrix`
        :return: The corresponding matrix type, or ``NULL`` in case of errors.
        """
        return _pymdlsdk._IType_factory_create_matrix(self, column_type, columns)

    def create_color(self):
        r""" Creates a new instance of the type color."""
        return _pymdlsdk._IType_factory_create_color(self)

    def create_immediate_sized_array(self, element_type, size):
        r""" Creates a new instance of an immediate-sized array type."""
        return _pymdlsdk._IType_factory_create_immediate_sized_array(self, element_type, size)

    def create_deferred_sized_array(self, element_type, size):
        r""" Creates a new instance of a deferred-sized array type."""
        return _pymdlsdk._IType_factory_create_deferred_sized_array(self, element_type, size)

    def create_struct(self, symbol):
        r""" Returns a registered struct type, or ``NULL`` if ``symbol`` is invalid or unknown."""
        return _pymdlsdk._IType_factory_create_struct(self, symbol)

    def create_texture(self, shape):
        r""" Creates a new instance of the type texture."""
        return _pymdlsdk._IType_factory_create_texture(self, shape)

    def create_light_profile(self):
        r""" Creates a new instance of the type light_profile."""
        return _pymdlsdk._IType_factory_create_light_profile(self)

    def create_bsdf_measurement(self):
        r""" Creates a new instance of the type bsdf_measurement."""
        return _pymdlsdk._IType_factory_create_bsdf_measurement(self)

    def create_bsdf(self):
        r""" Creates a new instance of the type bsdf."""
        return _pymdlsdk._IType_factory_create_bsdf(self)

    def create_hair_bsdf(self):
        r""" Creates a new instance of the type hair_bsdf."""
        return _pymdlsdk._IType_factory_create_hair_bsdf(self)

    def create_edf(self):
        r""" Creates a new instance of the type edf."""
        return _pymdlsdk._IType_factory_create_edf(self)

    def create_vdf(self):
        r""" Creates a new instance of the type vdf."""
        return _pymdlsdk._IType_factory_create_vdf(self)

    def create_type_list(self):
        r""" Creates a new type map."""
        return _pymdlsdk._IType_factory_create_type_list(self)

    def get_predefined_enum(self, id):
        r""" Returns a registered enum type, or ``NULL`` if ``id`` is unknown."""
        return _pymdlsdk._IType_factory_get_predefined_enum(self, id)

    def get_predefined_struct(self, id):
        r""" Returns a registered struct type, or ``NULL`` if ``id`` is unknown."""
        return _pymdlsdk._IType_factory_get_predefined_struct(self, id)

    def clone(self, type_list):
        r""" Clones the given type list."""
        return _pymdlsdk._IType_factory_clone(self, type_list)

    def compare(self, *args):
        r"""
        *Overload 1:*
        Compares two instances of #mi::neuraylib::IType.

        The comparison operator for instances of #mi::neuraylib::IType is defined as follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Otherwise, the kind of the types are compared. If they are different, the result is
          determined by ``operator``< on the #mi::neuraylib::IType::Kind values.
        - Finally, specific types are compared as follows:
          - #mi::neuraylib::IType_enum and #mi::neuraylib::IType_struct: The result is determined by
            ``strcmp()`` on the corresponding symbol names.
          - #mi::neuraylib::IType_vector, #mi::neuraylib::IType_matrix, #mi::neuraylib::IType_array:
            If the element types are different, they determine the result of the comparison. If the
            element types are identical the number of compound elements determines the result.
          - #mi::neuraylib::IType_alias: If the modifiers are different, they determine the result
            of the comparison. If the modifiers are identical, the aliased types determine the
            result.
          - #mi::neuraylib::IType_texture: The result is determined by a comparison of the
            corresponding shapes.
          - All other pairs of (the same kind of) types are considered equal.

        :type lhs: :py:class:`IType`
        :param lhs:   The left-hand side operand for the comparison.
        :type rhs: :py:class:`IType`
        :param rhs:   The right-hand side operand for the comparison.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.

        |

        *Overload 2:*
        Compares two instances of #mi::neuraylib::IType_list.

        The comparison operator for instances of #mi::neuraylib::IType_list is defined as follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Next, the list sizes are compared using ``operator``<().
        - Next, the lists are traversed by increasing index and the names are compared using
          ``strcmp()``.
        - Finally, the list elements are enumerated by increasing index and the types are compared.

        :type lhs: :py:class:`IType_list`
        :param lhs:   The left-hand side operand for the comparison.
        :type rhs: :py:class:`IType_list`
        :param rhs:   The right-hand side operand for the comparison.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.
        """
        return _pymdlsdk._IType_factory_compare(self, *args)

    def is_compatible(self, src, dst):
        r"""
        Checks, if two instances of #mi::neuraylib::IType are compatible, meaning that ``src``
        can be casted to ``dst``.

        ``src`` is compatible with and therefore can be casted to ``dst``, if
        - ``src`` and ``dst`` are of identical type (see #mi::neuraylib::IType_factory::compare()).
        - ``src`` and ``dst`` are of type #mi::neuraylib::IType_struct, have the same number of
          fields and all fields are compatible.
        - ``src`` and ``dst`` are of type #mi::neuraylib::IType_enum and both enumeration types have
          the same set of numerical enumeration values. The name of the enumeration values, their
          order, or whether multiple enumeration value names share the same numerical value
          do not matter.
        - ``src`` and ``dst`` are of type #mi::neuraylib::IType_array, both arrays have the same size
          and their element types are compatible.

        :type src: :py:class:`IType`
        :param src: The source type.
        :type dst: :py:class:`IType`
        :param dst: the target type to which src is intended to be compatible.
        :rtype: int
        :return: 
                      -  0 if ``src`` can be casted to ``dst``, but ``src`` and ``dst`` are not of identical
                           type.
                      -  1 if ``src`` and ``dst`` are of identical type.
                      - -1 if ``src`` cannot be casted to ``dst``.
        """
        return _pymdlsdk._IType_factory_is_compatible(self, src, dst)

    def dump(self, *args):
        r"""
        *Overload 1:*
         Returns a textual representation of a type.

         The representation of the type might contain line breaks, for example for structures and
         enums. Subsequent lines have a suitable indentation. The assumed indentation level of the
         first line is specified by ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 2:*
         Returns a textual representation of a type list.

         The representation of the type list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 3:*
         Returns a textual representation of a type list.

         The representation of the type list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.
        """
        return _pymdlsdk._IType_factory_dump(self, *args)

# Register _IType_factory in _pymdlsdk:
_pymdlsdk._IType_factory_swigregister(_IType_factory)

class Interface_declare_IValue(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue

# Register Interface_declare_IValue in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_swigregister(Interface_declare_IValue)

def Interface_declare_IValue_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_compare_iid(iid)

class _IValue(Interface_declare_IValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    VK_BOOL = _pymdlsdk._IValue_VK_BOOL
    r""" A boolean value. See #mi::neuraylib::IValue_bool."""
    VK_INT = _pymdlsdk._IValue_VK_INT
    r""" An integer value. See #mi::neuraylib::IValue_int."""
    VK_ENUM = _pymdlsdk._IValue_VK_ENUM
    r""" An enum value. See #mi::neuraylib::IValue_enum."""
    VK_FLOAT = _pymdlsdk._IValue_VK_FLOAT
    r""" A float value. See #mi::neuraylib::IValue_float."""
    VK_DOUBLE = _pymdlsdk._IValue_VK_DOUBLE
    r""" A double value. See #mi::neuraylib::IValue_double."""
    VK_STRING = _pymdlsdk._IValue_VK_STRING
    r""" A string value. See #mi::neuraylib::IValue_string."""
    VK_VECTOR = _pymdlsdk._IValue_VK_VECTOR
    r""" A vector value. See #mi::neuraylib::IValue_vector."""
    VK_MATRIX = _pymdlsdk._IValue_VK_MATRIX
    r""" A matrix value. See #mi::neuraylib::IValue_matrix."""
    VK_COLOR = _pymdlsdk._IValue_VK_COLOR
    r""" A color value. See #mi::neuraylib::IValue_color."""
    VK_ARRAY = _pymdlsdk._IValue_VK_ARRAY
    r""" An array value. See #mi::neuraylib::IValue_array."""
    VK_STRUCT = _pymdlsdk._IValue_VK_STRUCT
    r""" A struct value. See #mi::neuraylib::IValue_struct."""
    VK_INVALID_DF = _pymdlsdk._IValue_VK_INVALID_DF
    r""" An invalid distribution function value. See #mi::neuraylib::IValue_invalid_df."""
    VK_TEXTURE = _pymdlsdk._IValue_VK_TEXTURE
    r""" A texture value. See #mi::neuraylib::IValue_texture."""
    VK_LIGHT_PROFILE = _pymdlsdk._IValue_VK_LIGHT_PROFILE
    r""" A light_profile value. See #mi::neuraylib::IValue_light_profile."""
    VK_BSDF_MEASUREMENT = _pymdlsdk._IValue_VK_BSDF_MEASUREMENT
    r""" A bsdf_measurement value. See #mi::neuraylib::IValue_bsdf_measurement."""
    VK_FORCE_32_BIT = _pymdlsdk._IValue_VK_FORCE_32_BIT

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk._IValue__get_kind(self)

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_get_type(self)

# Register _IValue in _pymdlsdk:
_pymdlsdk._IValue_swigregister(_IValue)

class Interface_declare_IValue_atomic(_IValue):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_atomic_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_atomic

# Register Interface_declare_IValue_atomic in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_atomic_swigregister(Interface_declare_IValue_atomic)

def Interface_declare_IValue_atomic_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_atomic_compare_iid(iid)

class _IValue_atomic(Interface_declare_IValue_atomic):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_atomic_get_type(self)

# Register _IValue_atomic in _pymdlsdk:
_pymdlsdk._IValue_atomic_swigregister(_IValue_atomic)

class Interface_declare_IValue_bool(_IValue_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_bool_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_bool

# Register Interface_declare_IValue_bool in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_bool_swigregister(Interface_declare_IValue_bool)

def Interface_declare_IValue_bool_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_bool_compare_iid(iid)

class _IValue_bool(Interface_declare_IValue_bool):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_bool_get_type(self)

    def get_value(self):
        r""" Returns the value."""
        return _pymdlsdk._IValue_bool_get_value(self)

    def set_value(self, value):
        r""" Sets the value."""
        return _pymdlsdk._IValue_bool_set_value(self, value)

# Register _IValue_bool in _pymdlsdk:
_pymdlsdk._IValue_bool_swigregister(_IValue_bool)

class Interface_declare_IValue_int(_IValue_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_int_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_int

# Register Interface_declare_IValue_int in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_int_swigregister(Interface_declare_IValue_int)

def Interface_declare_IValue_int_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_int_compare_iid(iid)

class _IValue_int(Interface_declare_IValue_int):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_int_get_type(self)

    def get_value(self):
        r""" Returns the value."""
        return _pymdlsdk._IValue_int_get_value(self)

    def set_value(self, value):
        r""" Sets the value."""
        return _pymdlsdk._IValue_int_set_value(self, value)

# Register _IValue_int in _pymdlsdk:
_pymdlsdk._IValue_int_swigregister(_IValue_int)

class Interface_declare_IValue_enum(_IValue_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_enum_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_enum

# Register Interface_declare_IValue_enum in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_enum_swigregister(Interface_declare_IValue_enum)

def Interface_declare_IValue_enum_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_enum_compare_iid(iid)

class _IValue_enum(Interface_declare_IValue_enum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_enum_get_type(self)

    def get_value(self):
        r""" Returns the (integer) value of this enum value."""
        return _pymdlsdk._IValue_enum_get_value(self)

    def get_index(self):
        r""" Returns the index of this enum value."""
        return _pymdlsdk._IValue_enum_get_index(self)

    def set_value(self, value):
        r"""
        Sets the enum value by integer in linear time.

        If there are multiple indices with the same value the one with the smallest index is chosen.

        :rtype: int
        :return: 0 in case of success, -1 if ``value`` is not valid for this enum type
        """
        return _pymdlsdk._IValue_enum_set_value(self, value)

    def set_index(self, index):
        r"""
        Sets the enum value by index.

        :rtype: int
        :return: 0 in case of success, -1 if ``index`` is not valid for this enum type
        """
        return _pymdlsdk._IValue_enum_set_index(self, index)

    def get_name(self):
        r""" Returns the string representation of this enum value."""
        return _pymdlsdk._IValue_enum_get_name(self)

    def set_name(self, name):
        r"""
        Sets the enum value by string representation in linear time.

        :rtype: int
        :return: 0 in case of success, -1 if ``name`` is not valid for this enum type
        """
        return _pymdlsdk._IValue_enum_set_name(self, name)

# Register _IValue_enum in _pymdlsdk:
_pymdlsdk._IValue_enum_swigregister(_IValue_enum)

class Interface_declare_IValue_float(_IValue_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_float_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_float

# Register Interface_declare_IValue_float in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_float_swigregister(Interface_declare_IValue_float)

def Interface_declare_IValue_float_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_float_compare_iid(iid)

class _IValue_float(Interface_declare_IValue_float):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_float_get_type(self)

    def get_value(self):
        r""" Returns the value."""
        return _pymdlsdk._IValue_float_get_value(self)

    def set_value(self, value):
        r""" Sets the value."""
        return _pymdlsdk._IValue_float_set_value(self, value)

# Register _IValue_float in _pymdlsdk:
_pymdlsdk._IValue_float_swigregister(_IValue_float)

class Interface_declare_IValue_double(_IValue_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_double_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_double

# Register Interface_declare_IValue_double in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_double_swigregister(Interface_declare_IValue_double)

def Interface_declare_IValue_double_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_double_compare_iid(iid)

class _IValue_double(Interface_declare_IValue_double):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_double_get_type(self)

    def get_value(self):
        r""" Returns the value."""
        return _pymdlsdk._IValue_double_get_value(self)

    def set_value(self, value):
        r""" Sets the value."""
        return _pymdlsdk._IValue_double_set_value(self, value)

# Register _IValue_double in _pymdlsdk:
_pymdlsdk._IValue_double_swigregister(_IValue_double)

class Interface_declare_IValue_string(_IValue_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_string_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_string

# Register Interface_declare_IValue_string in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_string_swigregister(Interface_declare_IValue_string)

def Interface_declare_IValue_string_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_string_compare_iid(iid)

class _IValue_string(Interface_declare_IValue_string):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_string_get_type(self)

    def get_value(self):
        r""" Returns the value."""
        return _pymdlsdk._IValue_string_get_value(self)

    def set_value(self, value):
        r""" Sets the value."""
        return _pymdlsdk._IValue_string_set_value(self, value)

# Register _IValue_string in _pymdlsdk:
_pymdlsdk._IValue_string_swigregister(_IValue_string)

class Interface_declare_IValue_string_localized(_IValue_string):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_string_localized_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_string_localized

# Register Interface_declare_IValue_string_localized in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_string_localized_swigregister(Interface_declare_IValue_string_localized)

def Interface_declare_IValue_string_localized_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_string_localized_compare_iid(iid)

class _IValue_string_localized(Interface_declare_IValue_string_localized):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_original_value(self):
        r"""
        Returns the original value of a localized string.
        While IValue_string::value() returns the translated string.
        """
        return _pymdlsdk._IValue_string_localized_get_original_value(self)

# Register _IValue_string_localized in _pymdlsdk:
_pymdlsdk._IValue_string_localized_swigregister(_IValue_string_localized)

class Interface_declare_IValue_compound(_IValue):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_compound_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_compound

# Register Interface_declare_IValue_compound in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_compound_swigregister(Interface_declare_IValue_compound)

def Interface_declare_IValue_compound_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_compound_compare_iid(iid)

class _IValue_compound(Interface_declare_IValue_compound):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_compound_get_type(self)

    def get_size(self):
        r""" Returns the number of components in this compound value."""
        return _pymdlsdk._IValue_compound_get_size(self)

    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.

        |

        *Overload 2:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk._IValue_compound__get_value(self, *args)

    def set_value(self, index, value):
        r"""
        Sets the value at ``index``.

        :type index: int
        :param index:   The index of the field.
        :type value: :py:class:`IValue`
        :param value:   The new value of the field.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: ``index`` is out of bounds.
                           - -3: Incorrect type of ``value``.
        """
        return _pymdlsdk._IValue_compound_set_value(self, index, value)

# Register _IValue_compound in _pymdlsdk:
_pymdlsdk._IValue_compound_swigregister(_IValue_compound)

class Interface_declare_IValue_vector(_IValue_compound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_vector_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_vector

# Register Interface_declare_IValue_vector in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_vector_swigregister(Interface_declare_IValue_vector)

def Interface_declare_IValue_vector_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_vector_compare_iid(iid)

class _IValue_vector(Interface_declare_IValue_vector):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_vector_get_type(self)

    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.

        |

        *Overload 2:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk._IValue_vector__get_value(self, *args)

# Register _IValue_vector in _pymdlsdk:
_pymdlsdk._IValue_vector_swigregister(_IValue_vector)

class Interface_declare_IValue_matrix(_IValue_compound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_matrix_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_matrix

# Register Interface_declare_IValue_matrix in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_matrix_swigregister(Interface_declare_IValue_matrix)

def Interface_declare_IValue_matrix_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_matrix_compare_iid(iid)

class _IValue_matrix(Interface_declare_IValue_matrix):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_matrix_get_type(self)

    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.

        |

        *Overload 2:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk._IValue_matrix__get_value(self, *args)

# Register _IValue_matrix in _pymdlsdk:
_pymdlsdk._IValue_matrix_swigregister(_IValue_matrix)

class Interface_declare_IValue_color(_IValue_compound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_color_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_color

# Register Interface_declare_IValue_color in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_color_swigregister(Interface_declare_IValue_color)

def Interface_declare_IValue_color_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_color_compare_iid(iid)

class _IValue_color(Interface_declare_IValue_color):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_color_get_type(self)

    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.

        |

        *Overload 2:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk._IValue_color__get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the value at ``index``.

        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: ``index`` is out of bounds.

        |

        *Overload 2:*
        Sets the value at ``index``.

        :type index: int
        :param index:   The index of the field.
        :type value: :py:class:`IValue`
        :param value:   The new value of the field.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: ``index`` is out of bounds.
                           - -3: Incorrect type of ``value``.
        """
        return _pymdlsdk._IValue_color_set_value(self, *args)

# Register _IValue_color in _pymdlsdk:
_pymdlsdk._IValue_color_swigregister(_IValue_color)

class Interface_declare_IValue_array(_IValue_compound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_array_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_array

# Register Interface_declare_IValue_array in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_array_swigregister(Interface_declare_IValue_array)

def Interface_declare_IValue_array_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_array_compare_iid(iid)

class _IValue_array(Interface_declare_IValue_array):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_array_get_type(self)

    def set_size(self, size):
        r"""
        Sets the size for dynamic arrays.

        :type size: int
        :param size:   The desired array size.
        :rtype: int
        :return: 
                          -  0: Success.
                          - -1: The array is a static array.
        """
        return _pymdlsdk._IValue_array_set_size(self, size)

# Register _IValue_array in _pymdlsdk:
_pymdlsdk._IValue_array_swigregister(_IValue_array)

class Interface_declare_IValue_struct(_IValue_compound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_struct_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_struct

# Register Interface_declare_IValue_struct in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_struct_swigregister(Interface_declare_IValue_struct)

def Interface_declare_IValue_struct_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_struct_compare_iid(iid)

class _IValue_struct(Interface_declare_IValue_struct):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_struct_get_type(self)

    def _get_field(self, *args):
        r"""
        *Overload 1:*
        Returns a field by name in linear time.

        :type name: string
        :param name:    The name of the field.
        :rtype: :py:class:`IValue`
        :return: The value of the field, or ``NULL`` if there is no such field.

        |

        *Overload 2:*
        Returns a field by name in linear time.

        :type name: string
        :param name:    The name of the field.
        :rtype: :py:class:`IValue`
        :return: The value of the field, or ``NULL`` if there is no such field.
        """
        return _pymdlsdk._IValue_struct__get_field(self, *args)

    def set_field(self, name, value):
        r"""
        Sets a field by name in linear time.

        :type name: string
        :param name:    The name of the field.
        :type value: :py:class:`IValue`
        :param value:   The new value of the field.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: There is no such field of the given name.
                           - -3: Incorrect type of ``value``.
        """
        return _pymdlsdk._IValue_struct_set_field(self, name, value)

# Register _IValue_struct in _pymdlsdk:
_pymdlsdk._IValue_struct_swigregister(_IValue_struct)

class Interface_declare_IValue_resource(_IValue):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_resource_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_resource

# Register Interface_declare_IValue_resource in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_resource_swigregister(Interface_declare_IValue_resource)

def Interface_declare_IValue_resource_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_resource_compare_iid(iid)

class _IValue_resource(Interface_declare_IValue_resource):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_resource_get_type(self)

    def get_value(self):
        r"""
        Returns the name of the DB element representing this resource.

        :rtype: string
        :return: The name of the DB element, or ``NULL`` if no valid resource is set.
        """
        return _pymdlsdk._IValue_resource_get_value(self)

    def set_value(self, value):
        r"""
        Sets the name of the DB element representing this resource.

        Pointing this instance to a different DB element resets the MDL file path returned by
        #get_file_path().

        :type value: string
        :param value:   The name of the resource, or ``NULL`` to release the current resource.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: There is no DB element with that name.
                           - -2: The DB element has not the correct type for this resource.
        """
        return _pymdlsdk._IValue_resource_set_value(self, value)

    def get_file_path(self):
        r"""
        Returns the absolute MDL file path of the resource, or ``NULL`` if not known.

        Notes: The value returned here is not a property of this object, but a property of the
              referenced resource.
        """
        return _pymdlsdk._IValue_resource_get_file_path(self)

# Register _IValue_resource in _pymdlsdk:
_pymdlsdk._IValue_resource_swigregister(_IValue_resource)

class Interface_declare_IValue_texture(_IValue_resource):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_texture_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_texture

# Register Interface_declare_IValue_texture in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_texture_swigregister(Interface_declare_IValue_texture)

def Interface_declare_IValue_texture_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_texture_compare_iid(iid)

class _IValue_texture(Interface_declare_IValue_texture):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_texture_get_type(self)

    def get_gamma(self):
        r"""
        Returns the gamma value of this texture.

        Notes: : A gamma value of 0 corresponds to the default gamma value for the given texture
               kind.
        """
        return _pymdlsdk._IValue_texture_get_gamma(self)

    def get_selector(self):
        r""" Returns the selector of this texture, or ``NULL``."""
        return _pymdlsdk._IValue_texture_get_selector(self)

# Register _IValue_texture in _pymdlsdk:
_pymdlsdk._IValue_texture_swigregister(_IValue_texture)

class Interface_declare_IValue_light_profile(_IValue_resource):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_light_profile_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_light_profile

# Register Interface_declare_IValue_light_profile in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_light_profile_swigregister(Interface_declare_IValue_light_profile)

def Interface_declare_IValue_light_profile_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_light_profile_compare_iid(iid)

class _IValue_light_profile(Interface_declare_IValue_light_profile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_light_profile_get_type(self)

# Register _IValue_light_profile in _pymdlsdk:
_pymdlsdk._IValue_light_profile_swigregister(_IValue_light_profile)

class Interface_declare_IValue_bsdf_measurement(_IValue_resource):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_bsdf_measurement_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_bsdf_measurement

# Register Interface_declare_IValue_bsdf_measurement in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_bsdf_measurement_swigregister(Interface_declare_IValue_bsdf_measurement)

def Interface_declare_IValue_bsdf_measurement_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_bsdf_measurement_compare_iid(iid)

class _IValue_bsdf_measurement(Interface_declare_IValue_bsdf_measurement):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_bsdf_measurement_get_type(self)

# Register _IValue_bsdf_measurement in _pymdlsdk:
_pymdlsdk._IValue_bsdf_measurement_swigregister(_IValue_bsdf_measurement)

class Interface_declare_IValue_invalid_df(_IValue):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_invalid_df_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_invalid_df

# Register Interface_declare_IValue_invalid_df in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_invalid_df_swigregister(Interface_declare_IValue_invalid_df)

def Interface_declare_IValue_invalid_df_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_invalid_df_compare_iid(iid)

class _IValue_invalid_df(Interface_declare_IValue_invalid_df):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_invalid_df_get_type(self)

# Register _IValue_invalid_df in _pymdlsdk:
_pymdlsdk._IValue_invalid_df_swigregister(_IValue_invalid_df)

class Interface_declare_IValue_list(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_list_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_list

# Register Interface_declare_IValue_list in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_list_swigregister(Interface_declare_IValue_list)

def Interface_declare_IValue_list_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_list_compare_iid(iid)

class _IValue_list(Interface_declare_IValue_list):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_size(self):
        r""" Returns the number of elements."""
        return _pymdlsdk._IValue_list_get_size(self)

    def get_index(self, name):
        r""" Returns the index for the given name, or -1 if there is no such value."""
        return _pymdlsdk._IValue_list_get_index(self, name)

    def get_name(self, index):
        r""" Returns the name for the given index, or ``NULL`` if there is no such value."""
        return _pymdlsdk._IValue_list_get_name(self, index)

    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value for ``index``, or ``NULL`` if there is no such value.

        |

        *Overload 2:*
        Returns the value for ``name``, or ``NULL`` if there is no such value.
        """
        return _pymdlsdk._IValue_list_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets a value at a given index.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: ``index`` is out of bounds.

        |

        *Overload 2:*
        Sets a value identified by name.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is no value mapped to ``name`` in the list.
        """
        return _pymdlsdk._IValue_list_set_value(self, *args)

    def add_value(self, name, value):
        r"""
        Adds a value at the end of the list.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is already a value mapped to ``name`` in the list.
        """
        return _pymdlsdk._IValue_list_add_value(self, name, value)

# Register _IValue_list in _pymdlsdk:
_pymdlsdk._IValue_list_swigregister(_IValue_list)

class Interface_declare_IValue_factory(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_factory_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_factory

# Register Interface_declare_IValue_factory in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_factory_swigregister(Interface_declare_IValue_factory)

def Interface_declare_IValue_factory_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_factory_compare_iid(iid)

class _IValue_factory(Interface_declare_IValue_factory):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type_factory(self):
        r""" Returns the type factory associated with this value factory."""
        return _pymdlsdk._IValue_factory_get_type_factory(self)

    def create_bool(self, value=False):
        r""" Creates a new value of type boolean."""
        return _pymdlsdk._IValue_factory_create_bool(self, value)

    def create_int(self, value=0):
        r""" Creates a new value of type integer."""
        return _pymdlsdk._IValue_factory_create_int(self, value)

    def create_enum(self, type, index=0):
        r""" Creates a new value of type enum, or returns ``NULL`` in case of errors."""
        return _pymdlsdk._IValue_factory_create_enum(self, type, index)

    def create_float(self, value=0.0):
        r""" Creates a new value of type float."""
        return _pymdlsdk._IValue_factory_create_float(self, value)

    def create_double(self, value=0.0):
        r""" Creates a new value of type double."""
        return _pymdlsdk._IValue_factory_create_double(self, value)

    def create_string(self, *args):
        r"""
        Creates a new value of type string.

        :type value: string, optional
        :param value:   The value ``NULL`` is handled like the empty string.
        """
        return _pymdlsdk._IValue_factory_create_string(self, *args)

    def create_vector(self, type):
        r""" Creates a new value of type vector, or returns ``NULL`` in case of errors."""
        return _pymdlsdk._IValue_factory_create_vector(self, type)

    def create_matrix(self, type):
        r""" Creates a new value of type matrix, or returns ``NULL`` in case of errors."""
        return _pymdlsdk._IValue_factory_create_matrix(self, type)

    def create_color(self, red=0.0, green=0.0, blue=0.0):
        r""" Creates a new value of type color."""
        return _pymdlsdk._IValue_factory_create_color(self, red, green, blue)

    def create_array(self, type):
        r""" Creates a new value of type array, or returns ``NULL`` in case of errors."""
        return _pymdlsdk._IValue_factory_create_array(self, type)

    def create_struct(self, type):
        r""" Creates a new value of type struct, or returns ``NULL`` in case of errors."""
        return _pymdlsdk._IValue_factory_create_struct(self, type)

    def create_texture(self, type, value):
        r""" Creates a new texture value, or returns ``NULL`` in case of errors."""
        return _pymdlsdk._IValue_factory_create_texture(self, type, value)

    def create_light_profile(self, value):
        r""" Creates a new light profile value, or returns ``NULL`` in case of errors."""
        return _pymdlsdk._IValue_factory_create_light_profile(self, value)

    def create_bsdf_measurement(self, value):
        r""" Creates a new BSDF measurement value, or returns ``NULL`` in case of errors."""
        return _pymdlsdk._IValue_factory_create_bsdf_measurement(self, value)

    def create_invalid_df(self, type):
        r""" Creates a new invalid distribution function value."""
        return _pymdlsdk._IValue_factory_create_invalid_df(self, type)

    def create(self, *args):
        r"""
        *Overload 1:*
        Creates a default-constructed value of the given type.

        |

        *Overload 2:*
        Creates a value observing the range of an ``"::anno::soft_range()"`` or an
        ``"::anno::hard_range()"`` annotation.

        The type of the value is determined by the parameter types of the annotation.

        |

        *Overload 3:*
        Creates a value observing a potentially present range annotation.

        This method is a convenience wrapper around the other two (non-template) overloads.

        If ``annotation_block`` contains an ``"::anno::soft_range()"`` or an ``"::anno::hard_range()"``
        annotation, then this method calls the annotation-based overload with that annotation (where
        ``"::anno::soft_range()"`` has priority over ``"::anno::hard_range()"``). Otherwise, it calls
        the type-based overload with the given value type.
        """
        return _pymdlsdk._IValue_factory_create(self, *args)

    def create_value_list(self):
        r""" Creates a new value list."""
        return _pymdlsdk._IValue_factory_create_value_list(self)

    def clone(self, *args):
        r"""
        *Overload 1:*
        Clones the given value.

        Note that referenced DB elements, e.g., resources, are not copied, but shared.

        |

        *Overload 2:*
        Clones the given value list.

        Note that referenced DB elements, e.g., resources, are not copied, but shared.
        """
        return _pymdlsdk._IValue_factory_clone(self, *args)

    def compare(self, *args):
        r"""
        *Overload 1:*
        Compares two instances of #mi::neuraylib::IValue.

        The comparison operator for instances of #mi::neuraylib::IValue is defined as follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Otherwise, the types of ``lhs`` and ``rhs`` are compared. If they are different, the result
          is determined by that comparison.
        - Next, the kind of the values are compared. If they are different, the result is determined
          by ``operator``< on the #mi::neuraylib::IValue::Kind values.
        - Finally, the values are compared as follows:
          - For atomic types, their values are compared using ``operator``< or ``strcmp()``, with the
            exception of enums, for which the indices rather than the values are compared.
          - For compounds, the compound size is compared using ``operator``< (the compound size might
            be different for dynamic arrays). If both compounds are of equal size, the compounds
            elements are compared in lexicographic order.
          - For resources, the values are compared using ``strcmp()``.

        :type lhs: :py:class:`IValue`
        :param lhs:          The left-hand side operand for the comparison.
        :type rhs: :py:class:`IValue`
        :param rhs:          The right-hand side operand for the comparison.
        :type epsilon: float, optional
        :param epsilon:      Maximum difference for floating point values to consider them as equal.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.

        |

        *Overload 2:*
        Compares two instances of #mi::neuraylib::IValue_list.

        The comparison operator for instances of #mi::neuraylib::IValue_list is defined as follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Next, the list sizes are compared using ``operator``<().
        - Next, the lists are traversed by increasing index and the names are compared
          using ``strcmp()``.
        - Finally, the list elements are enumerated by increasing index and the values are compared.

        :type lhs: :py:class:`IValue_list`
        :param lhs:          The left-hand side operand for the comparison.
        :type rhs: :py:class:`IValue_list`
        :param rhs:          The right-hand side operand for the comparison.
        :type epsilon: float, optional
        :param epsilon:      Maximum difference for floating point values to consider them as equal.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.

        |

        *Overload 3:*
        Compares two instances of #mi::neuraylib::IValue_list.

        The comparison operator for instances of #mi::neuraylib::IValue_list is defined as follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Next, the list sizes are compared using ``operator``<().
        - Next, the lists are traversed by increasing index and the names are compared
          using ``strcmp()``.
        - Finally, the list elements are enumerated by increasing index and the values are compared.

        :type lhs: :py:class:`IValue_list`
        :param lhs:          The left-hand side operand for the comparison.
        :type rhs: :py:class:`IValue_list`
        :param rhs:          The right-hand side operand for the comparison.
        :param epsilon:      Maximum difference for floating point values to consider them as equal.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.
        """
        return _pymdlsdk._IValue_factory_compare(self, *args)

    def dump(self, *args):
        r"""
        *Overload 1:*
         Returns a textual representation of a value.

         The textual representation is of the form "type name = value" if ``name`` is not ``NULL``, and
         of the form "value" if ``name`` is ``NULL``. The representation of the value might contain
         line breaks, for example for structures, enums, and arrays. Subsequent lines have a suitable
         indentation. The assumed indentation level of the first line is specified by ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 2:*
         Returns a textual representation of a value list.

         The representation of the value list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 3:*
         Returns a textual representation of a value list.

         The representation of the value list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.
        """
        return _pymdlsdk._IValue_factory_dump(self, *args)

# Register _IValue_factory in _pymdlsdk:
_pymdlsdk._IValue_factory_swigregister(_IValue_factory)


def set_value(*args):
    r"""
    *Overload 1:*
    This specialization handles #mi::neuraylib::IValue_bool.

    It expects a ``bool`` as second argument. See #mi::neuraylib::set_value() for details.

    |

    *Overload 2:*
    This specialization handles #mi::neuraylib::IValue_float and #mi::neuraylib::IValue_double.

    It expects an #mi::Float32 as second argument. See #mi::neuraylib::set_value() for details.

    |

    *Overload 3:*
    This specialization handles #mi::neuraylib::IValue_float and #mi::neuraylib::IValue_double.

    It expects an #mi::Float64 as second argument. See #mi::neuraylib::set_value() for details.

    |

    *Overload 4:*
    This specialization handles #mi::neuraylib::IValue_enum, #mi::neuraylib::IValue_string and
    #mi::neuraylib::IValue_resource.

    It expects a ``const`` ``char*`` as second argument. See #mi::neuraylib::set_value() for details.

    |

    *Overload 5:*
    This specialization handles #mi::neuraylib::IValue_color.

    It expects an #mi::math::Color as second argument. See #mi::neuraylib::set_value() for details.

    |

    *Overload 6:*
    This specialization handles #mi::neuraylib::IValue_color.

    It expects an #mi::math::Spectrum as second argument. See #mi::neuraylib::set_value() for
    details.
    """
    return _pymdlsdk.set_value(*args)

def get_value(*args):
    r"""
    *Overload 1:*
    This specialization handles #mi::neuraylib::IValue_bool.

    It expects a ``bool`` as second argument. See #mi::neuraylib::get_value() for details.

    |

    *Overload 2:*
    This specialization handles #mi::neuraylib::IValue_float and #mi::neuraylib::IValue_double.

    It expects an #mi::Float32 as second argument. See #mi::neuraylib::get_value() for details.

    |

    *Overload 3:*
    This specialization handles #mi::neuraylib::IValue_float and #mi::neuraylib::IValue_double.

    It expects an #mi::Float64 as second argument. See #mi::neuraylib::get_value() for details.

    |

    *Overload 4:*
    This specialization handles #mi::neuraylib::IValue_enum, #mi::neuraylib::IValue_string and
    #mi::neuraylib::IValue_resource.

    It expects a ``const`` ``char*`` as second argument. See #mi::neuraylib::get_value() for details.

    |

    *Overload 5:*
    This specialization handles #mi::neuraylib::IValue_color.

    It expects an #mi::math::Color as second argument. See #mi::neuraylib::get_value() for details.

    |

    *Overload 6:*
    This specialization handles #mi::neuraylib::IValue_color.

    It expects an #mi::math::Spectrum as second argument. See #mi::neuraylib::get_value() for
    details.
    """
    return _pymdlsdk.get_value(*args)
MDL_VERSION_1_0 = _pymdlsdk.MDL_VERSION_1_0
r""" MDL version 1.0"""
MDL_VERSION_1_1 = _pymdlsdk.MDL_VERSION_1_1
r""" MDL version 1.1"""
MDL_VERSION_1_2 = _pymdlsdk.MDL_VERSION_1_2
r""" MDL version 1.2"""
MDL_VERSION_1_3 = _pymdlsdk.MDL_VERSION_1_3
r""" MDL version 1.3"""
MDL_VERSION_1_4 = _pymdlsdk.MDL_VERSION_1_4
r""" MDL version 1.4"""
MDL_VERSION_1_5 = _pymdlsdk.MDL_VERSION_1_5
r""" MDL version 1.5"""
MDL_VERSION_1_6 = _pymdlsdk.MDL_VERSION_1_6
r""" MDL version 1.6"""
MDL_VERSION_1_7 = _pymdlsdk.MDL_VERSION_1_7
r""" MDL version 1.7"""
MDL_VERSION_LATEST = _pymdlsdk.MDL_VERSION_LATEST
r""" Latest MDL version"""
MDL_VERSION_INVALID = _pymdlsdk.MDL_VERSION_INVALID
r""" Invalid MDL version"""
MDL_VERSION_FORCE_32_BIT = _pymdlsdk.MDL_VERSION_FORCE_32_BIT
class Interface_declare_IExpression(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IExpression_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IExpression

# Register Interface_declare_IExpression in _pymdlsdk:
_pymdlsdk.Interface_declare_IExpression_swigregister(Interface_declare_IExpression)

def Interface_declare_IExpression_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IExpression_compare_iid(iid)

class _IExpression(Interface_declare_IExpression):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    EK_CONSTANT = _pymdlsdk._IExpression_EK_CONSTANT
    r""" A constant expression. See #mi::neuraylib::IExpression_constant."""
    EK_CALL = _pymdlsdk._IExpression_EK_CALL
    r""" An indirect call expression. See #mi::neuraylib::IExpression_call."""
    EK_PARAMETER = _pymdlsdk._IExpression_EK_PARAMETER
    r""" A parameter reference expression. See #mi::neuraylib::IExpression_parameter."""
    EK_DIRECT_CALL = _pymdlsdk._IExpression_EK_DIRECT_CALL
    r""" A direct call expression. See #mi::neuraylib::IExpression_direct_call."""
    EK_TEMPORARY = _pymdlsdk._IExpression_EK_TEMPORARY
    r""" A temporary reference expression. See #mi::neuraylib::IExpression_temporary."""
    EK_FORCE_32_BIT = _pymdlsdk._IExpression_EK_FORCE_32_BIT

    def _get_kind(self):
        r""" Returns the kind of this expression."""
        return _pymdlsdk._IExpression__get_kind(self)

    def _get_type(self):
        r""" Returns the type of this expression."""
        return _pymdlsdk._IExpression__get_type(self)

# Register _IExpression in _pymdlsdk:
_pymdlsdk._IExpression_swigregister(_IExpression)

class Interface_declare_IExpression_constant(_IExpression):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IExpression_constant_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IExpression_constant

# Register Interface_declare_IExpression_constant in _pymdlsdk:
_pymdlsdk.Interface_declare_IExpression_constant_swigregister(Interface_declare_IExpression_constant)

def Interface_declare_IExpression_constant_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IExpression_constant_compare_iid(iid)

class _IExpression_constant(Interface_declare_IExpression_constant):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value of the constant.

        |

        *Overload 2:*
        Returns the value of the constant.
        """
        return _pymdlsdk._IExpression_constant__get_value(self, *args)

    def set_value(self, value):
        r"""
        Sets the value of the constant.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: The type of ``value`` does not match the type of the constant.
        """
        return _pymdlsdk._IExpression_constant_set_value(self, value)

# Register _IExpression_constant in _pymdlsdk:
_pymdlsdk._IExpression_constant_swigregister(_IExpression_constant)

class Interface_declare_IExpression_call(_IExpression):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IExpression_call_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IExpression_call

# Register Interface_declare_IExpression_call in _pymdlsdk:
_pymdlsdk.Interface_declare_IExpression_call_swigregister(Interface_declare_IExpression_call)

def Interface_declare_IExpression_call_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IExpression_call_compare_iid(iid)

class _IExpression_call(Interface_declare_IExpression_call):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_call(self):
        r""" Returns the DB name of the referenced function call or material instance."""
        return _pymdlsdk._IExpression_call_get_call(self)

    def set_call(self, name):
        r"""
        Sets the name of the referenced function call or material instance.

        :type name: string
        :param name:    The DB name of the function call or material instance.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: There is no DB element with that name.
                           - -3: The DB element has not the correct type.
                           - -4: The return type of the DB element does not match the type of this
                                 expression.
                           - -5: The material instance or function call referenced by "name" is
                                 a parameter default and therefore cannot be used in a call.
                           - -6: The material instance or function call referenced by "name" is
                                 invalid and therefore cannot be used in a call.
        """
        return _pymdlsdk._IExpression_call_set_call(self, name)

# Register _IExpression_call in _pymdlsdk:
_pymdlsdk._IExpression_call_swigregister(_IExpression_call)

class Interface_declare_IExpression_parameter(_IExpression):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IExpression_parameter_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IExpression_parameter

# Register Interface_declare_IExpression_parameter in _pymdlsdk:
_pymdlsdk.Interface_declare_IExpression_parameter_swigregister(Interface_declare_IExpression_parameter)

def Interface_declare_IExpression_parameter_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IExpression_parameter_compare_iid(iid)

class _IExpression_parameter(Interface_declare_IExpression_parameter):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_index(self):
        r""" Returns the index of the referenced parameter."""
        return _pymdlsdk._IExpression_parameter_get_index(self)

    def set_index(self, index):
        r""" Sets the index of the referenced parameter."""
        return _pymdlsdk._IExpression_parameter_set_index(self, index)

# Register _IExpression_parameter in _pymdlsdk:
_pymdlsdk._IExpression_parameter_swigregister(_IExpression_parameter)

class Interface_declare_IExpression_direct_call(_IExpression):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IExpression_direct_call_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IExpression_direct_call

# Register Interface_declare_IExpression_direct_call in _pymdlsdk:
_pymdlsdk.Interface_declare_IExpression_direct_call_swigregister(Interface_declare_IExpression_direct_call)

def Interface_declare_IExpression_direct_call_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IExpression_direct_call_compare_iid(iid)

class _IExpression_direct_call(Interface_declare_IExpression_direct_call):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_definition(self):
        r""" Returns the DB name of the corresponding function or material definition."""
        return _pymdlsdk._IExpression_direct_call_get_definition(self)

    def get_arguments(self):
        r""" Returns the arguments of the direct call."""
        return _pymdlsdk._IExpression_direct_call_get_arguments(self)

# Register _IExpression_direct_call in _pymdlsdk:
_pymdlsdk._IExpression_direct_call_swigregister(_IExpression_direct_call)

class Interface_declare_IExpression_temporary(_IExpression):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IExpression_temporary_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IExpression_temporary

# Register Interface_declare_IExpression_temporary in _pymdlsdk:
_pymdlsdk.Interface_declare_IExpression_temporary_swigregister(Interface_declare_IExpression_temporary)

def Interface_declare_IExpression_temporary_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IExpression_temporary_compare_iid(iid)

class _IExpression_temporary(Interface_declare_IExpression_temporary):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_index(self):
        r""" Returns the index of the referenced temporary."""
        return _pymdlsdk._IExpression_temporary_get_index(self)

    def set_index(self, index):
        r""" Sets the index of the referenced temporary."""
        return _pymdlsdk._IExpression_temporary_set_index(self, index)

# Register _IExpression_temporary in _pymdlsdk:
_pymdlsdk._IExpression_temporary_swigregister(_IExpression_temporary)

class Interface_declare_IExpression_list(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IExpression_list_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IExpression_list

# Register Interface_declare_IExpression_list in _pymdlsdk:
_pymdlsdk.Interface_declare_IExpression_list_swigregister(Interface_declare_IExpression_list)

def Interface_declare_IExpression_list_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IExpression_list_compare_iid(iid)

class _IExpression_list(Interface_declare_IExpression_list):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_size(self):
        r""" Returns the number of elements."""
        return _pymdlsdk._IExpression_list_get_size(self)

    def get_index(self, name):
        r""" Returns the index for the given name, or -1 if there is no such expression."""
        return _pymdlsdk._IExpression_list_get_index(self, name)

    def get_name(self, index):
        r""" Returns the name for the given index, or ``NULL`` if there is no such expression."""
        return _pymdlsdk._IExpression_list_get_name(self, index)

    def _get_expression(self, *args):
        r"""
        *Overload 1:*
        Returns the expression for ``index``, or ``NULL`` if there is no such expression.

        |

        *Overload 2:*
        Returns the expression for ``name``, or ``NULL`` if there is no such expression.
        """
        return _pymdlsdk._IExpression_list__get_expression(self, *args)

    def set_expression(self, *args):
        r"""
        *Overload 1:*
        Sets an expression at a given index.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: ``index`` is out of bounds.

        |

        *Overload 2:*
        Sets an expression identified by name.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is no expression mapped to ``name`` in the list.
        """
        return _pymdlsdk._IExpression_list_set_expression(self, *args)

    def add_expression(self, name, expression):
        r"""
        Adds an expression at the end of the list.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is already an expression mapped to ``name`` in the list.
        """
        return _pymdlsdk._IExpression_list_add_expression(self, name, expression)

# Register _IExpression_list in _pymdlsdk:
_pymdlsdk._IExpression_list_swigregister(_IExpression_list)

class Interface_declare_IAnnotation_definition(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IAnnotation_definition_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IAnnotation_definition

# Register Interface_declare_IAnnotation_definition in _pymdlsdk:
_pymdlsdk.Interface_declare_IAnnotation_definition_swigregister(Interface_declare_IAnnotation_definition)

def Interface_declare_IAnnotation_definition_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IAnnotation_definition_compare_iid(iid)

class _IAnnotation_definition(Interface_declare_IAnnotation_definition):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    AS_UNKNOWN = _pymdlsdk._IAnnotation_definition_AS_UNKNOWN
    r""" Unknown semantics."""
    AS_INTRINSIC_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_INTRINSIC_ANNOTATION
    r""" This is the internal intrinsic() annotation."""
    AS_ANNOTATION_FIRST = _pymdlsdk._IAnnotation_definition_AS_ANNOTATION_FIRST
    AS_THROWS_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_THROWS_ANNOTATION
    r""" This is the internal throws() annotation."""
    AS_SINCE_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_SINCE_ANNOTATION
    r""" This is the internal since() annotation."""
    AS_REMOVED_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_REMOVED_ANNOTATION
    r""" This is the internal removed() annotation."""
    AS_CONST_EXPR_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_CONST_EXPR_ANNOTATION
    r""" This is the internal const_expr() annotation."""
    AS_DERIVABLE_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_DERIVABLE_ANNOTATION
    r""" This is the internal derivable() annotation."""
    AS_NATIVE_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_NATIVE_ANNOTATION
    r""" This is the internal native() annotation."""
    AS_UNUSED_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_UNUSED_ANNOTATION
    r""" This is the unused() annotation."""
    AS_NOINLINE_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_NOINLINE_ANNOTATION
    r""" This is the noinline() annotation."""
    AS_SOFT_RANGE_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_SOFT_RANGE_ANNOTATION
    r""" This is the soft_range() annotation."""
    AS_HARD_RANGE_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_HARD_RANGE_ANNOTATION
    r""" This is the hard_range() annotation."""
    AS_HIDDEN_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_HIDDEN_ANNOTATION
    r""" This is the hidden() annotation."""
    AS_DEPRECATED_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_DEPRECATED_ANNOTATION
    r""" This is the deprecated() annotation."""
    AS_VERSION_NUMBER_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_VERSION_NUMBER_ANNOTATION
    r""" This is the (old) version_number() annotation."""
    AS_VERSION_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_VERSION_ANNOTATION
    r""" This is the version() annotation."""
    AS_DEPENDENCY_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_DEPENDENCY_ANNOTATION
    r""" This is the dependency() annotation."""
    AS_UI_ORDER_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_UI_ORDER_ANNOTATION
    r""" This is the ui_order() annotation."""
    AS_USAGE_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_USAGE_ANNOTATION
    r""" This is the usage() annotation."""
    AS_ENABLE_IF_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_ENABLE_IF_ANNOTATION
    r""" This is the enable_if() annotation."""
    AS_THUMBNAIL_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_THUMBNAIL_ANNOTATION
    r""" This is the thumbnail() annotation."""
    AS_DISPLAY_NAME_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_DISPLAY_NAME_ANNOTATION
    r""" This is the display_name() annotation."""
    AS_IN_GROUP_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_IN_GROUP_ANNOTATION
    r""" This is the in_group() annotation."""
    AS_DESCRIPTION_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_DESCRIPTION_ANNOTATION
    r""" This is the description() annotation."""
    AS_AUTHOR_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_AUTHOR_ANNOTATION
    r""" This is the author() annotation."""
    AS_CONTRIBUTOR_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_CONTRIBUTOR_ANNOTATION
    r""" This is the contributor() annotation."""
    AS_COPYRIGHT_NOTICE_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_COPYRIGHT_NOTICE_ANNOTATION
    r""" This is the copyright_notice() annotation."""
    AS_CREATED_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_CREATED_ANNOTATION
    r""" This is the created() annotation."""
    AS_MODIFIED_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_MODIFIED_ANNOTATION
    r""" This is the modified() annotation."""
    AS_KEYWORDS_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_KEYWORDS_ANNOTATION
    r""" This is the key_words() annotation."""
    AS_ORIGIN_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_ORIGIN_ANNOTATION
    r""" This is the origin() annotation."""
    AS_ANNOTATION_LAST = _pymdlsdk._IAnnotation_definition_AS_ANNOTATION_LAST
    AS_FORCE_32_BIT = _pymdlsdk._IAnnotation_definition_AS_FORCE_32_BIT

    def get_module(self):
        r"""
        Returns the DB name of the module containing this annotation definition.

        The type of the module is #mi::neuraylib::IModule.
        """
        return _pymdlsdk._IAnnotation_definition_get_module(self)

    def get_name(self):
        r""" Returns the MDL name of the annotation definition."""
        return _pymdlsdk._IAnnotation_definition_get_name(self)

    def get_mdl_module_name(self):
        r""" Returns the MDL name of the module containing this annotation definition."""
        return _pymdlsdk._IAnnotation_definition_get_mdl_module_name(self)

    def get_mdl_simple_name(self):
        r"""
        Returns the simple MDL name of the annotation definition.

        The simple name is the last component of the MDL name, i.e., without any packages and
        scope qualifiers, and without the parameter type names.

        :rtype: string
        :return: The simple MDL name of the annotation definition.
        """
        return _pymdlsdk._IAnnotation_definition_get_mdl_simple_name(self)

    def get_mdl_parameter_type_name(self, index):
        r"""
        Returns the type name of the parameter at ``index``.

        Notes: The type names provided here are substrings of the MDL name returned by #get_name().
              They are provided here such that parsing of the MDL name is not necessary. However,
              for most use cases it is strongly recommended to use #get_parameter_types() instead.

        :type index: int
        :param index:    The index of the parameter.
        :rtype: string
        :return: The type name of the parameter, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk._IAnnotation_definition_get_mdl_parameter_type_name(self, index)

    def get_semantic(self):
        r""" Returns the semantic of this annotation definition."""
        return _pymdlsdk._IAnnotation_definition_get_semantic(self)

    def is_exported(self):
        r""" Indicates whether the annotation definition is exported by its module."""
        return _pymdlsdk._IAnnotation_definition_is_exported(self)

    def get_mdl_version(self, since, removed):
        r"""
        Returns the MDL version when this annotation definition was added and removed.

        :type since: int, out
        :param since:     The MDL version in which this annotation definition was added. If the
                                  annotation definition does not belong to the standard library, the
                                  MDL version of the corresponding module is returned.
        :type removed: int, out
        :param removed:   The MDL version in which this annotation definition was removed, or
                                  mi::neuraylib::MDL_VERSION_INVALID if the annotation has not been
                                  removed so far or does not belong to the standard library.
        """
        return _pymdlsdk._IAnnotation_definition_get_mdl_version(self, since, removed)

    def get_parameter_count(self):
        r""" Returns the parameter count of the annotation definition."""
        return _pymdlsdk._IAnnotation_definition_get_parameter_count(self)

    def get_parameter_name(self, index):
        r"""
        Returns the parameter name of the given index.

        :type index: int
        :param index:    The parameter index.
        :rtype: string
        :return: The name of the parameter or ``NULL`` if index
                            is out of range.
        """
        return _pymdlsdk._IAnnotation_definition_get_parameter_name(self, index)

    def get_parameter_index(self, name):
        r"""
        Returns the parameter index of the given name.

        :type name: string
        :param name:     The parameter name.
        :rtype: int
        :return: The index of the parameter or ``-1`` if there is no
                            parameter of that ``name``.
        """
        return _pymdlsdk._IAnnotation_definition_get_parameter_index(self, name)

    def get_parameter_types(self):
        r""" Returns the parameter types of the annotation definition."""
        return _pymdlsdk._IAnnotation_definition_get_parameter_types(self)

    def get_defaults(self):
        r""" Returns the parameter defaults of the annotation definition."""
        return _pymdlsdk._IAnnotation_definition_get_defaults(self)

    def get_annotations(self):
        r"""
        Returns the annotations of this definition or ``NULL`` if no
        annotations exist.
        """
        return _pymdlsdk._IAnnotation_definition_get_annotations(self)

    def create_annotation(self, arguments):
        r"""
        Creates an annotation.

        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments for new annotation.
        :rtype: :py:class:`IAnnotation`
        :return: The created annotation or ``NULL`` if one of the arguments
                                does not correspond to an actual parameter of the annotation or
                                is not a constant expression.
        """
        return _pymdlsdk._IAnnotation_definition_create_annotation(self, arguments)

# Register _IAnnotation_definition in _pymdlsdk:
_pymdlsdk._IAnnotation_definition_swigregister(_IAnnotation_definition)

class Interface_declare_IAnnotation(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IAnnotation_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IAnnotation

# Register Interface_declare_IAnnotation in _pymdlsdk:
_pymdlsdk.Interface_declare_IAnnotation_swigregister(Interface_declare_IAnnotation)

def Interface_declare_IAnnotation_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IAnnotation_compare_iid(iid)

class _IAnnotation(Interface_declare_IAnnotation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_name(self):
        r""" Returns the name of the annotation."""
        return _pymdlsdk._IAnnotation_get_name(self)

    def set_name(self, name):
        r""" Sets the name of the annotation."""
        return _pymdlsdk._IAnnotation_set_name(self, name)

    def get_arguments(self):
        r"""
        Returns the arguments of the annotation.

        The arguments of annotations are always constant expressions.
        """
        return _pymdlsdk._IAnnotation_get_arguments(self)

    def get_definition(self):
        r""" Returns the definition of this annotation."""
        return _pymdlsdk._IAnnotation_get_definition(self)

# Register _IAnnotation in _pymdlsdk:
_pymdlsdk._IAnnotation_swigregister(_IAnnotation)

class Interface_declare_IAnnotation_block(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IAnnotation_block_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IAnnotation_block

# Register Interface_declare_IAnnotation_block in _pymdlsdk:
_pymdlsdk.Interface_declare_IAnnotation_block_swigregister(Interface_declare_IAnnotation_block)

def Interface_declare_IAnnotation_block_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IAnnotation_block_compare_iid(iid)

class _IAnnotation_block(Interface_declare_IAnnotation_block):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_size(self):
        r""" Returns the number of annotations in this block."""
        return _pymdlsdk._IAnnotation_block_get_size(self)

    def get_annotation(self, index):
        r""" Returns the annotation for ``index``, or ``NULL`` if index is out of bounds."""
        return _pymdlsdk._IAnnotation_block_get_annotation(self, index)

    def set_annotation(self, index, annotation):
        r"""
        Sets an annotation block at a given index.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: ``index`` is out of bounds.
        """
        return _pymdlsdk._IAnnotation_block_set_annotation(self, index, annotation)

    def add_annotation(self, annotation):
        r"""
        Adds an annotation at the end of the annotation block.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
        """
        return _pymdlsdk._IAnnotation_block_add_annotation(self, annotation)

# Register _IAnnotation_block in _pymdlsdk:
_pymdlsdk._IAnnotation_block_swigregister(_IAnnotation_block)

class Interface_declare_IAnnotation_list(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IAnnotation_list_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IAnnotation_list

# Register Interface_declare_IAnnotation_list in _pymdlsdk:
_pymdlsdk.Interface_declare_IAnnotation_list_swigregister(Interface_declare_IAnnotation_list)

def Interface_declare_IAnnotation_list_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IAnnotation_list_compare_iid(iid)

class _IAnnotation_list(Interface_declare_IAnnotation_list):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_size(self):
        r""" Returns the number of elements."""
        return _pymdlsdk._IAnnotation_list_get_size(self)

    def get_index(self, name):
        r""" Returns the index for the given name, or -1 if there is no such block."""
        return _pymdlsdk._IAnnotation_list_get_index(self, name)

    def get_name(self, index):
        r""" Returns the name for the given index, or ``NULL`` if there is no such block."""
        return _pymdlsdk._IAnnotation_list_get_name(self, index)

    def get_annotation_block(self, *args):
        r"""
        *Overload 1:*
        Returns the annotation block for ``index``, or ``NULL`` if there is no such block.

        |

        *Overload 2:*
        Returns the annotation block for ``name``, or ``NULL`` if there is no such block.
        """
        return _pymdlsdk._IAnnotation_list_get_annotation_block(self, *args)

    def set_annotation_block(self, *args):
        r"""
        *Overload 1:*
        Sets an annotation block at a given index.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: ``index`` is out of bounds.

        |

        *Overload 2:*
        Sets an annotation block identified by name.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is no annotation block mapped to ``name`` in the list.
        """
        return _pymdlsdk._IAnnotation_list_set_annotation_block(self, *args)

    def add_annotation_block(self, name, block):
        r"""
        Adds an annotation block at the end of the list.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is already an annotation block mapped to ``name`` in the list.
        """
        return _pymdlsdk._IAnnotation_list_add_annotation_block(self, name, block)

# Register _IAnnotation_list in _pymdlsdk:
_pymdlsdk._IAnnotation_list_swigregister(_IAnnotation_list)

class Interface_declare_IExpression_factory(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IExpression_factory_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IExpression_factory

# Register Interface_declare_IExpression_factory in _pymdlsdk:
_pymdlsdk.Interface_declare_IExpression_factory_swigregister(Interface_declare_IExpression_factory)

def Interface_declare_IExpression_factory_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IExpression_factory_compare_iid(iid)

class _IExpression_factory(Interface_declare_IExpression_factory):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_value_factory(self):
        r""" Returns the value factory associated with this expression factory."""
        return _pymdlsdk._IExpression_factory_get_value_factory(self)

    def create_constant(self, value):
        r"""
        Creates a constant (const).

        :type value: :py:class:`IValue`
        :param value:        The value of the constant.
        :rtype: :py:class:`IExpression_constant`
        :return: The created constant.
        """
        return _pymdlsdk._IExpression_factory_create_constant(self, value)

    def create_call(self, name):
        r"""
        Creates a call.

        :type name: string
        :param name:         The DB name of the referenced function call or material instance.
        :rtype: :py:class:`IExpression_call`
        :return: The created call, or ``NULL`` in case of errors.
        """
        return _pymdlsdk._IExpression_factory_create_call(self, name)

    def create_parameter(self, type, index):
        r"""
        Creates a parameter reference.

        :type type: :py:class:`IType`
        :param type:         The type of the parameter.
        :type index: int
        :param index:        The index of the parameter.
        :rtype: :py:class:`IExpression_parameter`
        :return: The created parameter reference, or ``NULL`` in case of errors.
        """
        return _pymdlsdk._IExpression_factory_create_parameter(self, type, index)

    def create_direct_call_with_ret(self, name, arguments):
        r"""
        Creates a direct call.

        :type name: string
        :param name:         The DB name of the referenced function or material definition.
        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments of the created direct call.

                                Arguments for parameters without default are mandatory, otherwise
                                optional. The type of an argument must match the corresponding parameter
                                type. Any argument missing in ``arguments`` will be set to the default of
                                the corresponding parameter.

                                Note that the expressions in ``arguments`` are copied. Valid
                                subexpressions are constants, direct calls, and parameter references.
                                operation is a deep copy, e.g., DB elements referenced in call
                                expressions are also copied.

                                ``NULL`` is a valid argument which is handled like an empty expression
                                list.
        :type errors: int, out, optional
        :param errors:  An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                -  0: Success.
                                - -1: An argument for a non-existing parameter was provided in
                                      ``arguments``.
                                - -2: The type of an argument in ``arguments`` does not have the correct
                                      type.
                                - -3: A parameter that has no default was not provided with an argument
                                      value.
                                - -4: The function or material definition can not be instantiated
                                      because it is not exported.
                                - -5: A parameter type is uniform, but the corresponding argument has a
                                      varying return type.
                                - -6: An argument expression is not a constant, a direct call, nor a
                                      parameter.
                                - -7: Invalid parameters (``NULL`` pointer) or ``name`` is not a valid
                                      DB name of a function or material definition.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument or default is a call expression and the return type of
                                      the called function or material definition is effectively varying
                                      since the function or material definition itself is varying.
                                - -9: The function or material definition is invalid due to a module
                                      reload.
        :rtype: :py:class:`IExpression_direct_call`
        :return: The created call, or ``NULL`` in case of errors.
        """
        return _pymdlsdk._IExpression_factory_create_direct_call_with_ret(self, name, arguments)

    def create_direct_call(self, name, arguments):
        r"""
        Creates a direct call.

        :type name: string
        :param name:         The DB name of the referenced function or material definition.
        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments of the created direct call.

                                Arguments for parameters without default are mandatory, otherwise
                                optional. The type of an argument must match the corresponding parameter
                                type. Any argument missing in ``arguments`` will be set to the default of
                                the corresponding parameter.

                                Note that the expressions in ``arguments`` are copied. Valid
                                subexpressions are constants, direct calls, and parameter references.
                                operation is a deep copy, e.g., DB elements referenced in call
                                expressions are also copied.

                                ``NULL`` is a valid argument which is handled like an empty expression
                                list.
        :param errors:  An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                -  0: Success.
                                - -1: An argument for a non-existing parameter was provided in
                                      ``arguments``.
                                - -2: The type of an argument in ``arguments`` does not have the correct
                                      type.
                                - -3: A parameter that has no default was not provided with an argument
                                      value.
                                - -4: The function or material definition can not be instantiated
                                      because it is not exported.
                                - -5: A parameter type is uniform, but the corresponding argument has a
                                      varying return type.
                                - -6: An argument expression is not a constant, a direct call, nor a
                                      parameter.
                                - -7: Invalid parameters (``NULL`` pointer) or ``name`` is not a valid
                                      DB name of a function or material definition.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument or default is a call expression and the return type of
                                      the called function or material definition is effectively varying
                                      since the function or material definition itself is varying.
                                - -9: The function or material definition is invalid due to a module
                                      reload.
        :rtype: :py:class:`IExpression_direct_call`
        :return: The created call, or ``NULL`` in case of errors.
        """
        return _pymdlsdk._IExpression_factory_create_direct_call(self, name, arguments)

    def create_expression_list(self):
        r""" Creates a new expression list."""
        return _pymdlsdk._IExpression_factory_create_expression_list(self)

    def create_annotation(self, name, arguments):
        r"""
        Creates a new annotation.

        Returns ``NULL`` if one of the arguments is not a constant expression.
        """
        return _pymdlsdk._IExpression_factory_create_annotation(self, name, arguments)

    def create_annotation_block(self):
        r""" Creates a new annotation block."""
        return _pymdlsdk._IExpression_factory_create_annotation_block(self)

    def create_annotation_list(self):
        r""" Creates a new annotation list."""
        return _pymdlsdk._IExpression_factory_create_annotation_list(self)

    def clone(self, *args):
        r"""
        *Overload 1:*
        Clones the given expression.

        Note that referenced DB elements, e.g., resources in constant expressions, or function calls
        and material instances in call expressions, are not copied, but shared. Function calls and
        material instances that serve as default arguments, are copied, though.

        |

        *Overload 2:*
        Clones the given expression list.

        Note that referenced DB elements, e.g., resources in constant expressions, or function calls
        and material instances in call expressions, are not copied, but shared.
        """
        return _pymdlsdk._IExpression_factory_clone(self, *args)
    DEFAULT_COMPARISON_OPTIONS = _pymdlsdk._IExpression_factory_DEFAULT_COMPARISON_OPTIONS
    r""" Default comparison options."""
    DEEP_CALL_COMPARISONS = _pymdlsdk._IExpression_factory_DEEP_CALL_COMPARISONS
    r"""
    This option indicates that call expressions should be compared for equality, not for
    identity. That is, the comparison is not done via
    #mi::neuraylib::IExpression::get_value(), but by traversing into the referenced
    function call, i.e., comparing the function definition reference and the arguments.
    This option is useful if you want to decide whether an argument is *semantically* equal
    to the corresponding default parameter.
    """
    SKIP_TYPE_ALIASES = _pymdlsdk._IExpression_factory_SKIP_TYPE_ALIASES
    r"""
    This option indicates that all type aliases should be skipped before types of
    expression are compared. Defaults and argument might sometimes differ in explicit type
    modifiers, therefore this option is useful if you want to decide whether an argument is
    *semantically* equal to the corresponding default parameter.
    """
    COMPARISON_OPTIONS_FORCE_32_BIT = _pymdlsdk._IExpression_factory_COMPARISON_OPTIONS_FORCE_32_BIT

    def compare(self, *args):
        r"""
        *Overload 1:*
        Compares two instances of #mi::neuraylib::IExpression.

        The comparison operator for instances of #mi::neuraylib::IExpression is defined as follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Otherwise, the types of ``lhs`` and ``rhs`` are compared. If they are different, the result
          is determined by that comparison.
        - Next, the kind of the expressions are compared. If they are different, the result is
          determined by ``operator``< on the #mi::neuraylib::IExpression::Kind values. Note that
          setting #SKIP_TYPE_ALIASES in ``flags`` modifies this behavior.
        - Finally, the expressions are compared as follows:
          - For constants the results is defined by comparing their values.
          - For calls, the result is defined by comparison of the call reference (unless
            #DEEP_CALL_COMPARISONS is set in ``flags)``. Note that the representation of this call
            reference is an internal implementation detail, and the comparison result might have
            the opposite sign as ``strcmp()`` on the strings returned by
            #mi::neuraylib::IExpression_call::get_call().
          - For parameter and temporary references, the results is defined by ``operator``<() on the
            indices.
          - For indirect calls, first the definition reference is compared. Note that the
            representation of this definition reference is an internal implementation detail, and
            the comparison result might have the opposite sign as ``strcmp()`` on the strings
            returned by #mi::neuraylib::IExpression_direct_call::get_definition(). If both indirect
            call reference the same definition, then the result is defined by comparison of the
            arguments.

        :type lhs: :py:class:`IExpression`
        :param lhs:          The left-hand side operand for the comparison.
        :type rhs: :py:class:`IExpression`
        :param rhs:          The right-hand side operand for the comparison.
        :type flags: int, optional
        :param flags:        A bitmask of flags of type #Comparison_options.
        :type epsilon: float, optional
        :param epsilon:      Maximum difference for floating point values to consider them as equal.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.

        |

        *Overload 2:*
        Compares two instances of #mi::neuraylib::IExpression_list.

        The comparison operator for instances of #mi::neuraylib::IExpression_list is defined as
        follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Next, the list sizes are compared using ``operator``<().
        - Next, the lists are traversed by increasing index and the names are compared using
          ``strcmp()``.
        - Finally, the list elements are enumerated by increasing index and the expressions are
          compared.

        :type lhs: :py:class:`IExpression_list`
        :param lhs:          The left-hand side operand for the comparison.
        :type rhs: :py:class:`IExpression_list`
        :param rhs:          The right-hand side operand for the comparison.
        :type flags: int, optional
        :param flags:        A bitmask of flags of type #Comparison_options.
        :type epsilon: float, optional
        :param epsilon:      Maximum difference for floating point values to consider them as equal.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.

        |

        *Overload 3:*
        Compares two instances of #mi::neuraylib::IExpression_list.

        The comparison operator for instances of #mi::neuraylib::IExpression_list is defined as
        follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Next, the list sizes are compared using ``operator``<().
        - Next, the lists are traversed by increasing index and the names are compared using
          ``strcmp()``.
        - Finally, the list elements are enumerated by increasing index and the expressions are
          compared.

        :type lhs: :py:class:`IExpression_list`
        :param lhs:          The left-hand side operand for the comparison.
        :type rhs: :py:class:`IExpression_list`
        :param rhs:          The right-hand side operand for the comparison.
        :type flags: int, optional
        :param flags:        A bitmask of flags of type #Comparison_options.
        :param epsilon:      Maximum difference for floating point values to consider them as equal.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.

        |

        *Overload 4:*
        Compares two instances of #mi::neuraylib::IExpression_list.

        The comparison operator for instances of #mi::neuraylib::IExpression_list is defined as
        follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Next, the list sizes are compared using ``operator``<().
        - Next, the lists are traversed by increasing index and the names are compared using
          ``strcmp()``.
        - Finally, the list elements are enumerated by increasing index and the expressions are
          compared.

        :type lhs: :py:class:`IExpression_list`
        :param lhs:          The left-hand side operand for the comparison.
        :type rhs: :py:class:`IExpression_list`
        :param rhs:          The right-hand side operand for the comparison.
        :param flags:        A bitmask of flags of type #Comparison_options.
        :param epsilon:      Maximum difference for floating point values to consider them as equal.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.
        """
        return _pymdlsdk._IExpression_factory_compare(self, *args)

    def dump(self, *args):
        r"""
        *Overload 1:*
         Returns a textual representation of an expression.

         The parameter ``depth`` is only relevant for constants, where the argument is passed to
         #mi::neuraylib::IValue_factory::dump().

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 2:*
         Returns a textual representation of an expression list.

         The representation of the expression list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 3:*
         Returns a textual representation of an expression list.

         The representation of the expression list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 4:*
         Returns a textual representation of an annotation.

         The representation of the annotation will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 5:*
         Returns a textual representation of an annotation.

         The representation of the annotation will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 6:*
         Returns a textual representation of an annotation block.

         The representation of the annotation block will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 7:*
         Returns a textual representation of an annotation block.

         The representation of the annotation block will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 8:*
         Returns a textual representation of an annotation list.

         The representation of the annotation list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 9:*
         Returns a textual representation of an annotation list.

         The representation of the annotation list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.
        """
        return _pymdlsdk._IExpression_factory_dump(self, *args)

    def create_cast_with_ret(self, src_expr, target_type, cast_db_name, force_cast):
        r"""
        Returns an expression which casts the source expression to the ``target_type``.

        This is a convenience function that creates an instance of the cast operator with
        the necessary arguments, stores it in the database and creates and returns an
        #mi::neuraylib::IExpression_call using the just created function. If ``force_cast`` is
        set to ``true``, the cast will always be inserted, even if the types match. If ``force_cast``
        is set to ``false``, the original expression is returned for identical types.
        If the type of ``src_expr`` and ``target_type`` are not compatible, ``NULL`` is returned.

        :type src_expr: :py:class:`IExpression`
        :param src_expr:     The expression whose type is supposed to be casted.
        :type target_type: :py:class:`IType`
        :param target_type:  The result type of the cast. Note that the inserted cast operator acts on
                                types without qualifiers, i.e., modifiers on ``target_type`` are ignored.
        :type cast_db_name: string
        :param cast_db_name: This name is used when storing the instance
                                of the cast-operator function into the database. If the name is already
                                taken by another DB element, this string will be used as the base for
                                generating a unique name. If NULL, a unique name is generated.
        :type force_cast: boolean
        :param force_cast:   If ``true``, the cast will be created even if the types are
                                identical. Please note that a cast cannot be forced for
                                incompatible types.
        :type errors: int, optional
        :param errors:       An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                - 0: Success.
                                - 1: Invalid parameters (``NULL`` pointer).
                                - 2: The type of ``src_expr`` cannot be cast to ``target_type``.

        :rtype: :py:class:`IExpression`
        :return: The resulting expression or ``NULL`` in case of failure.
        """
        return _pymdlsdk._IExpression_factory_create_cast_with_ret(self, src_expr, target_type, cast_db_name, force_cast)

    def create_cast(self, src_expr, target_type, cast_db_name, force_cast):
        r"""
        Returns an expression which casts the source expression to the ``target_type``.

        This is a convenience function that creates an instance of the cast operator with
        the necessary arguments, stores it in the database and creates and returns an
        #mi::neuraylib::IExpression_call using the just created function. If ``force_cast`` is
        set to ``true``, the cast will always be inserted, even if the types match. If ``force_cast``
        is set to ``false``, the original expression is returned for identical types.
        If the type of ``src_expr`` and ``target_type`` are not compatible, ``NULL`` is returned.

        :type src_expr: :py:class:`IExpression`
        :param src_expr:     The expression whose type is supposed to be casted.
        :type target_type: :py:class:`IType`
        :param target_type:  The result type of the cast. Note that the inserted cast operator acts on
                                types without qualifiers, i.e., modifiers on ``target_type`` are ignored.
        :type cast_db_name: string
        :param cast_db_name: This name is used when storing the instance
                                of the cast-operator function into the database. If the name is already
                                taken by another DB element, this string will be used as the base for
                                generating a unique name. If NULL, a unique name is generated.
        :type force_cast: boolean
        :param force_cast:   If ``true``, the cast will be created even if the types are
                                identical. Please note that a cast cannot be forced for
                                incompatible types.
        :param errors:       An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                - 0: Success.
                                - 1: Invalid parameters (``NULL`` pointer).
                                - 2: The type of ``src_expr`` cannot be cast to ``target_type``.

        :rtype: :py:class:`IExpression`
        :return: The resulting expression or ``NULL`` in case of failure.
        """
        return _pymdlsdk._IExpression_factory_create_cast(self, src_expr, target_type, cast_db_name, force_cast)

# Register _IExpression_factory in _pymdlsdk:
_pymdlsdk._IExpression_factory_swigregister(_IExpression_factory)

MDL_REPAIR_DEFAULT = _pymdlsdk.MDL_REPAIR_DEFAULT
r""" Default mode, do not alter any inputs."""
MDL_REMOVE_INVALID_ARGUMENTS = _pymdlsdk.MDL_REMOVE_INVALID_ARGUMENTS
r""" Remove an invalid call attached to an argument."""
MDL_REPAIR_INVALID_ARGUMENTS = _pymdlsdk.MDL_REPAIR_INVALID_ARGUMENTS
r""" Attempt to repair invalid calls attached to an argument."""
MDL_REPAIR_OPTIONS_FORCE_32_BIT = _pymdlsdk.MDL_REPAIR_OPTIONS_FORCE_32_BIT
class Interface_declare_IFunction_call(_IScene_element):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IFunction_call_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IFunction_call

# Register Interface_declare_IFunction_call in _pymdlsdk:
_pymdlsdk.Interface_declare_IFunction_call_swigregister(Interface_declare_IFunction_call)

def Interface_declare_IFunction_call_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IFunction_call_compare_iid(iid)

class _IFunction_call(Interface_declare_IFunction_call):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_function_definition(self):
        r"""
        Returns the DB name of the corresponding function definition.

        The type of the function definition is #mi::neuraylib::IFunction_definition.

        Notes: The DB name of the function definition is different from its MDL name (see
              #get_mdl_function_definition()).
        """
        return _pymdlsdk._IFunction_call_get_function_definition(self)

    def get_mdl_function_definition(self):
        r"""
        Returns the MDL name of the corresponding function definition.

        Notes: The MDL name of the function definition is different from the name of the DB element
              (see #get_function_definition()).
        """
        return _pymdlsdk._IFunction_call_get_mdl_function_definition(self)

    def is_material(self):
        r"""
        Indicates whether the call represents a material instance.

        If 'mi_mdl_materials_are_functions' is disabled, then this method returns always
        ``false``.
        """
        return _pymdlsdk._IFunction_call_is_material(self)

    def is_array_constructor(self):
        r"""
        Indicates whether this call is an instance of the array constructor.

        See also: 'mi_neuray_mdl_arrays'
        """
        return _pymdlsdk._IFunction_call_is_array_constructor(self)

    def get_return_type(self):
        r""" Returns the return type of the corresponding function definition."""
        return _pymdlsdk._IFunction_call_get_return_type(self)

    def get_parameter_count(self):
        r""" Returns the number of parameters."""
        return _pymdlsdk._IFunction_call_get_parameter_count(self)

    def get_parameter_name(self, index):
        r"""
        Returns the name of the parameter at ``index``.

        :type index: int
        :param index:        The index of the parameter.
        :rtype: string
        :return: The name of the parameter, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk._IFunction_call_get_parameter_name(self, index)

    def get_parameter_index(self, name):
        r"""
        Returns the index position of a parameter.

        :type name: string
        :param name:         The name of the parameter.
        :rtype: int
        :return: The index of the parameter, or -1 if ``name`` is invalid.
        """
        return _pymdlsdk._IFunction_call_get_parameter_index(self, name)

    def get_parameter_types(self):
        r""" Returns the types of all parameters."""
        return _pymdlsdk._IFunction_call_get_parameter_types(self)

    def get_arguments(self):
        r""" Returns all arguments."""
        return _pymdlsdk._IFunction_call_get_arguments(self)

    def set_arguments(self, arguments):
        r"""
        Sets multiple arguments.

        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments. Note that the expressions are copied. This copy operation
                                is a shallow copy, e.g., DB elements referenced in call expressions are
                                *not* copied.
        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer).
                                - -2: One of the parameters in ``arguments`` does not exist.
                                - -3: One of the argument types does not match the corresponding
                                      parameter type.
                                - -4: The function call is immutable (because it appears in a default of
                                      a function or material definition).
                                - -5: One of the parameter types is uniform, but the corresponding
                                      argument type is varying.
                                - -6: One of the arguments is not a constant nor a call.
                                - -7: One of the arguments contains references to DB elements in a scope
                                      that is more private scope than the scope of this material
                                      instance.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument is a call expression and the return type of the
                                      called function definition is effectively varying since the
                                      function definition itself is varying.
        """
        return _pymdlsdk._IFunction_call_set_arguments(self, arguments)

    def set_argument(self, *args):
        r"""
        *Overload 1:*
        Sets the argument at ``index``.

        :type index: int
        :param index:        The index of the argument.
        :type argument: :py:class:`IExpression`
        :param argument:     The argument. Note that the expression is copied. This copy operation
                                is a shallow copy, e.g., DB elements referenced in call expressions are
                                *not* copied.
        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer).
                                - -2: Parameter ``index`` does not exist.
                                - -3: The argument type does not match the parameter type.
                                - -4: The function call is immutable (because it appears in a default of
                                      a function or material definition).
                                - -5: The parameter type is uniform, but the argument type is varying.
                                - -6: The argument expression is not a constant nor a call.
                                - -7: The argument contains references to DB elements in a scope that is
                                      more private scope than the scope of this material instance.
                                - -8: The parameter types is uniform, but the argument is a call
                                      expression and the return type of the called function definition
                                      is effectively varying since the function definition itself is
                                      varying.

        |

        *Overload 2:*
        Sets an argument identified by name.

        :type name: string
        :param name:         The name of the parameter.
        :type argument: :py:class:`IExpression`
        :param argument:     The argument. Note that the expression is copied. This copy operation
                                is a shallow copy, e.g., DB elements referenced in call expressions are
                                *not* copied.
        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer).
                                - -2: Parameter ``name`` does not exist.
                                - -3: The argument type does not match the parameter type.
                                - -4: The function call is immutable (because it appears in a default of
                                      a function or material definition).
                                - -5: The parameter type is uniform, but the argument type is varying.
                                - -6: The argument expression is not a constant nor a call.
                                - -7: The argument contains references to DB elements in a scope that is
                                      more private scope than the scope of this material instance.
                                - -8: The parameter types is uniform, but the argument is a call
                                      expression and the return type of the called function definition
                                      is effectively varying since the function definition itself is
                                      varying.
        """
        return _pymdlsdk._IFunction_call_set_argument(self, *args)

    def reset_argument(self, *args):
        r"""
        *Overload 1:*
        Resets the argument at ``index``.

        If the function definition has a default for this parameter (and it does not violate a
        potential uniform requirement), then a clone of it is used as new argument. Otherwise, a
        constant expression is created, observing range annotations if present (see the overload of
        #mi::neuraylib::IValue_factory::create() with two arguments).

        :type index: int
        :param index:        The index of the argument.
        :rtype: int
        :return: 
                                -   0: Success.
                                -  -2: Parameter ``index`` does not exist.
                                -  -4: The function call is immutable (because it appears in a default
                                       of a function or material definition).
                                -  -9: The function call is not valid (see #is_valid()).

        |

        *Overload 2:*
        Resets an argument identified by name

        If the function definition has a default for this parameter (and it does not violate a
        potential uniform requirement), then a clone of it is used as new argument. Otherwise, a
        constant expression is created, observing range annotations if present (see the overload of
        #mi::neuraylib::IValue_factory::create() with two arguments).

        :type name: string
        :param name:         The name of the parameter.
        :rtype: int
        :return: 
                                -   0: Success.
                                -  -1: Invalid parameters (``NULL`` pointer).
                                -  -2: Parameter ``name`` does not exist.
                                -  -4: The function call is immutable (because it appears in a default
                                       of a function or material definition).
                                -  -9: The function call is not valid (see #is_valid()).
        """
        return _pymdlsdk._IFunction_call_reset_argument(self, *args)

    def is_default(self):
        r"""
        Indicates, if this function call acts as a default argument of a material or function
        definition.

        Defaults are immutable, their arguments cannot be changed and they cannot be used
        in call expressions.

        :rtype: boolean
        :return: ``true``, if this function call is a default, ``false`` otherwise.
        """
        return _pymdlsdk._IFunction_call_is_default(self)

    def is_valid(self, context):
        r"""
        Returns ``true`` if this function call and all its arguments point to valid
        material and function definitions, ``false`` otherwise.

        Material and function definitions can become invalid due to a module reload.

        See also: #mi::neuraylib::IModule::reload(), #mi::neuraylib::IFunction_call::repair()

        :type context: :py:class:`IMdl_execution_context`
        :param context:  Execution context that can be queried for error messages
                            after the operation has finished. Can be ``NULL``.
        :rtype: boolean
        :return: 
                 - ``true``:  The instance is valid.
                 - ``false``: The instance is invalid.
        """
        return _pymdlsdk._IFunction_call_is_valid(self, context)

    def repair(self, flags, context):
        r"""
        Attempts to repair an invalid function call.

        :type flags: int
        :param flags:    Repair options, see #mi::neuraylib::Mdl_repair_options.
        :type context: :py:class:`IMdl_execution_context`
        :param context:  Execution context that can be queried for error messages
                            after the operation has finished. Can be ``NULL``.
        :rtype: int
        :return: 
                -   0:   Success.
                -  -1:   Repair failed. Check the ``context`` for details.
        """
        return _pymdlsdk._IFunction_call_repair(self, flags, context)

# Register _IFunction_call in _pymdlsdk:
_pymdlsdk._IFunction_call_swigregister(_IFunction_call)

class Interface_declare_IFunction_definition(_IScene_element):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IFunction_definition_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IFunction_definition

# Register Interface_declare_IFunction_definition in _pymdlsdk:
_pymdlsdk.Interface_declare_IFunction_definition_swigregister(Interface_declare_IFunction_definition)

def Interface_declare_IFunction_definition_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IFunction_definition_compare_iid(iid)

class _IFunction_definition(Interface_declare_IFunction_definition):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    DS_UNKNOWN = _pymdlsdk._IFunction_definition_DS_UNKNOWN
    r""" Unknown semantics."""
    DS_CONV_CONSTRUCTOR = _pymdlsdk._IFunction_definition_DS_CONV_CONSTRUCTOR
    r""" The conversion constructor."""
    DS_ELEM_CONSTRUCTOR = _pymdlsdk._IFunction_definition_DS_ELEM_CONSTRUCTOR
    r""" The elemental constructor."""
    DS_COLOR_SPECTRUM_CONSTRUCTOR = _pymdlsdk._IFunction_definition_DS_COLOR_SPECTRUM_CONSTRUCTOR
    r""" The color from spectrum constructor."""
    DS_MATRIX_ELEM_CONSTRUCTOR = _pymdlsdk._IFunction_definition_DS_MATRIX_ELEM_CONSTRUCTOR
    r""" The matrix elemental constructor."""
    DS_MATRIX_DIAG_CONSTRUCTOR = _pymdlsdk._IFunction_definition_DS_MATRIX_DIAG_CONSTRUCTOR
    r""" The matrix diagonal constructor."""
    DS_INVALID_REF_CONSTRUCTOR = _pymdlsdk._IFunction_definition_DS_INVALID_REF_CONSTRUCTOR
    r""" The invalid reference constructor."""
    DS_DEFAULT_STRUCT_CONSTRUCTOR = _pymdlsdk._IFunction_definition_DS_DEFAULT_STRUCT_CONSTRUCTOR
    r""" The default constructor for a struct."""
    DS_TEXTURE_CONSTRUCTOR = _pymdlsdk._IFunction_definition_DS_TEXTURE_CONSTRUCTOR
    r""" The texture constructor."""
    DS_CONV_OPERATOR = _pymdlsdk._IFunction_definition_DS_CONV_OPERATOR
    r""" The type conversion operator."""
    DS_COPY_CONSTRUCTOR = _pymdlsdk._IFunction_definition_DS_COPY_CONSTRUCTOR
    r""" The copy constructor."""
    DS_BITWISE_COMPLEMENT = _pymdlsdk._IFunction_definition_DS_BITWISE_COMPLEMENT
    r""" The bitwise complement operator."""
    DS_UNARY_FIRST = _pymdlsdk._IFunction_definition_DS_UNARY_FIRST
    DS_OPERATOR_FIRST = _pymdlsdk._IFunction_definition_DS_OPERATOR_FIRST
    DS_LOGICAL_NOT = _pymdlsdk._IFunction_definition_DS_LOGICAL_NOT
    r""" The unary logical negation operator."""
    DS_POSITIVE = _pymdlsdk._IFunction_definition_DS_POSITIVE
    r""" The unary arithmetic positive operator."""
    DS_NEGATIVE = _pymdlsdk._IFunction_definition_DS_NEGATIVE
    r""" The unary arithmetic negation operator."""
    DS_PRE_INCREMENT = _pymdlsdk._IFunction_definition_DS_PRE_INCREMENT
    r""" The pre-increment operator."""
    DS_PRE_DECREMENT = _pymdlsdk._IFunction_definition_DS_PRE_DECREMENT
    r""" The pre-decrement operator."""
    DS_POST_INCREMENT = _pymdlsdk._IFunction_definition_DS_POST_INCREMENT
    r""" The post-increment operator."""
    DS_POST_DECREMENT = _pymdlsdk._IFunction_definition_DS_POST_DECREMENT
    r""" The post-decrement operator."""
    DS_CAST = _pymdlsdk._IFunction_definition_DS_CAST
    r"""  The cast operator. See 'mi_neuray_mdl_cast_operator'."""
    DS_UNARY_LAST = _pymdlsdk._IFunction_definition_DS_UNARY_LAST
    DS_SELECT = _pymdlsdk._IFunction_definition_DS_SELECT
    r""" The select operator."""
    DS_BINARY_FIRST = _pymdlsdk._IFunction_definition_DS_BINARY_FIRST
    DS_ARRAY_INDEX = _pymdlsdk._IFunction_definition_DS_ARRAY_INDEX
    r""" The array index operator. See 'mi_neuray_mdl_array_index_operator'."""
    DS_MULTIPLY = _pymdlsdk._IFunction_definition_DS_MULTIPLY
    r""" The multiplication operator."""
    DS_DIVIDE = _pymdlsdk._IFunction_definition_DS_DIVIDE
    r""" The division operator."""
    DS_MODULO = _pymdlsdk._IFunction_definition_DS_MODULO
    r""" The modulus operator."""
    DS_PLUS = _pymdlsdk._IFunction_definition_DS_PLUS
    r""" The addition operator."""
    DS_MINUS = _pymdlsdk._IFunction_definition_DS_MINUS
    r""" The subtraction operator."""
    DS_SHIFT_LEFT = _pymdlsdk._IFunction_definition_DS_SHIFT_LEFT
    r""" The shift-left operator."""
    DS_SHIFT_RIGHT = _pymdlsdk._IFunction_definition_DS_SHIFT_RIGHT
    r""" The arithmetic shift-right operator."""
    DS_UNSIGNED_SHIFT_RIGHT = _pymdlsdk._IFunction_definition_DS_UNSIGNED_SHIFT_RIGHT
    r""" The unsigned shift-right operator."""
    DS_LESS = _pymdlsdk._IFunction_definition_DS_LESS
    r""" The less operator."""
    DS_LESS_OR_EQUAL = _pymdlsdk._IFunction_definition_DS_LESS_OR_EQUAL
    r""" The less-or-equal operator."""
    DS_GREATER_OR_EQUAL = _pymdlsdk._IFunction_definition_DS_GREATER_OR_EQUAL
    r""" The greater-or-equal operator."""
    DS_GREATER = _pymdlsdk._IFunction_definition_DS_GREATER
    r""" The greater operator."""
    DS_EQUAL = _pymdlsdk._IFunction_definition_DS_EQUAL
    r""" The equal operator."""
    DS_NOT_EQUAL = _pymdlsdk._IFunction_definition_DS_NOT_EQUAL
    r""" The not-equal operator."""
    DS_BITWISE_AND = _pymdlsdk._IFunction_definition_DS_BITWISE_AND
    r""" The bitwise and operator."""
    DS_BITWISE_XOR = _pymdlsdk._IFunction_definition_DS_BITWISE_XOR
    r""" The bitwise xor operator."""
    DS_BITWISE_OR = _pymdlsdk._IFunction_definition_DS_BITWISE_OR
    r""" The bitwise or operator."""
    DS_LOGICAL_AND = _pymdlsdk._IFunction_definition_DS_LOGICAL_AND
    r""" The logical and operator."""
    DS_LOGICAL_OR = _pymdlsdk._IFunction_definition_DS_LOGICAL_OR
    r""" The logical or operator."""
    DS_ASSIGN = _pymdlsdk._IFunction_definition_DS_ASSIGN
    r""" The assign operator."""
    DS_MULTIPLY_ASSIGN = _pymdlsdk._IFunction_definition_DS_MULTIPLY_ASSIGN
    r""" The multiplication-assign operator."""
    DS_DIVIDE_ASSIGN = _pymdlsdk._IFunction_definition_DS_DIVIDE_ASSIGN
    r""" The division-assign operator."""
    DS_MODULO_ASSIGN = _pymdlsdk._IFunction_definition_DS_MODULO_ASSIGN
    r""" The modulus-assign operator."""
    DS_PLUS_ASSIGN = _pymdlsdk._IFunction_definition_DS_PLUS_ASSIGN
    r""" The plus-assign operator."""
    DS_MINUS_ASSIGN = _pymdlsdk._IFunction_definition_DS_MINUS_ASSIGN
    r""" The minus-assign operator."""
    DS_SHIFT_LEFT_ASSIGN = _pymdlsdk._IFunction_definition_DS_SHIFT_LEFT_ASSIGN
    r""" The shift-left-assign operator."""
    DS_SHIFT_RIGHT_ASSIGN = _pymdlsdk._IFunction_definition_DS_SHIFT_RIGHT_ASSIGN
    r""" The arithmetic shift-right-assign operator."""
    DS_UNSIGNED_SHIFT_RIGHT_ASSIGN = _pymdlsdk._IFunction_definition_DS_UNSIGNED_SHIFT_RIGHT_ASSIGN
    r""" The unsigned shift-right-assign operator."""
    DS_BITWISE_OR_ASSIGN = _pymdlsdk._IFunction_definition_DS_BITWISE_OR_ASSIGN
    r""" The bitwise or-assign operator."""
    DS_BITWISE_XOR_ASSIGN = _pymdlsdk._IFunction_definition_DS_BITWISE_XOR_ASSIGN
    r""" The bitwise xor-assign operator."""
    DS_BITWISE_AND_ASSIGN = _pymdlsdk._IFunction_definition_DS_BITWISE_AND_ASSIGN
    r""" The bitwise and-assign operator."""
    DS_SEQUENCE = _pymdlsdk._IFunction_definition_DS_SEQUENCE
    r""" The comma operator."""
    DS_BINARY_LAST = _pymdlsdk._IFunction_definition_DS_BINARY_LAST
    DS_TERNARY = _pymdlsdk._IFunction_definition_DS_TERNARY
    r""" The ternary operator (conditional). See 'mi_neuray_mdl_ternary_operator'."""
    DS_OPERATOR_LAST = _pymdlsdk._IFunction_definition_DS_OPERATOR_LAST
    DS_INTRINSIC_MATH_FIRST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_FIRST
    r""" The %math::abs() intrinsic function."""
    DS_INTRINSIC_MATH_ABS = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_ABS
    DS_INTRINSIC_MATH_ACOS = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_ACOS
    r""" The %math::acos() intrinsic function."""
    DS_INTRINSIC_MATH_ALL = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_ALL
    r""" The %math::all() intrinsic function."""
    DS_INTRINSIC_MATH_ANY = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_ANY
    r""" The %math::any() intrinsic function."""
    DS_INTRINSIC_MATH_ASIN = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_ASIN
    r""" The %math::asin() intrinsic function."""
    DS_INTRINSIC_MATH_ATAN = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_ATAN
    r""" The %math::atan() intrinsic function."""
    DS_INTRINSIC_MATH_ATAN2 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_ATAN2
    r""" The %math::atan2() intrinsic function."""
    DS_INTRINSIC_MATH_AVERAGE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_AVERAGE
    r""" The %math::average() intrinsic function."""
    DS_INTRINSIC_MATH_CEIL = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_CEIL
    r""" The %math::ceil() intrinsic function."""
    DS_INTRINSIC_MATH_CLAMP = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_CLAMP
    r""" The %math::clamp() intrinsic function."""
    DS_INTRINSIC_MATH_COS = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_COS
    r""" The %math::cos() intrinsic function."""
    DS_INTRINSIC_MATH_CROSS = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_CROSS
    r""" The %math::cross() intrinsic function."""
    DS_INTRINSIC_MATH_DEGREES = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_DEGREES
    r""" The %math::degrees() intrinsic function."""
    DS_INTRINSIC_MATH_DISTANCE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_DISTANCE
    r""" The %math::distance() intrinsic function."""
    DS_INTRINSIC_MATH_DOT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_DOT
    r""" The %math::dot() intrinsic function."""
    DS_INTRINSIC_MATH_EVAL_AT_WAVELENGTH = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_EVAL_AT_WAVELENGTH
    r""" The %math::eval_at_wavelength() intrinsic"""
    DS_INTRINSIC_MATH_EXP = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_EXP
    r"""  function. The %math::exp() intrinsic function."""
    DS_INTRINSIC_MATH_EXP2 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_EXP2
    r""" The %math::exp2() intrinsic function."""
    DS_INTRINSIC_MATH_FLOOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_FLOOR
    r""" The %math::floor() intrinsic function."""
    DS_INTRINSIC_MATH_FMOD = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_FMOD
    r""" The %math::fmod() intrinsic function."""
    DS_INTRINSIC_MATH_FRAC = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_FRAC
    r""" The %math::frac() intrinsic function."""
    DS_INTRINSIC_MATH_ISNAN = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_ISNAN
    r""" The %math::isnan() intrinsic function."""
    DS_INTRINSIC_MATH_ISFINITE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_ISFINITE
    r""" The %math::isfinite() intrinsic function."""
    DS_INTRINSIC_MATH_LENGTH = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_LENGTH
    r""" The %math::length() intrinsic function."""
    DS_INTRINSIC_MATH_LERP = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_LERP
    r""" The %math::lerp() intrinsic function."""
    DS_INTRINSIC_MATH_LOG = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_LOG
    r""" The %math::log() intrinsic function."""
    DS_INTRINSIC_MATH_LOG2 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_LOG2
    r""" The %math::log2() intrinsic function."""
    DS_INTRINSIC_MATH_LOG10 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_LOG10
    r""" The %math::log10() intrinsic function."""
    DS_INTRINSIC_MATH_LUMINANCE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_LUMINANCE
    r""" The %math::luminance() intrinsic function."""
    DS_INTRINSIC_MATH_MAX = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_MAX
    r""" The %math::max() intrinsic function."""
    DS_INTRINSIC_MATH_MAX_VALUE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_MAX_VALUE
    r""" The %math::max_value() intrinsic function."""
    DS_INTRINSIC_MATH_MAX_VALUE_WAVELENGTH = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_MAX_VALUE_WAVELENGTH
    r""" The %math::max_value_wavelength() intrinsic"""
    DS_INTRINSIC_MATH_MIN = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_MIN
    r"""  function. The %math::min() intrinsic function."""
    DS_INTRINSIC_MATH_MIN_VALUE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_MIN_VALUE
    r""" The %math::min_value() intrinsic function."""
    DS_INTRINSIC_MATH_MIN_VALUE_WAVELENGTH = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_MIN_VALUE_WAVELENGTH
    r""" The %math::min_value_wavelength() intrinsic"""
    DS_INTRINSIC_MATH_MODF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_MODF
    r"""  function. The %math::modf() intrinsic function."""
    DS_INTRINSIC_MATH_NORMALIZE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_NORMALIZE
    r""" The %math::normalize() intrinsic function."""
    DS_INTRINSIC_MATH_POW = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_POW
    r""" The %math::pow() intrinsic function."""
    DS_INTRINSIC_MATH_RADIANS = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_RADIANS
    r""" The %math::radians() intrinsic function."""
    DS_INTRINSIC_MATH_ROUND = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_ROUND
    r""" The %math::round() intrinsic function."""
    DS_INTRINSIC_MATH_RSQRT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_RSQRT
    r""" The %math::rsqrt() intrinsic function."""
    DS_INTRINSIC_MATH_SATURATE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_SATURATE
    r""" The %math::saturate() intrinsic function."""
    DS_INTRINSIC_MATH_SIGN = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_SIGN
    r""" The %math::sign() intrinsic function."""
    DS_INTRINSIC_MATH_SIN = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_SIN
    r""" The %math::sin() intrinsic function."""
    DS_INTRINSIC_MATH_SINCOS = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_SINCOS
    r""" The %math::sincos() intrinsic function."""
    DS_INTRINSIC_MATH_SMOOTHSTEP = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_SMOOTHSTEP
    r""" The %math::smoothstep() intrinsic function."""
    DS_INTRINSIC_MATH_SQRT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_SQRT
    r""" The %math::sqrt() intrinsic function."""
    DS_INTRINSIC_MATH_STEP = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_STEP
    r""" The %math::step() intrinsic function."""
    DS_INTRINSIC_MATH_TAN = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_TAN
    r""" The %math::tan() intrinsic function."""
    DS_INTRINSIC_MATH_TRANSPOSE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_TRANSPOSE
    r""" The %math::transpose() intrinsic function."""
    DS_INTRINSIC_MATH_BLACKBODY = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_BLACKBODY
    r""" The %math::blackbody() intrinsic function."""
    DS_INTRINSIC_MATH_EMISSION_COLOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_EMISSION_COLOR
    r""" The %math::emission_color() intrinsic"""
    DS_INTRINSIC_MATH_COSH = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_COSH
    r"""  function. The %math::cosh() intrinsic function."""
    DS_INTRINSIC_MATH_SINH = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_SINH
    r""" The %math::sinh() intrinsic function."""
    DS_INTRINSIC_MATH_TANH = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_TANH
    r""" The %math::tanh() intrinsic function."""
    DS_INTRINSIC_MATH_INT_BITS_TO_FLOAT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_INT_BITS_TO_FLOAT
    r""" The %math::int_bits_to_float() intrinsic"""
    DS_INTRINSIC_MATH_FLOAT_BITS_TO_INT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_FLOAT_BITS_TO_INT
    r"""  function. The %math::float_bits_to_int() intrinsic"""
    DS_INTRINSIC_MATH_DX = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_DX
    r"""  function. The %math::DX() intrinsic function."""
    DS_INTRINSIC_MATH_DY = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_DY
    r""" The %math::DY() intrinsic function."""
    DS_INTRINSIC_MATH_LAST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_LAST
    DS_INTRINSIC_STATE_POSITION = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_POSITION
    r"""  The %state::position() function."""
    DS_INTRINSIC_STATE_FIRST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_FIRST
    DS_INTRINSIC_STATE_NORMAL = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_NORMAL
    r""" The %state::normal() function."""
    DS_INTRINSIC_STATE_GEOMETRY_NORMAL = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_GEOMETRY_NORMAL
    r""" The %state::geometry_normal() function."""
    DS_INTRINSIC_STATE_MOTION = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_MOTION
    r""" The %state::motion() function."""
    DS_INTRINSIC_STATE_TEXTURE_SPACE_MAX = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_TEXTURE_SPACE_MAX
    r""" The %state::texture_space_max() function."""
    DS_INTRINSIC_STATE_TEXTURE_COORDINATE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_TEXTURE_COORDINATE
    r""" The %state::texture_coordinate() function."""
    DS_INTRINSIC_STATE_TEXTURE_TANGENT_U = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_TEXTURE_TANGENT_U
    r""" The %state::texture_tangent_u() function."""
    DS_INTRINSIC_STATE_TEXTURE_TANGENT_V = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_TEXTURE_TANGENT_V
    r""" The %state::texture_tangent_v() function."""
    DS_INTRINSIC_STATE_TANGENT_SPACE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_TANGENT_SPACE
    r""" The %state::tangent_space() function."""
    DS_INTRINSIC_STATE_GEOMETRY_TANGENT_U = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_GEOMETRY_TANGENT_U
    r""" The %state::geometry_tangent_u() function."""
    DS_INTRINSIC_STATE_GEOMETRY_TANGENT_V = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_GEOMETRY_TANGENT_V
    r""" The %state::geometry_tangent_v() function."""
    DS_INTRINSIC_STATE_DIRECTION = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_DIRECTION
    r""" The %state::direction() function."""
    DS_INTRINSIC_STATE_ANIMATION_TIME = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_ANIMATION_TIME
    r""" The %state::animation_time() function."""
    DS_INTRINSIC_STATE_WAVELENGTH_BASE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_WAVELENGTH_BASE
    r""" The %state::wavelength_base() function."""
    DS_INTRINSIC_STATE_TRANSFORM = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_TRANSFORM
    r""" The %state::transform() function."""
    DS_INTRINSIC_STATE_TRANSFORM_POINT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_TRANSFORM_POINT
    r""" The %state::transform_point() function."""
    DS_INTRINSIC_STATE_TRANSFORM_VECTOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_TRANSFORM_VECTOR
    r""" The %state::transform_vector() function."""
    DS_INTRINSIC_STATE_TRANSFORM_NORMAL = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_TRANSFORM_NORMAL
    r""" The %state::transform_normal() function."""
    DS_INTRINSIC_STATE_TRANSFORM_SCALE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_TRANSFORM_SCALE
    r""" The %state::transform_scale() function."""
    DS_INTRINSIC_STATE_ROUNDED_CORNER_NORMAL = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_ROUNDED_CORNER_NORMAL
    r""" The %state::rounded_corner_normal() function."""
    DS_INTRINSIC_STATE_METERS_PER_SCENE_UNIT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_METERS_PER_SCENE_UNIT
    r""" The %state::meters_per_scene_unit() function."""
    DS_INTRINSIC_STATE_SCENE_UNITS_PER_METER = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_SCENE_UNITS_PER_METER
    r""" The %state::scene_units_per_meter() function."""
    DS_INTRINSIC_STATE_OBJECT_ID = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_OBJECT_ID
    r""" The %state::object_id() function."""
    DS_INTRINSIC_STATE_WAVELENGTH_MIN = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_WAVELENGTH_MIN
    r""" The %state::wavelength_min() function."""
    DS_INTRINSIC_STATE_WAVELENGTH_MAX = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_WAVELENGTH_MAX
    r""" The %state::wavelength_max() function."""
    DS_INTRINSIC_STATE_LAST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_LAST
    DS_INTRINSIC_TEX_WIDTH = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_WIDTH
    r""" The tex::width() function."""
    DS_INTRINSIC_TEX_FIRST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_FIRST
    DS_INTRINSIC_TEX_HEIGHT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_HEIGHT
    r""" The tex::height() function."""
    DS_INTRINSIC_TEX_DEPTH = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_DEPTH
    r""" The tex::depth() function."""
    DS_INTRINSIC_TEX_LOOKUP_FLOAT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_LOOKUP_FLOAT
    r""" The tex::lookup_float() function."""
    DS_INTRINSIC_TEX_LOOKUP_FLOAT2 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_LOOKUP_FLOAT2
    r""" The tex::lookup_float2() function."""
    DS_INTRINSIC_TEX_LOOKUP_FLOAT3 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_LOOKUP_FLOAT3
    r""" The tex::lookup_float3() function."""
    DS_INTRINSIC_TEX_LOOKUP_FLOAT4 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_LOOKUP_FLOAT4
    r""" The tex::lookup_float4() function."""
    DS_INTRINSIC_TEX_LOOKUP_COLOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_LOOKUP_COLOR
    r""" The tex::lookup_color() function."""
    DS_INTRINSIC_TEX_TEXEL_FLOAT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_TEXEL_FLOAT
    r""" The tex::texel_float() function."""
    DS_INTRINSIC_TEX_TEXEL_FLOAT2 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_TEXEL_FLOAT2
    r""" The tex::texel_float2() function."""
    DS_INTRINSIC_TEX_TEXEL_FLOAT3 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_TEXEL_FLOAT3
    r""" The tex::texel_float3() function."""
    DS_INTRINSIC_TEX_TEXEL_FLOAT4 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_TEXEL_FLOAT4
    r""" The tex::texel_float4() function."""
    DS_INTRINSIC_TEX_TEXEL_COLOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_TEXEL_COLOR
    r""" The tex::texel_color() function."""
    DS_INTRINSIC_TEX_TEXTURE_ISVALID = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_TEXTURE_ISVALID
    r""" The tex::texture_isvalid() function."""
    DS_INTRINSIC_TEX_WIDTH_OFFSET = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_WIDTH_OFFSET
    r""" The tex::width_offset() function."""
    DS_INTRINSIC_TEX_HEIGHT_OFFSET = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_HEIGHT_OFFSET
    r""" The tex::height_offset() function."""
    DS_INTRINSIC_TEX_DEPTH_OFFSET = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_DEPTH_OFFSET
    r""" The tex::depth_offset() function."""
    DS_INTRINSIC_TEX_FIRST_FRAME = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_FIRST_FRAME
    r""" The tex::first_frame() function."""
    DS_INTRINSIC_TEX_LAST_FRAME = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_LAST_FRAME
    r""" The tex::last_frame() function."""
    DS_INTRINSIC_TEX_GRID_TO_OBJECT_SPACE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_GRID_TO_OBJECT_SPACE
    r""" The tex::grid_to_object_space() function."""
    DS_INTRINSIC_TEX_LAST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_LAST
    DS_INTRINSIC_DF_DIFFUSE_REFLECTION_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_DIFFUSE_REFLECTION_BSDF
    r""" The df::diffuse_reflection_bsdf() function."""
    DS_INTRINSIC_DF_FIRST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_FIRST
    DS_INTRINSIC_DF_DIFFUSE_TRANSMISSION_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_DIFFUSE_TRANSMISSION_BSDF
    r""" The df::diffuse_transmission_bsdf() function."""
    DS_INTRINSIC_DF_SPECULAR_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_SPECULAR_BSDF
    r""" The df::specular_bsdf() function."""
    DS_INTRINSIC_DF_SIMPLE_GLOSSY_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_SIMPLE_GLOSSY_BSDF
    r""" The df::simple_glossy_bsdf() function."""
    DS_INTRINSIC_DF_BACKSCATTERING_GLOSSY_REFLECTION_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_BACKSCATTERING_GLOSSY_REFLECTION_BSDF
    r""" The df::backscattering_glossy_reflection_bsdf() function."""
    DS_INTRINSIC_DF_MEASURED_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_MEASURED_BSDF
    r""" The df::measured_bsdf() function."""
    DS_INTRINSIC_DF_DIFFUSE_EDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_DIFFUSE_EDF
    r""" The df::diffuse_edf() function."""
    DS_INTRINSIC_DF_MEASURED_EDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_MEASURED_EDF
    r""" The df::measured_edf() function."""
    DS_INTRINSIC_DF_SPOT_EDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_SPOT_EDF
    r""" The df::spot_edf() function."""
    DS_INTRINSIC_DF_ANISOTROPIC_VDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_ANISOTROPIC_VDF
    r""" The df::anisotropic_vdf() function."""
    DS_INTRINSIC_DF_NORMALIZED_MIX = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_NORMALIZED_MIX
    r""" The df::normalized_mix() function."""
    DS_INTRINSIC_DF_CLAMPED_MIX = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_CLAMPED_MIX
    r""" The df::clamped_mix() function."""
    DS_INTRINSIC_DF_WEIGHTED_LAYER = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_WEIGHTED_LAYER
    r""" The df::weighted_layer() function."""
    DS_INTRINSIC_DF_FRESNEL_LAYER = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_FRESNEL_LAYER
    r""" The df::fresnel_layer() function."""
    DS_INTRINSIC_DF_CUSTOM_CURVE_LAYER = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_CUSTOM_CURVE_LAYER
    r""" The df::custom_curve_layer() function."""
    DS_INTRINSIC_DF_MEASURED_CURVE_LAYER = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_MEASURED_CURVE_LAYER
    r""" The df::measured_curve_layer() function."""
    DS_INTRINSIC_DF_THIN_FILM = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_THIN_FILM
    r""" The df::thin_film() function."""
    DS_INTRINSIC_DF_TINT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_TINT
    r""" The df::tint() function."""
    DS_INTRINSIC_DF_DIRECTIONAL_FACTOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_DIRECTIONAL_FACTOR
    r""" The df::directional_factor() function."""
    DS_INTRINSIC_DF_MEASURED_CURVE_FACTOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_MEASURED_CURVE_FACTOR
    r""" The df::measured_curve_factor() function."""
    DS_INTRINSIC_DF_LIGHT_PROFILE_POWER = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_LIGHT_PROFILE_POWER
    r""" The df::light_profile_power() function."""
    DS_INTRINSIC_DF_LIGHT_PROFILE_MAXIMUM = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_LIGHT_PROFILE_MAXIMUM
    r""" The df::light_profile_maximum() function."""
    DS_INTRINSIC_DF_LIGHT_PROFILE_ISVALID = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_LIGHT_PROFILE_ISVALID
    r""" The df::light_profile_isvalid() function."""
    DS_INTRINSIC_DF_BSDF_MEASUREMENT_ISVALID = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_BSDF_MEASUREMENT_ISVALID
    r""" The df::bsdf_measurement_is_valid() function."""
    DS_INTRINSIC_DF_MICROFACET_BECKMANN_SMITH_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_MICROFACET_BECKMANN_SMITH_BSDF
    r""" The df::microfacet_beckmann_smith_bsdf() function."""
    DS_INTRINSIC_DF_MICROFACET_GGX_SMITH_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_MICROFACET_GGX_SMITH_BSDF
    r""" The df::microfacet_ggx_smith_bsdf() function."""
    DS_INTRINSIC_DF_MICROFACET_BECKMANN_VCAVITIES_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_MICROFACET_BECKMANN_VCAVITIES_BSDF
    r""" The df::microfacet_beckmann_vcavities() function."""
    DS_INTRINSIC_DF_MICROFACET_GGX_VCAVITIES_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_MICROFACET_GGX_VCAVITIES_BSDF
    r""" The df::microfacet_ggx_vcavities() function."""
    DS_INTRINSIC_DF_WARD_GEISLER_MORODER_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_WARD_GEISLER_MORODER_BSDF
    r""" The df::ward_geisler_moroder_bsdf() function."""
    DS_INTRINSIC_DF_COLOR_NORMALIZED_MIX = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_COLOR_NORMALIZED_MIX
    r""" The df::color_normalized_mix() function."""
    DS_INTRINSIC_DF_COLOR_CLAMPED_MIX = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_COLOR_CLAMPED_MIX
    r""" The df::color_clamped_mix() function."""
    DS_INTRINSIC_DF_COLOR_WEIGHTED_LAYER = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_COLOR_WEIGHTED_LAYER
    r""" The df::color_weighted_layer() function."""
    DS_INTRINSIC_DF_COLOR_FRESNEL_LAYER = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_COLOR_FRESNEL_LAYER
    r""" The df::color_fresnel_layer() function."""
    DS_INTRINSIC_DF_COLOR_CUSTOM_CURVE_LAYER = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_COLOR_CUSTOM_CURVE_LAYER
    r""" The df::color_custom_curve_layer() function."""
    DS_INTRINSIC_DF_COLOR_MEASURED_CURVE_LAYER = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_COLOR_MEASURED_CURVE_LAYER
    r""" The df::color_measured_curve_layer() function."""
    DS_INTRINSIC_DF_FRESNEL_FACTOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_FRESNEL_FACTOR
    r""" The df::fresnel_factor() function."""
    DS_INTRINSIC_DF_MEASURED_FACTOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_MEASURED_FACTOR
    r""" The df::measured_factor() function."""
    DS_INTRINSIC_DF_CHIANG_HAIR_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_CHIANG_HAIR_BSDF
    r""" The df::chiang_hair_bsdf() function."""
    DS_INTRINSIC_DF_SHEEN_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_SHEEN_BSDF
    r""" The df::sheen_bsdf() function."""
    DS_INTRINSIC_DF_UNBOUNDED_MIX = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_UNBOUNDED_MIX
    r""" The df::unbounded_mix() function."""
    DS_INTRINSIC_DF_COLOR_UNBOUNDED_MIX = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_COLOR_UNBOUNDED_MIX
    r""" The df::color_unbounded() function."""
    DS_INTRINSIC_DF_LAST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_LAST
    DS_INTRINSIC_NVIDIA_DF_ASHIKHMIN_SHIRLEY_GLOSSY_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_NVIDIA_DF_ASHIKHMIN_SHIRLEY_GLOSSY_BSDF
    r""" The nvidia::df::ashikhmin_shirley_glossy_bsdf() function."""
    DS_INTRINSIC_NVIDIA_DF_FIRST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_NVIDIA_DF_FIRST
    DS_INTRINSIC_NVIDIA_DF_WARD_GM_GLOSSY_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_NVIDIA_DF_WARD_GM_GLOSSY_BSDF
    r""" The nvidia::df::ward_gm_glossy_bsdf() function."""
    DS_INTRINSIC_NVIDIA_DF_MICROFACET_BECKMANN_SMITH_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_NVIDIA_DF_MICROFACET_BECKMANN_SMITH_BSDF
    r""" The nvidia::df::microfacet_beckmann_smith_bsdf() function."""
    DS_INTRINSIC_NVIDIA_DF_MICROFACET_GGX_SMITH_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_NVIDIA_DF_MICROFACET_GGX_SMITH_BSDF
    r""" The nvidia::df::microfacet_ggx_smith_bsdf() function."""
    DS_INTRINSIC_NVIDIA_DF_MICROFACET_BECKMANN_VC_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_NVIDIA_DF_MICROFACET_BECKMANN_VC_BSDF
    r""" The nvidia::df::microfacet_beckmann_vc_bsdf() function."""
    DS_INTRINSIC_NVIDIA_DF_MICROFACET_GGX_VC_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_NVIDIA_DF_MICROFACET_GGX_VC_BSDF
    r""" The nvidia::df::microfacet_ggx_vc_bsdf() function."""
    DS_INTRINSIC_NVIDIA_DF_MICROFACET_PHONG_VC_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_NVIDIA_DF_MICROFACET_PHONG_VC_BSDF
    r""" The nvidia::df::microfacet_phong_vc_bsdf() function."""
    DS_INTRINSIC_NVIDIA_DF_SIMPLE_GLOSSY_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_NVIDIA_DF_SIMPLE_GLOSSY_BSDF
    r""" The nvidia::df::simple_glossy_bsdf() function."""
    DS_INTRINSIC_NVIDIA_DF_SIMPLE_GLOSSY_BSDF_LEGACY = _pymdlsdk._IFunction_definition_DS_INTRINSIC_NVIDIA_DF_SIMPLE_GLOSSY_BSDF_LEGACY
    r""" The nvidia::df::simple_glossy_bsdf_legacy() function."""
    DS_INTRINSIC_NVIDIA_DF_LEGACY_MCP_GLOSSY_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_NVIDIA_DF_LEGACY_MCP_GLOSSY_BSDF
    r""" The nvidia::df::legacy_mcp_glossy_bsdf() function."""
    DS_INTRINSIC_NVIDIA_DF_MICROFACET_SIN_K_VC_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_NVIDIA_DF_MICROFACET_SIN_K_VC_BSDF
    r""" The nvidia::df::microfacet_sin_k_vcavities_bsdf() function."""
    DS_INTRINSIC_NVIDIA_DF_MICROFACET_MS_TEST_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_NVIDIA_DF_MICROFACET_MS_TEST_BSDF
    r""" The nvidia::df::microfacet_multiscatter_test_bsdf() function."""
    DS_INTRINSIC_NVIDIA_DF_THIN_FILM = _pymdlsdk._IFunction_definition_DS_INTRINSIC_NVIDIA_DF_THIN_FILM
    r""" The nvidia::df::thin_film() function."""
    DS_INTRINSIC_NVIDIA_DF_THIN_FILM_LAYER = _pymdlsdk._IFunction_definition_DS_INTRINSIC_NVIDIA_DF_THIN_FILM_LAYER
    r""" The nvidia::df::thin_film_layer() function."""
    DS_INTRINSIC_NVIDIA_DF_LAST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_NVIDIA_DF_LAST
    DS_INTRINSIC_SCENE_DATA_ISVALID = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_ISVALID
    r""" The scene::data_is_valid() function."""
    DS_INTRINSIC_SCENE_FIRST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_FIRST
    DS_INTRINSIC_SCENE_DATA_LOOKUP_INT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_INT
    r""" The scene::data_lookup_int() function."""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_INT2 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_INT2
    r""" The scene::data_lookup_int2() function."""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_INT3 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_INT3
    r""" The scene::data_lookup_int3() function."""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_INT4 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_INT4
    r""" The scene::data_lookup_int4() function."""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_FLOAT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_FLOAT
    r""" The scene::data_lookup_float() function."""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_FLOAT2 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_FLOAT2
    r""" The scene::data_lookup_float2() function."""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_FLOAT3 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_FLOAT3
    r""" The scene::data_lookup_float3() function."""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_FLOAT4 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_FLOAT4
    r""" The scene::data_lookup_float4() function."""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_COLOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_COLOR
    r""" The scene::data_lookup_color() function."""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_INT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_INT
    r""" The scene::data_lookup_uniform_int() function."""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_INT2 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_INT2
    r""" The scene::data_lookup_uniform_int2() function."""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_INT3 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_INT3
    r""" The scene::data_lookup_uniform_int3() function."""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_INT4 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_INT4
    r""" The scene::data_lookup_uniform_int4() function."""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_FLOAT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_FLOAT
    r""" The scene::data_lookup_uniform_float() function."""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_FLOAT2 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_FLOAT2
    r""" The scene::data_lookup_uniform_float2() function."""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_FLOAT3 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_FLOAT3
    r""" The scene::data_lookup_uniform_float3() function."""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_FLOAT4 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_FLOAT4
    r""" The scene::data_lookup_uniform_float4() function."""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_COLOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_COLOR
    r""" The scene::data_lookup_uniform_color() function."""
    DS_INTRINSIC_SCENE_LAST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_LAST
    DS_INTRINSIC_DEBUG_BREAKPOINT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DEBUG_BREAKPOINT
    r""" The debug::breakpoint() function."""
    DS_INTRINSIC_DEBUG_FIRST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DEBUG_FIRST
    DS_INTRINSIC_DEBUG_ASSERT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DEBUG_ASSERT
    r""" The debug::assert() function."""
    DS_INTRINSIC_DEBUG_PRINT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DEBUG_PRINT
    r""" The debug::print() function."""
    DS_INTRINSIC_DEBUG_LAST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DEBUG_LAST
    DS_INTRINSIC_DAG_FIELD_ACCESS = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DAG_FIELD_ACCESS
    r""" The structure field access function."""
    DS_INTRINSIC_DAG_FIRST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DAG_FIRST
    DS_INTRINSIC_DAG_ARRAY_CONSTRUCTOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DAG_ARRAY_CONSTRUCTOR
    r""" The array constructor. See 'mi_neuray_mdl_array_constructor'."""
    DS_INTRINSIC_DAG_ARRAY_LENGTH = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DAG_ARRAY_LENGTH
    r""" The array length operator. See 'mi_neuray_mdl_array_length_operator'."""
    DS_INTRINSIC_DAG_LAST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DAG_LAST
    DS_FORCE_32_BIT = _pymdlsdk._IFunction_definition_DS_FORCE_32_BIT

    def get_module(self):
        r"""
        Returns the DB name of the module containing this function definition.

        The type of the module is #mi::neuraylib::IModule.
        """
        return _pymdlsdk._IFunction_definition_get_module(self)

    def get_mdl_name(self):
        r"""
        Returns the MDL name of the function definition.

        Notes: The MDL name of the function definition is different from the name of the DB element.
              Use #mi::neuraylib::ITransaction::name_of() to obtain the name of the DB element.

        :rtype: string
        :return: The MDL name of the function definition.
        """
        return _pymdlsdk._IFunction_definition_get_mdl_name(self)

    def get_mdl_module_name(self):
        r""" Returns the MDL name of the module containing this function definition."""
        return _pymdlsdk._IFunction_definition_get_mdl_module_name(self)

    def get_mdl_simple_name(self):
        r"""
        Returns the simple MDL name of the function definition.

        The simple name is the last component of the MDL name, i.e., without any packages and
        scope qualifiers, and without the parameter type names.

        :rtype: string
        :return: The simple MDL name of the function definition.
        """
        return _pymdlsdk._IFunction_definition_get_mdl_simple_name(self)

    def get_mdl_parameter_type_name(self, index):
        r"""
        Returns the type name of the parameter at ``index``.

        Notes: The type names provided here are substrings of the MDL name returned by
              #get_mdl_name(). They are provided here such that parsing of the MDL name is not
              necessary. Their main use case is one variant of overload resolution if no actual
              arguments are given (see
              #mi::neuraylib::IModule::get_function_overloads(const char*,const IArray*)const. For
              almost all other use cases it is strongly recommended to use #get_parameter_types()
              instead.

        :type index: int
        :param index:    The index of the parameter.
        :rtype: string
        :return: The type name of the parameter, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk._IFunction_definition_get_mdl_parameter_type_name(self, index)

    def get_prototype(self):
        r"""
        Returns the DB name of the prototype, or ``NULL`` if this function definition is not a
        variant.
        """
        return _pymdlsdk._IFunction_definition_get_prototype(self)

    def get_mdl_version(self, since, removed):
        r"""
        Returns the MDL version when this function definition was added and removed.

        :type since: int, out
        :param since:     The MDL version in which this function definition was added. If the
                                  function definition does not belong to the standard library, the
                                  MDL version of the corresponding module is returned.
        :type removed: int, out
        :param removed:   The MDL version in which this function definition was removed, or
                                  mi::neuraylib::MDL_VERSION_INVALID if the function has not been
                                  removed so far or does not belong to the standard library.
        """
        return _pymdlsdk._IFunction_definition_get_mdl_version(self, since, removed)

    def get_semantic(self):
        r""" Returns the semantic of this function definition."""
        return _pymdlsdk._IFunction_definition_get_semantic(self)

    def is_array_constructor(self):
        r"""
        Indicates whether this definition represents the array constructor.

        See also: 'mi_neuray_mdl_arrays'
        """
        return _pymdlsdk._IFunction_definition_is_array_constructor(self)

    def is_exported(self):
        r""" Indicates whether the function definition is exported by its module."""
        return _pymdlsdk._IFunction_definition_is_exported(self)

    def is_uniform(self):
        r"""
        Indicates whether the function definition is uniform.

        Notes: This includes, in addition to functions definitions that are explicitly marked as
              uniform, also function definitions that are not explicitly marked either uniform or
              varying and that have been analyzed by the MDL compiler to be uniform.
        """
        return _pymdlsdk._IFunction_definition_is_uniform(self)

    def is_material(self):
        r"""
        Indicates whether the definition represents a material.

        If 'mi_mdl_materials_are_functions' is disabled, then this method returns always
        ``false``.
        """
        return _pymdlsdk._IFunction_definition_is_material(self)

    def get_return_type(self):
        r"""
        Returns the return type.

        :rtype: :py:class:`IType`
        :return: The return type.
        """
        return _pymdlsdk._IFunction_definition_get_return_type(self)

    def get_parameter_count(self):
        r""" Returns the number of parameters."""
        return _pymdlsdk._IFunction_definition_get_parameter_count(self)

    def get_parameter_name(self, index):
        r"""
        Returns the name of the parameter at ``index``.

        :type index: int
        :param index:    The index of the parameter.
        :rtype: string
        :return: The name of the parameter, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk._IFunction_definition_get_parameter_name(self, index)

    def get_parameter_index(self, name):
        r"""
        Returns the index position of a parameter.

        :type name: string
        :param name:     The name of the parameter.
        :rtype: int
        :return: The index of the parameter, or -1 if ``name`` is invalid.
        """
        return _pymdlsdk._IFunction_definition_get_parameter_index(self, name)

    def get_parameter_types(self):
        r""" Returns the types of all parameters."""
        return _pymdlsdk._IFunction_definition_get_parameter_types(self)

    def get_defaults(self):
        r"""
        Returns the defaults of all parameters.

        Notes: Not all parameters have defaults. Hence, the indices in the returned expression list
              do not necessarily coincide with the parameter indices of this definition. Therefore,
              defaults should be retrieved via the name of the parameter instead of its index.
        """
        return _pymdlsdk._IFunction_definition_get_defaults(self)

    def get_enable_if_conditions(self):
        r"""
        Returns the ``enable_if`` conditions of all parameters.

        Notes: Not all parameters have a condition. Hence, the indices in the returned expression
              list do not necessarily coincide with the parameter indices of this definition.
              Therefore, conditions should be retrieved via the name of the parameter instead of
              its index.
        """
        return _pymdlsdk._IFunction_definition_get_enable_if_conditions(self)

    def get_enable_if_users(self, index):
        r"""
        Returns the number of other parameters whose ``enable_if`` condition might depend on the
        argument of the given parameter.

        :type index: int
        :param index:    The index of the parameter.
        :rtype: int
        :return: The number of other parameters whose ``enable_if`` condition depends on this
                            parameter argument.
        """
        return _pymdlsdk._IFunction_definition_get_enable_if_users(self, index)

    def get_enable_if_user(self, index, u_index):
        r"""
        Returns the index of a parameter whose ``enable_if`` condition might depend on the
        argument of the given parameter.

        :type index: int
        :param index:    The index of the parameter.
        :type u_index: int
        :param u_index:  The index of the enable_if user.
        :rtype: int
        :return: The index of a parameter whose ``enable_if`` condition depends on this
                            parameter argument, or ~0 if indexes are out of range.
        """
        return _pymdlsdk._IFunction_definition_get_enable_if_user(self, index, u_index)

    def get_annotations(self):
        r"""
        Returns the annotations of the function definition itself, or ``NULL`` if there are no such
        annotations.
        """
        return _pymdlsdk._IFunction_definition_get_annotations(self)

    def get_return_annotations(self):
        r"""
        Returns the annotations of the return type of this function definition, or ``NULL`` if there
        are no such annotations.
        """
        return _pymdlsdk._IFunction_definition_get_return_annotations(self)

    def get_parameter_annotations(self):
        r"""
        Returns the annotations of all parameters.

        Notes: Not all parameters have annotations. Hence, the indices in the returned annotation
              list do not necessarily coincide with the parameter indices of this definition.
              Therefore, annotation blocks should be retrieved via the name of the parameter
              instead of its index.
        """
        return _pymdlsdk._IFunction_definition_get_parameter_annotations(self)

    def get_thumbnail(self):
        r"""
        Returns the resolved file name of the thumbnail image for this function definition.

        The function first checks for a thumbnail annotation. If the annotation is provided,
        it uses the 'name' argument of the annotation and resolves that in the MDL search path.
        If the annotation is not provided or file resolution fails, it checks for a file
        module_name.material_name.png next to the MDL module.
        In case this cannot be found either ``NULL`` is returned.
        """
        return _pymdlsdk._IFunction_definition_get_thumbnail(self)

    def is_valid(self, context):
        r"""
        Returns ``true`` if the definition is valid, ``false`` otherwise.

        A definition can become invalid if the module it has been defined in
        or another module imported by that module has been reloaded. In the first case,
        the definition can no longer be used. In the second case, the
        definition can be validated by reloading the module it has been
        defined in.
        :type context: :py:class:`IMdl_execution_context`
        :param context:  Execution context that can be queried for error messages
                            after the operation has finished. Can be ``NULL``.
        :rtype: boolean
        :return: - ``true``   The definition is valid.
                        - ``false``  The definition is invalid.
        """
        return _pymdlsdk._IFunction_definition_is_valid(self, context)

    def get_body(self):
        r"""
        Returns the direct call expression that represents the body of the function (if possible).

        Notes: Functions bodies with control flow can not be represented by an expression. For such
              functions, this method always returns ``NULL``. For all other functions, i.e., for
              functions, whose body is an expression or a plain return statement, the method never
              returns ``NULL`` (unless there is no body at all, see below).

        Functions with a known semantic, i.e., different from
              #mi::neuraylib::IFunction_definition::DS_UNKNOWN, do not have a body as such, and the
              method returns ``NULL`` for such functions.
        """
        return _pymdlsdk._IFunction_definition_get_body(self)

    def get_temporary_count(self):
        r""" Returns the number of temporaries used by this function."""
        return _pymdlsdk._IFunction_definition_get_temporary_count(self)

    def get_temporary(self, index):
        r"""
        Returns the expression of a temporary.

        :type index: int
        :param index:            The index of the temporary.
        :rtype: :py:class:`IExpression`
        :return: The expression of the temporary, or ``NULL`` if ``index`` is out of
                                    range.
        """
        return _pymdlsdk._IFunction_definition_get_temporary(self, index)

    def get_temporary_name(self, index):
        r"""
        Returns the name of a temporary.

        Notes: Names of temporaries are not necessarily unique, e.g., due to inlining. Names are for
              informational purposes and should not be used to identify a particular temporary.

        See also: #mi::neuraylib::IMdl_configuration::set_expose_names_of_let_expressions()

        :type index: int
        :param index:            The index of the temporary.
        :rtype: string
        :return: The name of the temporary, or ``NULL`` if the temporary has no name
                                    or ``index`` is out of range.
        """
        return _pymdlsdk._IFunction_definition_get_temporary_name(self, index)

    def create_function_call_with_ret(self, arguments):
        r"""
        Creates a new function call.

        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments of the created function call.

                                Arguments for parameters without default are mandatory, otherwise
                                optional. The type of an argument must match the corresponding parameter
                                type. Any argument missing in ``arguments`` will be set to the default of
                                the corresponding parameter.

                                Note that the expressions in ``arguments`` are copied. This copy
                                operation is a deep copy, e.g., DB elements referenced in call
                                expressions are also copied.

                                ``NULL`` is a valid argument which is handled like an empty expression
                                list.
        :type errors: int, out, optional
        :param errors:  An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                -  0: Success.
                                - -1: An argument for a non-existing parameter was provided in
                                      ``arguments``.
                                - -2: The type of an argument in ``arguments`` does not have the correct
                                      type, see #get_parameter_types().
                                - -3: A parameter that has no default was not provided with an argument
                                      value.
                                - -4: The definition can not be instantiated because it is not exported.
                                - -5: A parameter type is uniform, but the corresponding argument has a
                                      varying return type.
                                - -6: An argument expression is not a constant nor a call.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument or default is a call expression and the return type of
                                      the called function definition is effectively varying since the
                                      function definition itself is varying.
                                - -9: The function definition is invalid due to a module reload, see
                                      #is_valid() for diagnostics.
        :rtype: :py:class:`IFunction_call`
        :return: The created function call, or ``NULL`` in case of errors.
        """
        return _pymdlsdk._IFunction_definition_create_function_call_with_ret(self, arguments)

    def create_function_call(self, arguments):
        r"""
        Creates a new function call.

        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments of the created function call.

                                Arguments for parameters without default are mandatory, otherwise
                                optional. The type of an argument must match the corresponding parameter
                                type. Any argument missing in ``arguments`` will be set to the default of
                                the corresponding parameter.

                                Note that the expressions in ``arguments`` are copied. This copy
                                operation is a deep copy, e.g., DB elements referenced in call
                                expressions are also copied.

                                ``NULL`` is a valid argument which is handled like an empty expression
                                list.
        :param errors:  An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                -  0: Success.
                                - -1: An argument for a non-existing parameter was provided in
                                      ``arguments``.
                                - -2: The type of an argument in ``arguments`` does not have the correct
                                      type, see #get_parameter_types().
                                - -3: A parameter that has no default was not provided with an argument
                                      value.
                                - -4: The definition can not be instantiated because it is not exported.
                                - -5: A parameter type is uniform, but the corresponding argument has a
                                      varying return type.
                                - -6: An argument expression is not a constant nor a call.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument or default is a call expression and the return type of
                                      the called function definition is effectively varying since the
                                      function definition itself is varying.
                                - -9: The function definition is invalid due to a module reload, see
                                      #is_valid() for diagnostics.
        :rtype: :py:class:`IFunction_call`
        :return: The created function call, or ``NULL`` in case of errors.
        """
        return _pymdlsdk._IFunction_definition_create_function_call(self, arguments)

# Register _IFunction_definition in _pymdlsdk:
_pymdlsdk._IFunction_definition_swigregister(_IFunction_definition)

class Interface_declare_IImage(_IScene_element):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IImage_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IImage

# Register Interface_declare_IImage in _pymdlsdk:
_pymdlsdk.Interface_declare_IImage_swigregister(Interface_declare_IImage)

def Interface_declare_IImage_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IImage_compare_iid(iid)

class _IImage(Interface_declare_IImage):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def reset_file(self, filename, selector=None):
        r"""
        Sets the image to a file identified by ``filename``.

        Note that support for a given image format requires an image plugin capable of handling
        that format.

        The filename can include one of the following three uv-tileset markers in the filename:
        <UDIM>, <UVTILE0>, or <UVTILE1>. The image refers then to a
        whole uv-tileset, a set of images used together as a single large two-dimensional image.
        The different markers indicate the different filename conventions that encode where each
        image file is placed in the uv texture space.



          |Marker
          |Pattern
          |(0,0) index
          |Convention to format a (u, v)-index
        |
        -

          |<UDIM>
          |DDDD
          |1001
          |UDIM, expands to the four digit number 1000+(u+1+v10)
        |

          |<UVTILE0>
          |"_u"I"_v"I
          |_u0_v0
          |0-based uv-tileset, expands to "_u"u"_v"v"</td>
        </tr>
        <tr>
          <td>&lt;UVTILE1&gt;</td>
          <td>"_u"I"_v"I</td>
          <td>_u1_v1</td>
          <td>1-based uv-tileset, expands to "_u"(u+1)"_v"(v+1)"
        |


        The filename can also include a sequence marker for the frame number of animated textures:
        <#...> (with a non-zero count of ``'#'`` characters). The marker matches any
        non-negative integral number of at most as many digits as there are ``'#'`` characters in the
        sequence marker. The number may have leading zeros, which are ignored for its numerical
        interpretation. Multiple occurrences of the same number is undefined behavior (can happen
        in case of leading zeros).

        Images without sequences marker are treated as a single frame with frame number 0. Images
        without uv-tileset marker are treated as a single uv-tile (per frame) with u- and
        v-coordinates of 0.

        :type filename: string
        :param filename:       The filename of the image to load.
        :type selector: string, optional
        :param selector:       The selector, or ``NULL``. See section 2.3.1 in ['MDLLS]' for
                                  details.
        :rtype: int
        :return: 
                                  -  0: Success.
                                  - -1: Invalid parameters (``NULL`` pointer).
                                  - -2: Failure to resolve the given filename, e.g., the file does not
                                        exist.
                                  - -3: Failure to open the file.
                                  - -4: No image plugin found to handle the file.
                                  - -5: The image plugin failed to import the file.

        See also: #mi::neuraylib::IMdl_factory::create_texture() for a way to create a texture based
             on an MDL file path instead of a filename.
        """
        return _pymdlsdk._IImage_reset_file(self, filename, selector)

    def reset_reader(self, *args):
        r"""
        *Overload 1:*
        Sets the image to the data provided by a reader.

        :type reader: mi::neuraylib::IReader
        :param reader:         The reader that provides the data for the image. The reader needs to
                                  support absolute access.
        :type image_format: string
        :param image_format:   The image format of the data, e.g., ``"jpg"``. Note that support for a
                                  given image format requires an image plugin capable of handling that
                                  format.
        :type selector: string, optional
        :param selector:       The selector, or ``NULL``. See section 2.3.1 in ['MDLLS]' for
                                  details.
        :rtype: int
        :return: 
                                  -  0: Success.
                                  - -1: Invalid parameters (``NULL`` pointer).
                                  - -3: The reader does not support absolute access.
                                  - -4: No image plugin found to handle the data.
                                  - -5: The image plugin failed to import the data.

        |

        *Overload 2:*
        Sets the image to the frame/uv-tile data provided by an array of readers.

        :type reader: :py:class:`IArray`
        :param reader:         A static or dynamic array of structures of type ``Uvtile_reader``. Such
                                  a structure has the following members:
                                  - #mi::Sint32 **u**

                                    The u-coordinate of this uv-tile.
                                  - #mi::Sint32 **v**

                                    The v-coordinate of this uv-tile.
                                  - #mi::Size **frame**

                                    The frame number of this uv-tile.
                                  - #mi::neuraylib::IReader* **reader**

                                    The reader that provides the data for this uv-tile. The reader needs
                                    to support absolute access.
        :type image_format: string
        :param image_format:   The image format of the data, e.g., ``"jpg"``. Note that support for a
                                  given image format requires an image plugin capable of handling that
                                  format.
        :type selector: string, optional
        :param selector:       The selector, or ``NULL``. See section 2.3.1 in ['MDLLS]' for
                                  details.
        :rtype: int
        :return: 
                                  -  0: Success.
                                  - -1: Invalid parameters (``NULL`` pointer).
                                  - -3: Failure to obtain canvases from the readers (possible reasons
                                        are the reader does not support absolute access, no image plugin
                                        found to handle the data, the image plugin failed to import the
                                        data, and repeated u/v coordinates (per frame)).

        |

        *Overload 3:*
        Sets the image to the frame/uv-tile data provided by an array of readers.

        :type reader: :py:class:`IArray`
        :param reader:         A static or dynamic array of structures of type ``Uvtile_reader``. Such
                                  a structure has the following members:
                                  - #mi::Sint32 **u**

                                    The u-coordinate of this uv-tile.
                                  - #mi::Sint32 **v**

                                    The v-coordinate of this uv-tile.
                                  - #mi::Size **frame**

                                    The frame number of this uv-tile.
                                  - #mi::neuraylib::IReader* **reader**

                                    The reader that provides the data for this uv-tile. The reader needs
                                    to support absolute access.
        :type image_format: string
        :param image_format:   The image format of the data, e.g., ``"jpg"``. Note that support for a
                                  given image format requires an image plugin capable of handling that
                                  format.
        :param selector:       The selector, or ``NULL``. See section 2.3.1 in ['MDLLS]' for
                                  details.
        :rtype: int
        :return: 
                                  -  0: Success.
                                  - -1: Invalid parameters (``NULL`` pointer).
                                  - -3: Failure to obtain canvases from the readers (possible reasons
                                        are the reader does not support absolute access, no image plugin
                                        found to handle the data, the image plugin failed to import the
                                        data, and repeated u/v coordinates (per frame)).
        """
        return _pymdlsdk._IImage_reset_reader(self, *args)

    def set_from_canvas(self, *args):
        r"""
        *Overload 1:*
        Sets the image to the passed canvas (possibly sharing the pixel data).

        :type canvas: :py:class:`ICanvas`
        :param canvas:   The pixel data to be used by this image.
        :type shared: boolean, optional
        :param shared:   If ``false`` (the default), the pixel data is copied from ``canvas`` and the
                            method does the same as
                            #mi::neuraylib::IImage::set_from_canvas(const mi::neuraylib::ICanvas*).
                            If set to ``true``, the image uses the canvas directly (doing reference
                            counting on the canvas pointer). You must not modify the canvas content
                            after this call.
        :rtype: boolean
        :return: ``true`` if the pixel data of this image has been set correctly, and
                            ``false`` otherwise.

        |

        *Overload 2:*
        Sets the frames/uv-tiles of this image based to the passed canvases (possibly sharing the
        pixel data).

        :type uvtiles: :py:class:`IArray`
        :param uvtiles:  A static or dynamic array of structures of type ``Uvtile``. Such a structure
                            has the following members:
                            - #mi::Sint32 **u**

                              The u-coordinate of this uv-tile.
                            - #mi::Sint32 **v**

                              The v-coordinate of this uv-tile.
                            - #mi::Size **frame**

                              The frame number of this uv-tile.
                            - #mi::neuraylib::ICanvas* **canvas**

                              The pixel data to be used for this image.
        :type shared: boolean, optional
        :param shared:   If ``false`` (the default), the pixel data is copied from ``canvas`` and the
                            method does the same as
                            #mi::neuraylib::IImage::set_from_canvas(const mi::neuraylib::ICanvas*).
                            If set to ``true``, the image uses the canvases directly (doing reference
                            counting on the canvas pointers). You must not modify the canvas contents
                            after this call.
        :rtype: boolean
        :return: ``true`` if the pixel data of this image has been set correctly, and
                            ``false`` otherwise.
        """
        return _pymdlsdk._IImage_set_from_canvas(self, *args)

    def is_animated(self):
        r"""
        Indicates whether this image represents an animated texture.

        The return value ``false`` implies that there is a single frame with frame number 0.
        """
        return _pymdlsdk._IImage_is_animated(self)

    def get_length(self):
        r""" Returns the number of frames of this image. Never zero."""
        return _pymdlsdk._IImage_get_length(self)

    def get_frame_number(self, frame_id):
        r"""
        Returns the frame number for a give frame ID.

        This function is strictly monotonically increasing. Frame numbers are not necessarily
        consecutive, there can be missing frame numbers.

        :type frame_id: int
        :param frame_id:    The frame ID of the frame.
        :rtype: int
        :return: The frame number, or -1 if ``frame_id`` is out of bounds.
        """
        return _pymdlsdk._IImage_get_frame_number(self, frame_id)

    def get_frame_id(self, frame_number):
        r"""
        Returns the frame ID for a given frame number.

        :type frame_number: int
        :param frame_number:   The frame number of the frame.
        :rtype: int
        :return: The frame ID, or -1 if ``frame_number`` is not a valid frame number.
        """
        return _pymdlsdk._IImage_get_frame_id(self, frame_number)

    def is_uvtile(self):
        r"""
        Indicates whether this image represents a uvtile sequence.

        The return value ``false`` implies that there is a single uv-tile (per frame) with u- and v-
        coordinates of 0.
        """
        return _pymdlsdk._IImage_is_uvtile(self)

    def get_frame_length(self, frame_id):
        r""" Returns the number of uv-tiles for a given frame (or 0 if ``frame_id`` is out of bounds)."""
        return _pymdlsdk._IImage_get_frame_length(self, frame_id)

    def get_uvtile_uv(self, frame_id, uvtile_id, u, v):
        r"""
        Returns the u- and v- coordinates corresponding to a uv-tile ID.

        :type frame_id: int
        :param frame_id:    The frame ID of the frame.
        :type uvtile_id: int
        :param uvtile_id:   The uv-tile ID of the uv-tile.
        :type u: int
        :param u:           The u-coordinate of the uv-tile.
        :type v: int
        :param v:           The v-coordinate of the uv-tile.
        :rtype: int
        :return: 0 on success, -1 if ``uvtile_id`` is out of range.
        """
        return _pymdlsdk._IImage_get_uvtile_uv(self, frame_id, uvtile_id, u, v)

    def get_uvtile_id(self, frame_id, u, v):
        r"""
        Returns the uv-tile ID corresponding to u- and v-coordinates.

        :type frame_id: int
        :param frame_id:    The frame ID of the frame.
        :type u: int
        :param u:           The u-coordinate of the uv-tile.
        :type v: int
        :param v:           The v-coordinate of the uv-tile..
        :rtype: int
        :return: The uv-tile ID, or -1 of there is no uv-tile with the given coordinates.
        """
        return _pymdlsdk._IImage_get_uvtile_id(self, frame_id, u, v)

    def get_uvtile_uv_ranges(self, frame_id, min_u, min_v, max_u, max_v):
        r"""
        Returns the ranges of u- and v-coordinates.

        :type frame_id: int
        :param frame_id:    The frame ID of the frame.
        :type min_u: int, out
        :param min_u:  Smallest u-coordinate for that frame.
        :type min_v: int, out
        :param min_v:  Smallest v-coordinate for that frame.
        :type max_u: int, out
        :param max_u:  Largest u-coordinate for that frame.
        :type max_v: int, out
        :param max_v:  Largest v-coordinate for that frame.
        """
        return _pymdlsdk._IImage_get_uvtile_uv_ranges(self, frame_id, min_u, min_v, max_u, max_v)

    def get_filename(self, frame_id, uvtile_id):
        r"""
        Returns the resolved file name of a mipmap of the image.

        The method returns ``NULL`` if there is no file associated with the mipmap, e.g., after
        default construction, calls to #set_from_canvas(), or failures to resolve the file name
        passed to #reset_file().

        :type frame_id: int
        :param frame_id:    The frame ID of the mipmap.
        :type uvtile_id: int
        :param uvtile_id:   The uv-tile ID of the mipmap.

        See also: #get_original_filename()
        """
        return _pymdlsdk._IImage_get_filename(self, frame_id, uvtile_id)

    def get_original_filename(self):
        r"""
        Returns the unresolved file as passed to #reset_file().

        The method returns ``NULL`` after default construction or calls to #set_from_canvas().

        See also: #get_filename()
        """
        return _pymdlsdk._IImage_get_original_filename(self)

    def get_selector(self):
        r""" Returns the selector (or ``NULL)``."""
        return _pymdlsdk._IImage_get_selector(self)

    def get_canvas(self, frame_id, uvtile_id, level):
        r"""
        Returns a canvas with the pixel data of the image.

        Note that it is not possible to manipulate the pixel data.

        :type frame_id: int
        :param frame_id:    The frame ID of the canvas.
        :type uvtile_id: int
        :param uvtile_id:   The uv-tile ID of the canvas.
        :type level: int
        :param level:       The desired mipmap level. Level 0 is the highest resolution.
        :rtype: :py:class:`ICanvas`
        :return: A canvas pointing to the pixel data of the image, or ``NULL`` in case of
                               failure, e.g., because of an invalid uv-tile ID.
        """
        return _pymdlsdk._IImage_get_canvas(self, frame_id, uvtile_id, level)

    def get_type(self, frame_id, uvtile_id):
        r"""
        Returns the pixel type of a mipmap.

        :type frame_id: int
        :param frame_id:    The frame ID of the mipmap.
        :type uvtile_id: int
        :param uvtile_id:   The uv-tile ID of the mipmap to get the pixel type for.
        :rtype: string
        :return: The pixel type, or ``NULL`` in case of an invalid frame ID or uv-tile ID.

        See 'mi_neuray_types' for a list of supported pixel types.
        """
        return _pymdlsdk._IImage_get_type(self, frame_id, uvtile_id)

    def get_levels(self, frame_id, uvtile_id):
        r"""
        Returns the number of levels in the mipmap pyramid.

        :type frame_id: int
        :param frame_id:    The frame ID of the mipmap.
        :type uvtile_id: int
        :param uvtile_id:   The uv-tile ID of the mipmap to get the number of levels for.
        :rtype: int
        :return: The number of levels, or -1 in case of an invalid frame ID or uv-tile ID.
        """
        return _pymdlsdk._IImage_get_levels(self, frame_id, uvtile_id)

    def resolution_x(self, frame_id, uvtile_id, level):
        r"""
        Returns the horizontal resolution of a canvas.

        :type frame_id: int
        :param frame_id:    The frame ID of the canvas.
        :type uvtile_id: int
        :param uvtile_id:   The uv-tile ID of the canvas to get the resolution for.
        :type level: int
        :param level:       The desired mipmap level. Level 0 is the highest resolution.
        :rtype: int
        :return: The horizontal resolution, or -1 in case of an invalid frame ID,
                               uv-tile ID, or level.
        """
        return _pymdlsdk._IImage_resolution_x(self, frame_id, uvtile_id, level)

    def resolution_y(self, frame_id, uvtile_id, level):
        r"""
        Returns the vertical resolution of a canvas.

        :type frame_id: int
        :param frame_id:    The frame ID of the canvas.
        :type uvtile_id: int
        :param uvtile_id:   The uv-tile ID of the canvas to get the resolution for.
        :type level: int
        :param level:       The desired mipmap level. Level 0 is the highest resolution.
        :rtype: int
        :return: The vertical resolution, or -1 in case of an invalid frame ID,
                               uv-tile ID, or level.
        """
        return _pymdlsdk._IImage_resolution_y(self, frame_id, uvtile_id, level)

    def resolution_z(self, frame_id, uvtile_id, level):
        r"""
        Returns the number of layers of a canvas.

        :type frame_id: int
        :param frame_id:    The frame ID of the canvas.
        :type uvtile_id: int
        :param uvtile_id:   The uv-tile ID of the canvas to get the resolution for.
        :type level: int
        :param level:       The desired mipmap level. Level 0 is the highest resolution.
        :rtype: int
        :return: The number of layers, or -1 in case of an invalid frame ID,
                               uv-tile ID, or level.
        """
        return _pymdlsdk._IImage_resolution_z(self, frame_id, uvtile_id, level)

# Register _IImage in _pymdlsdk:
_pymdlsdk._IImage_swigregister(_IImage)

class Interface_declare_IMaterial_definition(_IScene_element):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IMaterial_definition_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IMaterial_definition

# Register Interface_declare_IMaterial_definition in _pymdlsdk:
_pymdlsdk.Interface_declare_IMaterial_definition_swigregister(Interface_declare_IMaterial_definition)

def Interface_declare_IMaterial_definition_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IMaterial_definition_compare_iid(iid)

class _IMaterial_definition(Interface_declare_IMaterial_definition):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_module(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_module().
        """
        return _pymdlsdk._IMaterial_definition_get_module(self)

    def get_mdl_name(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_mdl_name().
        """
        return _pymdlsdk._IMaterial_definition_get_mdl_name(self)

    def get_mdl_module_name(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_mdl_module_name().
        """
        return _pymdlsdk._IMaterial_definition_get_mdl_module_name(self)

    def get_mdl_simple_name(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_mdl_simple_name().
        """
        return _pymdlsdk._IMaterial_definition_get_mdl_simple_name(self)

    def get_mdl_parameter_type_name(self, index):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_mdl_parameter_type_name().
        """
        return _pymdlsdk._IMaterial_definition_get_mdl_parameter_type_name(self, index)

    def get_prototype(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_prototype().
        """
        return _pymdlsdk._IMaterial_definition_get_prototype(self)

    def get_mdl_version(self, since, removed):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_mdl_version().
        """
        return _pymdlsdk._IMaterial_definition_get_mdl_version(self, since, removed)

    def get_semantic(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_semantic().
        """
        return _pymdlsdk._IMaterial_definition_get_semantic(self)

    def is_exported(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::is_exported().
        """
        return _pymdlsdk._IMaterial_definition_is_exported(self)

    def get_return_type(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_return_type().
        """
        return _pymdlsdk._IMaterial_definition_get_return_type(self)

    def get_parameter_count(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_parameter_count().
        """
        return _pymdlsdk._IMaterial_definition_get_parameter_count(self)

    def get_parameter_name(self, index):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_parameter_name().
        """
        return _pymdlsdk._IMaterial_definition_get_parameter_name(self, index)

    def get_parameter_index(self, name):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_parameter_index().
        """
        return _pymdlsdk._IMaterial_definition_get_parameter_index(self, name)

    def get_parameter_types(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_parameter_types().
        """
        return _pymdlsdk._IMaterial_definition_get_parameter_types(self)

    def get_defaults(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_defaults().
        """
        return _pymdlsdk._IMaterial_definition_get_defaults(self)

    def get_enable_if_conditions(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_enable_if_conditions().
        """
        return _pymdlsdk._IMaterial_definition_get_enable_if_conditions(self)

    def get_enable_if_users(self, index):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_enable_if_users().
        """
        return _pymdlsdk._IMaterial_definition_get_enable_if_users(self, index)

    def get_enable_if_user(self, index, u_index):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_enable_if_user().
        """
        return _pymdlsdk._IMaterial_definition_get_enable_if_user(self, index, u_index)

    def get_annotations(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_annotations().
        """
        return _pymdlsdk._IMaterial_definition_get_annotations(self)

    def get_return_annotations(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_return_annotations().
        """
        return _pymdlsdk._IMaterial_definition_get_return_annotations(self)

    def get_parameter_annotations(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_parameter_annotations().
        """
        return _pymdlsdk._IMaterial_definition_get_parameter_annotations(self)

    def get_thumbnail(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_thumbnail().
        """
        return _pymdlsdk._IMaterial_definition_get_thumbnail(self)

    def is_valid(self, context):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::is_valid().
        """
        return _pymdlsdk._IMaterial_definition_is_valid(self, context)

    def get_body(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_body().
        """
        return _pymdlsdk._IMaterial_definition_get_body(self)

    def get_temporary_count(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_temporary_count().
        """
        return _pymdlsdk._IMaterial_definition_get_temporary_count(self)

    def get_temporary(self, index):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_temporary().
        """
        return _pymdlsdk._IMaterial_definition_get_temporary(self, index)

    def get_temporary_name(self, index):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_temporary_name().
        """
        return _pymdlsdk._IMaterial_definition_get_temporary_name(self, index)

    def create_material_instance_with_ret(self, arguments):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::create_function_call().
        """
        return _pymdlsdk._IMaterial_definition_create_material_instance_with_ret(self, arguments)

    def create_material_instance(self, arguments):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::create_function_call().
        """
        return _pymdlsdk._IMaterial_definition_create_material_instance(self, arguments)

# Register _IMaterial_definition in _pymdlsdk:
_pymdlsdk._IMaterial_definition_swigregister(_IMaterial_definition)

class Interface_declare_IMaterial_instance(_IScene_element):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IMaterial_instance_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IMaterial_instance

# Register Interface_declare_IMaterial_instance in _pymdlsdk:
_pymdlsdk.Interface_declare_IMaterial_instance_swigregister(Interface_declare_IMaterial_instance)

def Interface_declare_IMaterial_instance_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IMaterial_instance_compare_iid(iid)

class _IMaterial_instance(Interface_declare_IMaterial_instance):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    DEFAULT_OPTIONS = _pymdlsdk._IMaterial_instance_DEFAULT_OPTIONS
    r""" Default compilation options (e.g., instance compilation)."""
    CLASS_COMPILATION = _pymdlsdk._IMaterial_instance_CLASS_COMPILATION
    r""" Selects class compilation instead of instance compilation."""
    COMPILATION_OPTIONS_FORCE_32_BIT = _pymdlsdk._IMaterial_instance_COMPILATION_OPTIONS_FORCE_32_BIT

    def create_compiled_material(self, flags, context=None):
        r"""
        Creates a compiled material.

        :type flags: int
        :param flags:          A bitmask of flags of type #Compilation_options.
        :type context: :py:class:`IMdl_execution_context`, inout, optional
        :param context: An optional pointer to an execution context which can be used to pass
                                  compilation options to the MDL compiler. The following options are
                                  supported for this operation:
                                  - #mi::Float32 "meters_per_scene_unit": The conversion ratio between
                                    meters and scene units for this material. Default: 1.0f.
                                  - #mi::Float32 "wavelength_min": The smallest supported wavelength.
                                    Default: 380.0f.
                                  - #mi::Float32 "wavelength_max": The largest supported wavelength.
                                    Default: 780.0f.
                                  .
                                  The following options are supported in class compilation mode:
                                  - ``bool`` "fold_ternary_on_df": Fold all ternary operators of *df
                                    types. Default: ``false``.
                                  - ``bool`` "fold_all_bool_parameters": Fold all bool parameters.
                                    Default: ``false``.
                                  - ``bool`` "fold_all_enum_parameters": Fold all enum parameters.
                                    Default: ``false``.
                                  - #mi::base::IInterface *"fold_parameters": A static or dynamic array
                                    of strings of the parameters to fold. The names of the parameters
                                    are those that would otherwise be reported in
                                    #mi::neuraylib::ICompiled_material::get_parameter_name().
                                    Default: ``NULL``
                                  - ``bool`` "fold_trivial_cutout_opacity": Fold the expression for
                                    geometry.cutout_opacity if it evaluates to a constant with value
                                    0.0f or 1.0f. Default: ``false``.
                                  - ``bool`` "fold_transparent_layers": Calls to the functions
                                    ``df::weighted_layer()``, ``df::fresnel_layer()``,
                                    ``df::custom_curve_layer()``, ``df::measured_curve_layer()``, and
                                    their equivalents with color weights, are replaced by their
                                    ``base`` argument, if the ``weight`` argument evaluates to a constant
                                    with value 0.0f, and the ``layer`` argument is one of
                                    ``df::diffuse_transmission_bsdf()``, ``df::specular_bsdf()``,
                                    ``df::simple_glossy_bsdf()``, or ``df::microfacet_*_bsdf()``, and
                                    the ``scatter_mode`` argument (if present) is either
                                    ``df::scatter_transmit`` or ``df::scatter_reflect_transmit``.
                                    In addition, the ``layer`` argument might be a combination of such
                                    BSDFs using the ternary operator.
                                  .
                                  During material compilation, messages like errors and warnings will
                                  be passed to the context for later evaluation by the caller. Possible
                                  error conditions:
                                  - Type mismatch, call of an unsuitable DB element, or call cycle in
                                    the graph of this material instance.
                                  - The thin-walled material instance has different transmission for
                                    surface and backface.
                                  - An argument type of the graph of this material instance is varying
                                    but the corresponding parameter type is uniform.
                                  - An element in the array for the context option
                                    "fold_parameters" does not have the type #mi::IString.
        :rtype: :py:class:`ICompiled_material`
        :return: The corresponding compiled material, or ``NULL`` in case of failure.
        """
        return _pymdlsdk._IMaterial_instance_create_compiled_material(self, flags, context)

    def get_material_definition(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::get_function_definition().
        """
        return _pymdlsdk._IMaterial_instance_get_material_definition(self)

    def get_mdl_material_definition(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::get_mdl_function_definition().
        """
        return _pymdlsdk._IMaterial_instance_get_mdl_material_definition(self)

    def get_return_type(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::get_return_type().
        """
        return _pymdlsdk._IMaterial_instance_get_return_type(self)

    def get_parameter_count(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::get_parameter_count().
        """
        return _pymdlsdk._IMaterial_instance_get_parameter_count(self)

    def get_parameter_name(self, index):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::get_parameter_name().
        """
        return _pymdlsdk._IMaterial_instance_get_parameter_name(self, index)

    def get_parameter_index(self, name):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::get_parameter_index().
        """
        return _pymdlsdk._IMaterial_instance_get_parameter_index(self, name)

    def get_parameter_types(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::get_parameter_types().
        """
        return _pymdlsdk._IMaterial_instance_get_parameter_types(self)

    def get_arguments(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::get_arguments().
        """
        return _pymdlsdk._IMaterial_instance_get_arguments(self)

    def set_arguments(self, arguments):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::set_arguments().
        """
        return _pymdlsdk._IMaterial_instance_set_arguments(self, arguments)

    def set_argument(self, *args):
        r"""
        *Overload 1:*
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::set_argument(Size,const IExpression*).

        |

        *Overload 2:*
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::set_argument(const char*,const IExpression*).
        """
        return _pymdlsdk._IMaterial_instance_set_argument(self, *args)

    def reset_argument(self, *args):
        r"""
        *Overload 1:*
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::reset_argument(Size).

        |

        *Overload 2:*
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::reset_argument(const char*).
        """
        return _pymdlsdk._IMaterial_instance_reset_argument(self, *args)

    def is_default(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::is_default().
        """
        return _pymdlsdk._IMaterial_instance_is_default(self)

    def is_valid(self, context):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::is_valid().
        """
        return _pymdlsdk._IMaterial_instance_is_valid(self, context)

    def repair(self, flags, context):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::repair().
        """
        return _pymdlsdk._IMaterial_instance_repair(self, flags, context)

# Register _IMaterial_instance in _pymdlsdk:
_pymdlsdk._IMaterial_instance_swigregister(_IMaterial_instance)

class Interface_declare_IImage_api(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IImage_api_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IImage_api

# Register Interface_declare_IImage_api in _pymdlsdk:
_pymdlsdk.Interface_declare_IImage_api_swigregister(Interface_declare_IImage_api)

def Interface_declare_IImage_api_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IImage_api_compare_iid(iid)

class _IImage_api(Interface_declare_IImage_api):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def create_tile(self, pixel_type, width, height):
        r"""
        Creates a tile with given pixel type, width, and height.

        This factory function allows to create instances of the abstract interface
        #mi::neuraylib::ITile based on an internal default implementation. However, you are not
        obligated to use this factory function and the internal default implementation. It is
        absolutely fine to use your own (correct) implementation of the #mi::neuraylib::ITile
        interface.

        :type pixel_type: string
        :param pixel_type:   The desired pixel type. See 'mi_neuray_types' for a list of supported
                                pixel types.
        :type width: int
        :param width:        The desired width.
        :type height: int
        :param height:       The desired height.
        :rtype: :py:class:`ITile`
        :return: The requested tile, or ``NULL`` in case of invalid pixel type, width, or
                                height, or memory allocation failures.
        """
        return _pymdlsdk._IImage_api_create_tile(self, pixel_type, width, height)

    def create_canvas(self, pixel_type, width, height, layers=1, is_cubemap=False, gamma=0.0):
        r"""
        Creates a canvas with given pixel type, resolution, and layers.

        This factory function allows to create instances of the abstract interface
        #mi::neuraylib::ICanvas based on an internal default implementation. However, you are not
        obligated to use this factory function and the internal default implementation. It is
        absolutely fine to use your own (correct) implementation of the #mi::neuraylib::ICanvas
        interface.

        :type pixel_type: string
        :param pixel_type:   The desired pixel type. See 'mi_neuray_types' for a list of
                                supported pixel types.
        :type width: int
        :param width:        The desired width.
        :type height: int
        :param height:       The desired height.
        :type layers: int, optional
        :param layers:       The desired number of layers (depth). Must be 6 for cubemaps.
        :type is_cubemap: boolean, optional
        :param is_cubemap:   Flag that indicates whether this canvas represents a cubemap.
        :type gamma: float, optional
        :param gamma:        The desired gamma value. The special value 0.0 represents the default
                                gamma which is 1.0 for HDR pixel types and 2.2 for LDR pixel types.
        :rtype: :py:class:`ICanvas`
        :return: The requested canvas, or ``NULL`` in case of invalid pixel type, width,
                                height, layers, or cubemap flag, or memory allocation failures.
        """
        return _pymdlsdk._IImage_api_create_canvas(self, pixel_type, width, height, layers, is_cubemap, gamma)

    def create_canvas_cuda(self, cuda_device_id, pixel_type, width, height, layers=1, gamma=0.0):
        r"""
        Creates a CUDA canvas with given pixel type, width, height, and layers.

        See also: #create_canvas()
        See also: #mi::neuraylib::IGpu_description::get_cuda_device_id()

        :type cuda_device_id: int
        :param cuda_device_id: The CUDA ID of the device on which the canvas will reside.
                                Note that this is the CUDA device ID, not the 1-based GPU index
                                used in If: IRAY_API { #mi::neuraylib::IRendering_configuration.
                            }Else: #mi::neuraylib::IDice_configuration.  {}
        :type pixel_type: string
        :param pixel_type:   The desired pixel type. See 'mi_neuray_types' for a list of
                                supported pixel types.
        :type width: int
        :param width:        The desired width.
        :type height: int
        :param height:       The desired height.
        :type layers: int, optional
        :param layers:       The desired number of layers.
        :type gamma: float, optional
        :param gamma:        The desired gamma value. The special value 0.0 represents the default
                                gamma which is 1.0 for HDR pixel types and 2.2 for LDR pixel types.
        :rtype: mi::neuraylib::ICanvas_cuda
        :return: The requested canvas, or ``NULL`` in case of invalid parameters or
                                CUDA errors.
        """
        return _pymdlsdk._IImage_api_create_canvas_cuda(self, cuda_device_id, pixel_type, width, height, layers, gamma)

    def create_mipmaps(self, canvas, gamma_override=0.0):
        r"""
        Creates mipmaps from the given canvas.

        Notes: The base level (the canvas that is passed in) is not included in the returned
        canvas array.

        :type canvas: :py:class:`ICanvas`
        :param canvas:           The canvas to create the mipmaps from.
        :type gamma_override: float, optional
        :param gamma_override:   If this parameter is different from zero, it is used instead of the
                                    canvas gamma during mipmap creation.
        :rtype: :py:class:`IArray`
        :return: An array of type #mi::IPointer containing pointers to
                                    the mipmaps of type #mi::neuraylib::ICanvas.
                                    If no mipmaps could be created, NULL is returned.
        """
        return _pymdlsdk._IImage_api_create_mipmaps(self, canvas, gamma_override)

    def read_raw_pixels(self, width, height, canvas, canvas_x, canvas_y, canvas_layer, buffer, buffer_topdown, buffer_pixel_type, buffer_padding=0):
        r"""
        Reads raw pixel data from a canvas.

        Reads a rectangular area of pixels from a canvas (possibly spanning multiple tiles),
        converts the pixel type if needed, and writes the pixel data to buffer in memory.
        Management of the buffer memory is the responsibility of the caller.

        :type width: int
        :param width:               The width of the rectangular pixel area.
        :type height: int
        :param height:              The height of the rectangular pixel area.
        :type canvas: :py:class:`ICanvas`
        :param canvas:              The canvas to read the pixel data from.
        :type canvas_x: int
        :param canvas_x:            The x-coordinate of the lower-left corner of the rectangle.
        :type canvas_y: int
        :param canvas_y:            The y-coordinate of the lower-left corner of the rectangle.
        :type canvas_layer: int
        :param canvas_layer:        The layer of the canvas that holds the rectangular area.
        :type buffer: void
        :param buffer:              The buffer to write the pixel data to.
        :type buffer_topdown: boolean
        :param buffer_topdown:      Indicates whether the buffer stores the rows in top-down order.
        :type buffer_pixel_type: string
        :param buffer_pixel_type:   The pixel type of the buffer. See 'mi_neuray_types' for a
                                       list of supported pixel types.
        :type buffer_padding: int, optional
        :param buffer_padding:      The padding between subsequent rows of the buffer in bytes.
        :rtype: int
        :return: 
                                       -  0: Success.
                                       - -1: Invalid parameters (``NULL`` pointer).
                                       - -2: ``width`` or ``height`` is zero.
                                       - -3: Invalid pixel type of the buffer.
                                       - -4: The rectangular area [``canvas_x``, ``canvas_x`` + ``width)``
                                             x [``canvas_y``, ``canvas_y`` + ``height)`` exceeds the size
                                             of the canvas, or ``canvas_layer`` is invalid.
        """
        return _pymdlsdk._IImage_api_read_raw_pixels(self, width, height, canvas, canvas_x, canvas_y, canvas_layer, buffer, buffer_topdown, buffer_pixel_type, buffer_padding)

    def write_raw_pixels(self, width, height, canvas, canvas_x, canvas_y, canvas_layer, buffer, buffer_topdown, buffer_pixel_type, buffer_padding=0):
        r"""
        Writes raw pixel data to a canvas.

        Reads a rectangular area of pixels from a buffer in memory, converts the pixel type if
        needed, and writes the pixel data to a canvas (possibly spanning multiple tiles).
        Management of the buffer memory is the responsibility of the caller.

        :type width: int
        :param width:               The width of the rectangular pixel area.
        :type height: int
        :param height:              The height of the rectangular pixel area.
        :type canvas: :py:class:`ICanvas`
        :param canvas:              The canvas to write the pixel data to.
        :type canvas_x: int
        :param canvas_x:            The x-coordinate of the lower-left corner of the rectangle.
        :type canvas_y: int
        :param canvas_y:            The y-coordinate of the lower-left corner of the rectangle.
        :type canvas_layer: int
        :param canvas_layer:        The layer of the canvas that holds the rectangular area.
        :type buffer: void
        :param buffer:              The buffer to read the pixel data from.
        :type buffer_topdown: boolean
        :param buffer_topdown:      Indicates whether the buffer stores the rows in top-down order.
        :type buffer_pixel_type: string
        :param buffer_pixel_type:   The pixel type of the buffer. See 'mi_neuray_types' for a
                                       list of supported pixel types.
        :type buffer_padding: int, optional
        :param buffer_padding:      The padding between subsequent rows of the buffer in bytes.
        :rtype: int
        :return: 
                                       -  0: Success.
                                       - -1: Invalid parameters (``NULL`` pointer).
                                       - -2: ``width`` or ``height`` is zero.
                                       - -3: Invalid pixel type of the buffer.
                                       - -4: The rectangular area [``canvas_x``, ``canvas_x`` + ``width)``
                                             x [``canvas_y``, ``canvas_y`` + ``height)`` exceeds the size
                                             of the canvas, or ``canvas_layer`` is invalid.
        """
        return _pymdlsdk._IImage_api_write_raw_pixels(self, width, height, canvas, canvas_x, canvas_y, canvas_layer, buffer, buffer_topdown, buffer_pixel_type, buffer_padding)

    def create_buffer_from_canvas(self, canvas, image_format, pixel_type, quality, force_default_gamma=False):
        r"""
        Encodes the pixel data of a canvas into a memory buffer.

        :type canvas: :py:class:`ICanvas`
        :param canvas:                The canvas whose contents are to be used.
        :type image_format: string
        :param image_format:          The desired image format of the image, e.g., ``"jpg"``. Note
                                         that support for a given image format requires an image plugin
                                         capable of handling that format.
        :type pixel_type: string
        :param pixel_type:            The desired pixel type. See 'mi_neuray_types' for a list of
                                         supported pixel types. Not every image plugin supports every
                                         pixel type. If the requested pixel type is not supported, the
                                         argument is ignored and one of the supported formats is chosen
                                         instead.
        :type quality: string
        :param quality:               The compression quality is an integer in the range from 0 to
                                         100, where 0 is the lowest quality, and 100 is the highest
                                         quality.
        :type force_default_gamma: boolean, optional
        :param force_default_gamma:   If enabled, adjusts the gamma value of the exported pixel data
                                         according to the pixel type chosen for export (1.0 for HDR
                                         pixel types, 2.2 for LDR pixel types).
        :rtype: mi::neuraylib::IBuffer
        :return: The created buffer, or ``NULL`` in case of failure.
        """
        return _pymdlsdk._IImage_api_create_buffer_from_canvas(self, canvas, image_format, pixel_type, quality, force_default_gamma)

    def create_canvas_from_buffer(self, buffer, image_format):
        r"""
        Decodes the pixel data of a memory buffer into a canvas.

        :type buffer: mi::neuraylib::IBuffer
        :param buffer:        The buffer that holds the encoded pixel data.
        :type image_format: string
        :param image_format:  The image format of the buffer, e.g., ``"jpg"``. Note that support for
                                 a given image format requires an image plugin capable of handling that
                                 format.
        :rtype: :py:class:`ICanvas`
        :return: The canvas with the decoded pixel data, or ``NULL`` in case of failure.
        """
        return _pymdlsdk._IImage_api_create_canvas_from_buffer(self, buffer, image_format)

    def create_canvas_from_reader(self, reader, image_format):
        r"""
        Decodes the pixel data from a reader into a canvas.

        :type reader: mi::neuraylib::IReader
        :param reader:        The reader that provides the data for the image. The reader needs to
                                 support absolute access.
        :type image_format: string
        :param image_format:  The image format of the buffer, e.g., ``"jpg"``. Note that support for
                                 a given image format requires an image plugin capable of handling that
                                 format.
        :rtype: :py:class:`ICanvas`
        :return: The canvas with the decoded pixel data, or ``NULL`` in case of failure.
        """
        return _pymdlsdk._IImage_api_create_canvas_from_reader(self, reader, image_format)

    def supports_format_for_decoding(self, image_format, reader=None):
        r"""
        Indicates whether a particular image format is supported for decoding.

        Support for a given image format requires an image plugin capable of handling that format.
        This method allows to check whether such a plugin has been loaded for a particular format.

        Decoding is used when the image is converted into a canvas from a If: DICE_API { memory
        buffer. }Else: memory buffer or a file  {}. Note that even if this method returns ``true``,
        #create_canvas_from_buffer() If: IRAY_API { or
        #mi::neuraylib::IImport_api::import_canvas() } can still fail for a particular image if
        that image uses an unsupported feature.

        :type image_format: string
        :param image_format:   The image format in question, e.g., ``"jpg"``.
        :type reader: mi::neuraylib::IReader, optional
        :param reader:         An optional reader If: IRAY_API { used by
                              #mi::neuraylib::IImage_plugin::test(). }
        :rtype: boolean
        :return: ``true`` if the image format is supported, ``false`` otherwise
        """
        return _pymdlsdk._IImage_api_supports_format_for_decoding(self, image_format, reader)

    def supports_format_for_encoding(self, image_format):
        r"""
        Indicates whether a particular image format is supported for encoding.

        Support for a given image format requires an image plugin capable of handling that format.
        This method allows to check whether such a plugin has been loaded for a particular format.

        Encoding is used when the image is converted from a canvas into a If: DICE_API { memory
        buffer. }Else: memory buffer or a file.  {}. Note that even if this method returns
        ``true``, #create_buffer_from_canvas() If: IRAY_API { or
        #mi::neuraylib::IExport_api::export_canvas } can still fail if the given canvas
        uses an unsupported feature, e.g., multiple layers.

        :type image_format: string
        :param image_format:   The image format in question, e.g., ``"jpg"``.
        :rtype: boolean
        :return: ``true`` if the image format is supported, ``false`` otherwise
        """
        return _pymdlsdk._IImage_api_supports_format_for_encoding(self, image_format)

    def convert(self, canvas, pixel_type):
        r"""
        Converts a canvas to a different pixel type.

        Notes: This method creates a copy if the passed-in canvas already has the desired pixel type.
        (It cannot return the passed-in canvas since this would require a const cast.) If
        performance is critical, you should compare pixel types yourself and skip the method call if
        pixel type conversion is not needed.)

        The conversion converts a given pixel as follows:

        - Floating-point values are linearly mapped to integers as follows: 0.0f is mapped to 0 and
          1.0f is mapped to 255 or 65535, respectively. Note that the pixel type ``"Sint8"`` is
          treated as the corresponding unsigned integer type ``"Uint8"`` here. Floating-point values
          are clamped to [0.0f, 1.0f] beforehand. The reverse conversion uses the corresponding
          inverse mapping.
        - Single-channel formats are converted to grey-scale RGB formats by duplicating the value
          in each channel.
        - RGB formats are converted to single-channel formats by mixing the RGB channels with
          weights 0.27f for red, 0.67f for green, and 0.06f for blue.
        - If an alpha channel is added, the values are set to 1.0f, 255, or 65535 respectively.
        - The pixel type ``"Float32<4>"`` is treated in the same way as ``"Color"``, ``"Float32<3>"``
          in the same way as ``"Rgb_fp"``, and ``"Sint32"`` in the same way as ``"Rgba"``.
        - The pixel type ``"Rgbe"`` is converted via ``"Rgb_fp"``. Similarly, ``"Rgbea"`` is converted
          via ``"Color"``.
        - ``"Float32<2>"`` is converted to single-channel formats by averaging the two channels. If
          ``"Float32<2>"`` is converted to three- or four-channel formats, the blue channel is set to
          0.0f, or 0, respectively. Conversion of single-channel formats to ``"Float32<2>"``
          duplicates the channel. Conversion of three- or four-channel formats to ``"Float32<2>"``
          drops the third and fourth channel.

        :type canvas: :py:class:`ICanvas`
        :param canvas:       The canvas to convert (or to copy).
        :type pixel_type: string
        :param pixel_type:   The desired pixel type. See 'mi_neuray_types' for a list of supported
                                pixel types. If this pixel type is the same as the pixel type of
           ``canvas``, then a copy of the canvas is returned.
        :rtype: :py:class:`ICanvas`
        :return: A canvas with the requested pixel type, or ``NULL`` in case of errors
                                (``canvas`` is ``NULL``, or ``pixel_type`` is not valid).
        """
        return _pymdlsdk._IImage_api_convert(self, canvas, pixel_type)

    def adjust_gamma(self, canvas, new_gamma):
        r"""
        Sets the gamma value of a canvas and adjusts the pixel data accordingly.

        Notes: Gamma adjustments are always done in pixel type "Color" or "Rgb_fp". If necessary,
              the pixel data is converted forth and back automatically (which needs temporary
              buffers).

        :type canvas: :py:class:`ICanvas`
        :param canvas:           The canvas whose pixel data is to be adjusted.
        :type new_gamma: float
        :param new_gamma:        The new gamma value.
        """
        return _pymdlsdk._IImage_api_adjust_gamma(self, canvas, new_gamma)

    def get_components_per_pixel(self, pixel_type):
        r"""
        Returns the number of components per pixel type.

        For example, for the pixel type "Color" the method returns 4 because it consists of four
        components R, G, B, and A. Returns 0 in case of invalid pixel types.

        See also: #get_bytes_per_component()
        """
        return _pymdlsdk._IImage_api_get_components_per_pixel(self, pixel_type)

    def get_bytes_per_component(self, pixel_type):
        r"""
        Returns the number of bytes used per pixel component.

        For example, for the pixel type "Color" the method returns 4 because its components are of
        type #mi::Float32 which needs 4 bytes. Returns 0 in case of invalid pixel types.

        See also: #get_components_per_pixel()
        """
        return _pymdlsdk._IImage_api_get_bytes_per_component(self, pixel_type)

    def get_pixel_type_for_channel(self, pixel_type, selector):
        r"""
        Returns the pixel type of an RGBA channel.

        Invalid pixel type/selector combinations are:
        - ``pixel_type`` is not an RGB or RGBA pixel type
        - ``selector`` is not an RGBA channel selector

        :type pixel_type: string
        :param pixel_type:   The pixel type of the mipmap/canvas/tile.
        :type selector: string
        :param selector:     The RGBA channel selector.
        :rtype: string
        :return: Returns PT_UNDEF for invalid pixel type/selector combinations.
                                Otherwise, returns PT_SINT8 or PT_FLOAT32, depending on
                                ``pixel_type``.
        """
        return _pymdlsdk._IImage_api_get_pixel_type_for_channel(self, pixel_type, selector)

    def extract_channel(self, *args):
        r"""
        *Overload 1:*
        Extracts an RGBA channel from a canvas.

        :type canvas: :py:class:`ICanvas`
        :param canvas:           The canvas to extract a channel from.
        :type selector: string
        :param selector:         The RGBA channel selector.
        :rtype: :py:class:`ICanvas`
        :return: The extracted channel, or ``NULL`` in case of invalid pixel type/
                                    channel selector combinations (see #get_pixel_type_for_channel()).

        |

        *Overload 2:*
        Extracts an RGBA channel from a tile.

        :type tile: :py:class:`ITile`
        :param tile:             The tile to extract a channel from.
        :type selector: string
        :param selector:         The RGBA channel selector.
        :rtype: :py:class:`ITile`
        :return: The extracted channel, or ``NULL`` in case of invalid pixel type/
                                    channel selector combinations (see #get_pixel_type_for_channel()).
        """
        return _pymdlsdk._IImage_api_extract_channel(self, *args)

# Register _IImage_api in _pymdlsdk:
_pymdlsdk._IImage_api_swigregister(_IImage_api)

class Interface_declare_IMdl_configuration(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IMdl_configuration_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IMdl_configuration

# Register Interface_declare_IMdl_configuration in _pymdlsdk:
_pymdlsdk.Interface_declare_IMdl_configuration_swigregister(Interface_declare_IMdl_configuration)

def Interface_declare_IMdl_configuration_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IMdl_configuration_compare_iid(iid)

class _IMdl_configuration(Interface_declare_IMdl_configuration):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_logger(self, logger):
        r"""
        Sets the logger.

        If: IRAY_API { Sets the receiving logger, see also
        #mi::neuraylib::ILogging_configuration::set_receiving_logger().}Else:  { Installs a custom logger, and deinstalls the previously installed logger.
        By default, an internal logger is installed that prints all messages of severity
        #mi::base::details::MESSAGE_SEVERITY_INFO or higher to stderr.}

        :type logger: mi::base::ILogger
        :param logger:   The new logger that receives all log messages. Passing ``NULL`` is allowed
                            to reinstall the default logger.
        """
        return _pymdlsdk._IMdl_configuration_set_logger(self, logger)

    def get_logger(self):
        r"""
        Returns the used logger.

        :rtype: mi::base::ILogger
        :return: If: IRAY_API { Returns the forwarding logger. See
                  also #mi::neuraylib::ILogging_configuration::get_forwarding_logger(). }Else: The {
                  currently used logger ( either explicitly installed via #set_logger(), or
                  the default logger). Never returns ``NULL``. }
        """
        return _pymdlsdk._IMdl_configuration_get_logger(self)

    def add_mdl_path(self, path):
        r"""
        Adds a path to the list of paths to search for MDL modules.

        This search path is also used for resources referenced in MDL modules. By default, the list
        of MDL paths is empty.

        :type path: string
        :param path:                The path to be added.
        :rtype: int
        :return: 
                                       -  0: Success.
                                       - -1: Invalid parameters ( ``NULL`` pointer).
                                       - -2: Invalid path.
        """
        return _pymdlsdk._IMdl_configuration_add_mdl_path(self, path)

    def remove_mdl_path(self, path):
        r"""
        Removes a path from the list of paths to search for MDL modules.

        This search path is also used for resources referenced in MDL modules. By default, the list
        of MDL paths is empty.

        :type path: string
        :param path:                The path to be removed.
        :rtype: int
        :return: 
                                       -  0: Success.
                                       - -1: Invalid parameters ( ``NULL`` pointer).
                                       - -2: There is no such path in the path list.
        """
        return _pymdlsdk._IMdl_configuration_remove_mdl_path(self, path)

    def clear_mdl_paths(self):
        r"""
        Clears the list of paths to search for MDL modules.

        This search path is also used for resources referenced in MDL modules. By default, the list
        of MDL paths is empty.
        """
        return _pymdlsdk._IMdl_configuration_clear_mdl_paths(self)

    def get_mdl_paths_length(self):
        r"""
        Returns the number of paths to search for MDL modules.

        This search path is also used for resources referenced in MDL modules. By default, the list
        of MDL paths is empty.

        :rtype: int
        :return: The number of currently configured paths.
        """
        return _pymdlsdk._IMdl_configuration_get_mdl_paths_length(self)

    def get_mdl_path(self, index):
        r"""
        Returns the ``index`` -th path to search for MDL modules.

        This search path is also used for resources referenced in MDL modules. By default, the list
        of MDL paths is empty.

        :rtype: :py:class:`IString`
        :return: The ``index`` -th path, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk._IMdl_configuration_get_mdl_path(self, index)

    def get_mdl_system_paths_length(self):
        r""" Returns the number of MDL system paths."""
        return _pymdlsdk._IMdl_configuration_get_mdl_system_paths_length(self)

    def get_mdl_system_path(self, index):
        r"""
        Returns the ``index`` -th path in the MDL system paths.

        The default MDL system path is
        - ``%%PROGRAMDATA%``\NVIDIA ``Corporation``\mdl (on Windows),
        - ``/opt/nvidia/mdl`` (on Linux), and
        - ``/Library/Application`` ``Support/NVIDIA`` ``Corporation/mdl`` (on Mac OS).

        The MDL system paths can be changed via the environment variable ``MDL_SYSTEM_PATH``. The
        environment variable can contain multiple paths which are separated by semicolons (on
        Windows) or colons (on Linux and Mac OS), respectively.

        :rtype: string
        :return: The ``index`` -th path, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk._IMdl_configuration_get_mdl_system_path(self, index)

    def add_mdl_system_paths(self):
        r""" Adds the MDL system paths to the MDL search path."""
        return _pymdlsdk._IMdl_configuration_add_mdl_system_paths(self)

    def get_mdl_user_paths_length(self):
        r""" Returns the number of MDL user paths."""
        return _pymdlsdk._IMdl_configuration_get_mdl_user_paths_length(self)

    def get_mdl_user_path(self, index):
        r"""
        Returns the ``index`` -th path in the MDL user paths.

        The default MDL user path is
        - ``%%DOCUMENTS%``\mdl (on Windows),
        - ``$HOME/Documents/mdl`` (on Linux), and
        - ``$HOME/Documents/mdl`` (on Mac OS),
        where %DOCUMENTS% refers to the standard folder identified by ``FOLDERID_Documents`` from
        the Windows API (usually ``%%USERPROFILE%``\Documents).

        The MDL user paths can be changed via the environment variable ``MDL_USER_PATH``. The
        environment variable can contain multiple paths which are separated by semicolons (on
        Windows) or colons (on Linux and Mac OS), respectively.

        :rtype: string
        :return: The ``index`` -th path, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk._IMdl_configuration_get_mdl_user_path(self, index)

    def add_mdl_user_paths(self):
        r""" Adds the MDL user paths to the MDL search path."""
        return _pymdlsdk._IMdl_configuration_add_mdl_user_paths(self)

    def add_resource_path(self, path):
        r"""
        Adds a path to the list of paths to search for resources, i.e., textures, light profiles,
        and BSDF measurements.

        Note that for MDL resources referenced in .``mdl`` files the MDL search paths are considered,
        not the resource search path. By default, the list of resource paths is empty.

        :type path: string
        :param path:                The path to be added.
        :rtype: int
        :return: 
                                       -  0: Success.
                                       - -1: Invalid parameters ( ``NULL`` pointer).
                                       - -2: Invalid path.
        """
        return _pymdlsdk._IMdl_configuration_add_resource_path(self, path)

    def remove_resource_path(self, path):
        r"""
        Removes a path from the list of paths to search for resources, i.e., textures, light
        profiles, and BSDF measurements.

        Note that for MDL resources referenced in .``mdl`` files the MDL search paths are considered,
        not the resource search path. By default, the list of resource paths is empty.

        :type path: string
        :param path:                The path to be removed.
        :rtype: int
        :return: 
                                       -  0: Success.
                                       - -1: Invalid parameters ( ``NULL`` pointer).
                                       - -2: There is no such path in the path list.
        """
        return _pymdlsdk._IMdl_configuration_remove_resource_path(self, path)

    def clear_resource_paths(self):
        r"""
        Clears the list of paths to search for resources, i.e., textures, light profiles,
        and BSDF measurements.

        Note that for MDL resources referenced in .``mdl`` files the MDL search paths are considered,
        not the resource search path. By default, the list of resource paths is empty.
        """
        return _pymdlsdk._IMdl_configuration_clear_resource_paths(self)

    def get_resource_paths_length(self):
        r"""
        Returns the number of paths to search for resources, i.e., textures, light profiles,
        and BSDF measurements.

        Note that for MDL resources referenced in .``mdl`` files the MDL search paths are considered,
        not the resource search path. By default, the list of resource paths is empty.

        :rtype: int
        :return: The number of currently configured paths.
        """
        return _pymdlsdk._IMdl_configuration_get_resource_paths_length(self)

    def get_resource_path(self, index):
        r"""
        Returns the ``index`` -th path to search for resources, i.e., textures, light profiles,
        and BSDF measurements.

        Note that for MDL resources referenced in .``mdl`` files the MDL search paths are considered,
        not the resource search path. By default, the list of resource paths is empty.

        :rtype: :py:class:`IString`
        :return: The ``index`` -th path, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk._IMdl_configuration_get_resource_path(self, index)

    def set_implicit_cast_enabled(self, value):
        r"""
        Defines whether a cast operator is automatically inserted for compatible argument types.

        If set to ``true``, an appropriate cast operator is automatically inserted if arguments for
        instances of #mi::neuraylib::IFunction_call have a different but compatible type. If set to
        ``false``, such an assignment fails and it is necessary to insert the cast operator
        explicitly. Default: ``true``.

        See also: #mi::neuraylib::IExpression_factory::create_cast().

        :type value: boolean
        :param value:    ``True`` to enable the feature, ``false`` otherwise.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: The method cannot be called at this point of time.
        """
        return _pymdlsdk._IMdl_configuration_set_implicit_cast_enabled(self, value)

    def get_implicit_cast_enabled(self):
        r"""
        Indicates whether the SDK is supposed to automatically insert the cast operator for
        compatible types.

        See also: #set_implicit_cast_enabled()
        """
        return _pymdlsdk._IMdl_configuration_get_implicit_cast_enabled(self)

    def set_expose_names_of_let_expressions(self, value):
        r"""
        Defines whether an attempt is made to expose names of let expressions.

        If set to ``true``, the MDL compiler attempts to represent let expressions as temporaries,
        and makes the name of let expressions available as names of such temporaries. In order to
        do so, certain optimizations are disabled, in particular, constant folding. These names are
        only available on material and functions definitions, not on compiled materials, which are
        always highly optimized. Default: ``true``.

        Notes: Since some optimizations are essential for inner workings of the MDL compiler, there

        See also: #mi::neuraylib::IFunction_definition::get_temporary_name()
        """
        return _pymdlsdk._IMdl_configuration_set_expose_names_of_let_expressions(self, value)

    def get_expose_names_of_let_expressions(self):
        r"""
        Indicates whether an attempt is made to expose names of let expressions.

        See also: #set_expose_names_of_let_expressions()
        """
        return _pymdlsdk._IMdl_configuration_get_expose_names_of_let_expressions(self)

    def set_simple_glossy_bsdf_legacy_enabled(self, value):
        r"""
        Configures the behavior of ``df::simple_glossy_bsdf()`` in MDL modules
        of versions smaller than 1.3.

        Notes: If: IRAY_API { This setting can only be configured before The MDL SDKhas been
              started. }Else: This function has no effect in the MDL SDK and always returns -1. {
              }

        :type value: boolean
        :param value:    ``True`` to enable the feature, ``false`` otherwise.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: The method cannot be called at this point of time.
        """
        return _pymdlsdk._IMdl_configuration_set_simple_glossy_bsdf_legacy_enabled(self, value)

    def get_simple_glossy_bsdf_legacy_enabled(self):
        r"""
        Returns ``true`` if the legacy behavior for bsdfs of type ``df::simple_glossy_bsdf()`` used
        in MDL modules with versions smaller that 1.3 is enabled, ``false`` otherwise.
        """
        return _pymdlsdk._IMdl_configuration_get_simple_glossy_bsdf_legacy_enabled(self)

    def get_entity_resolver(self):
        r"""
        Returns an instance of the built-in entity resolver.

        Notes: The returned instance contains a copy of the currently configured search paths,
              subsequent changes to the search paths are not reflected in this instance.
        """
        return _pymdlsdk._IMdl_configuration_get_entity_resolver(self)

    def set_entity_resolver(self, resolver):
        r"""
        Installs an external entity resolver.

        :type resolver: mi::neuraylib::IMdl_entity_resolver
        :param resolver:   The external entity resolver to be used instead of the built-in entity
                              resolver. Pass ``NULL`` to uninstall a previously installed external
                              entity resolver.

        Notes: MDL archive creation is not supported with an external entity resolver ( see
              #mi::neuraylib::IMdl_archive_api::create_archive()).
        """
        return _pymdlsdk._IMdl_configuration_set_entity_resolver(self, resolver)

    def set_materials_are_functions(self, value):
        r"""
        Defines whether materials are treated as functions.

        See also: 'mi_mdl_materials_are_functions', #get_materials_are_functions().
        """
        return _pymdlsdk._IMdl_configuration_set_materials_are_functions(self, value)

    def get_materials_are_functions(self):
        r"""
        Indicates whether materials are treated as functions.

        See also: 'mi_mdl_materials_are_functions', #set_materials_are_functions().
        """
        return _pymdlsdk._IMdl_configuration_get_materials_are_functions(self)

    def set_encoded_names_enabled(self, value):
        r"""
        Defines whether encoded names are enabled.

        See 'mi_mdl_encoded_names' for details.

        This feature is enabled by default. Support for the disabled feature will be deprecated and
        removed in a future release.

        This can only be configured before the MDL SDKhas been started.

        Notes: This feature does not yet support module names containing parentheses or commas.

        If: IRAY_API { Notes: All hosts in a cluster need to agree on this setting. }

        If: IRAY_API { Notes: This setting needs to be the identical during export and import of
                           ``.mib`` files. }

        If: IRAY_API { Notes: Support for Iray Bridge requires that this feature is enabled. }

        See also: #get_encoded_names_enabled().
        """
        return _pymdlsdk._IMdl_configuration_set_encoded_names_enabled(self, value)

    def get_encoded_names_enabled(self):
        r"""
        Indicates whether encoded names are enabled.

        See also: #set_encoded_names_enabled().
        """
        return _pymdlsdk._IMdl_configuration_get_encoded_names_enabled(self)

# Register _IMdl_configuration in _pymdlsdk:
_pymdlsdk._IMdl_configuration_swigregister(_IMdl_configuration)

BAKE_ON_CPU = _pymdlsdk.BAKE_ON_CPU
r""" Use only the CPU for texture baking."""
BAKE_ON_GPU = _pymdlsdk.BAKE_ON_GPU
r""" Use only the GPU for texture baking."""
BAKE_ON_GPU_WITH_CPU_FALLBACK = _pymdlsdk.BAKE_ON_GPU_WITH_CPU_FALLBACK
r""" Prefer using the GPU for texture baking, use the CPU as fallback."""
BAKER_RESOURCE_FORCE_32_BIT = _pymdlsdk.BAKER_RESOURCE_FORCE_32_BIT
class Interface_declare_IMdl_distiller_api(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IMdl_distiller_api_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IMdl_distiller_api

# Register Interface_declare_IMdl_distiller_api in _pymdlsdk:
_pymdlsdk.Interface_declare_IMdl_distiller_api_swigregister(Interface_declare_IMdl_distiller_api)

def Interface_declare_IMdl_distiller_api_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IMdl_distiller_api_compare_iid(iid)

class _IMdl_distiller_api(Interface_declare_IMdl_distiller_api):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_target_count(self):
        r""" Returns the number of targets supported for distilling."""
        return _pymdlsdk._IMdl_distiller_api_get_target_count(self)

    def get_target_name(self, index):
        r"""
        Returns the ``index`` -th target name supported for distilling, or ``NULL`` if ``index`` is out
        of bounds.
        """
        return _pymdlsdk._IMdl_distiller_api_get_target_name(self, index)

    def distill_material_with_ret(self, material, target, distiller_options=None):
        r"""
        Distills a material.

        Material distilling refers to the translation of an arbitrary input material to a
        predefined target model.
        Supported target models are
        - diffuse
        - diffuse_glossy
        - specular_glossy
        - ue4
        - transmissive_pbr

        Depending on the structure of the input material and the
        complexity of the target model the resulting material can be as simple as a single bsdf
        or a set of bsdfs combined using layerers and mixes as illustrated in the table below
        using a pseudo-mdl notation.


             |diffuse
             |surface.scattering = diffuse_reflection_bsdf

                 geometry.normal = ()

           |

             |diffuse_glossy
             |surface.scattering = fresnel_layer(layer: simple_glossy_bsdf,
                 base: diffuse_reflection_bsdf)

                 geometry.normal = ()

          |

             |
                 surface.scattering = diffuse_reflection_bsdf

                 geometry.normal = ()

          |

             |
                 surface.scattering = simple_glossy_bsdf

                 geometry.normal = ()

          |

             |specular_glossy
             |surface.scattering = custom_curve_layer(layer: bsdf_glossy_ggx_vcavities,
                 base: diffuse_reflection_bsdf)

                 geometry.normal = ()

          |

             |
                 Any subset of the above construct, see ``diffuse_glossy``.

          |

             |ue4
             |surface.scattering = custom_curve_layer( // clearcoat

                   layer: bsdf_glossy_ggx_vcavities,

                   base: weighted_layer(

                     layer: normalized_mix(

                       bsdf_glossy_ggx_vcavities,

                       custom_curve_layer(

                         layer:
                 bsdf_glossy_ggx_vcavities,

                         base:
                 diffuse_reflection_bsdf

                       ),

                     ),

                     normal: () // under-clearcoat normal

                   ),

                   normal: () // clearcoat normal

                 )

          |

             |
                 A weighted_layer of any subset of the above construct
                 with an optional clearcoat on top.

          |

             |transmissive_pbr
             |surface.scattering = custom_curve_layer( // clearcoat

                   layer: bsdf_glossy_ggx_vcavities,

                   base: weighted_layer(

                     layer: normalized_mix(

                       bsdf_glossy_ggx_vcavities,

                       custom_curve_layer(

                         layer:
                 bsdf_glossy_ggx_vcavities,

                         base:
                 normalized_mix(


                 bsdf_glossy_ggx_vcavities(scatter_transmit)


                 diffuse_reflection_bsdf

                         ),

                       ),

                     ),

                     normal: () // under-clearcoat normal

                   ),

                   normal: () // clearcoat normal

                 )

          |

             |
                 A weighted_layer of any subset of the above construct
                 with an optional clearcoat on top.

          |


        :type material: :py:class:`ICompiled_material`
        :param material:           The material to be distilled.
        :type target: string
        :param target:             The target model. See #get_target_count() and #get_target_name().
        :type distiller_options: mi::IMap, optional
        :param distiller_options:  Options for the distiller. Supported options are:
                  - ``"top_layer_weight"`` of type ``mi::IFloat32``. This weight is given to the top
                    layer if a Fresnel layered BSDF is simplified to a single diffuse BSDF in the
                    'diffuse' distilling target. The base layer uses one minus this weight.
                    Default: 0.04.
                  - ``"layer_normal"`` of type ``mi::IBoolean``. If ``true``, it enables the aggregation
                    of the local normal maps of BSDF layerers to combine them with the global normal
                    map. Default: ``true``.

        :type errors: int, optional
        :param errors:             An optional pointer to an #mi::Sint32 to which an error code will
                                      be written. The error codes have the following meaning:
                                      -  0: Success.
                                      - -1: Invalid parameters (``NULL`` pointer).
                                      - -2: Invalid target model.
                                      - -3: Unspecified failure.
        :rtype: :py:class:`ICompiled_material`
        :return: The distilled material, or ``NULL`` in case of failure.
        """
        return _pymdlsdk._IMdl_distiller_api_distill_material_with_ret(self, material, target, distiller_options)

    def distill_material(self, material, target, distiller_options=None):
        r"""
        *Overload 1:*
        Distills a material.

        Material distilling refers to the translation of an arbitrary input material to a
        predefined target model.
        Supported target models are
        - diffuse
        - diffuse_glossy
        - specular_glossy
        - ue4
        - transmissive_pbr

        Depending on the structure of the input material and the
        complexity of the target model the resulting material can be as simple as a single bsdf
        or a set of bsdfs combined using layerers and mixes as illustrated in the table below
        using a pseudo-mdl notation.


             |diffuse
             |surface.scattering = diffuse_reflection_bsdf

                 geometry.normal = ()

           |

             |diffuse_glossy
             |surface.scattering = fresnel_layer(layer: simple_glossy_bsdf,
                 base: diffuse_reflection_bsdf)

                 geometry.normal = ()

          |

             |
                 surface.scattering = diffuse_reflection_bsdf

                 geometry.normal = ()

          |

             |
                 surface.scattering = simple_glossy_bsdf

                 geometry.normal = ()

          |

             |specular_glossy
             |surface.scattering = custom_curve_layer(layer: bsdf_glossy_ggx_vcavities,
                 base: diffuse_reflection_bsdf)

                 geometry.normal = ()

          |

             |
                 Any subset of the above construct, see ``diffuse_glossy``.

          |

             |ue4
             |surface.scattering = custom_curve_layer( // clearcoat

                   layer: bsdf_glossy_ggx_vcavities,

                   base: weighted_layer(

                     layer: normalized_mix(

                       bsdf_glossy_ggx_vcavities,

                       custom_curve_layer(

                         layer:
                 bsdf_glossy_ggx_vcavities,

                         base:
                 diffuse_reflection_bsdf

                       ),

                     ),

                     normal: () // under-clearcoat normal

                   ),

                   normal: () // clearcoat normal

                 )

          |

             |
                 A weighted_layer of any subset of the above construct
                 with an optional clearcoat on top.

          |

             |transmissive_pbr
             |surface.scattering = custom_curve_layer( // clearcoat

                   layer: bsdf_glossy_ggx_vcavities,

                   base: weighted_layer(

                     layer: normalized_mix(

                       bsdf_glossy_ggx_vcavities,

                       custom_curve_layer(

                         layer:
                 bsdf_glossy_ggx_vcavities,

                         base:
                 normalized_mix(


                 bsdf_glossy_ggx_vcavities(scatter_transmit)


                 diffuse_reflection_bsdf

                         ),

                       ),

                     ),

                     normal: () // under-clearcoat normal

                   ),

                   normal: () // clearcoat normal

                 )

          |

             |
                 A weighted_layer of any subset of the above construct
                 with an optional clearcoat on top.

          |


        :type material: :py:class:`ICompiled_material`
        :param material:           The material to be distilled.
        :type target: string
        :param target:             The target model. See #get_target_count() and #get_target_name().
        :type distiller_options: mi::IMap, optional
        :param distiller_options:  Options for the distiller. Supported options are:
                  - ``"top_layer_weight"`` of type ``mi::IFloat32``. This weight is given to the top
                    layer if a Fresnel layered BSDF is simplified to a single diffuse BSDF in the
                    'diffuse' distilling target. The base layer uses one minus this weight.
                    Default: 0.04.
                  - ``"layer_normal"`` of type ``mi::IBoolean``. If ``true``, it enables the aggregation
                    of the local normal maps of BSDF layerers to combine them with the global normal
                    map. Default: ``true``.

        :param errors:             An optional pointer to an #mi::Sint32 to which an error code will
                                      be written. The error codes have the following meaning:
                                      -  0: Success.
                                      - -1: Invalid parameters (``NULL`` pointer).
                                      - -2: Invalid target model.
                                      - -3: Unspecified failure.
        :rtype: :py:class:`ICompiled_material`
        :return: The distilled material, or ``NULL`` in case of failure.

        |

        *Overload 2:*
        Distills a material.

        Material distilling refers to the translation of an arbitrary input material to a
        predefined target model.
        Supported target models are
        - diffuse
        - diffuse_glossy
        - specular_glossy
        - ue4
        - transmissive_pbr

        Depending on the structure of the input material and the
        complexity of the target model the resulting material can be as simple as a single bsdf
        or a set of bsdfs combined using layerers and mixes as illustrated in the table below
        using a pseudo-mdl notation.


             |diffuse
             |surface.scattering = diffuse_reflection_bsdf

                 geometry.normal = ()

           |

             |diffuse_glossy
             |surface.scattering = fresnel_layer(layer: simple_glossy_bsdf,
                 base: diffuse_reflection_bsdf)

                 geometry.normal = ()

          |

             |
                 surface.scattering = diffuse_reflection_bsdf

                 geometry.normal = ()

          |

             |
                 surface.scattering = simple_glossy_bsdf

                 geometry.normal = ()

          |

             |specular_glossy
             |surface.scattering = custom_curve_layer(layer: bsdf_glossy_ggx_vcavities,
                 base: diffuse_reflection_bsdf)

                 geometry.normal = ()

          |

             |
                 Any subset of the above construct, see ``diffuse_glossy``.

          |

             |ue4
             |surface.scattering = custom_curve_layer( // clearcoat

                   layer: bsdf_glossy_ggx_vcavities,

                   base: weighted_layer(

                     layer: normalized_mix(

                       bsdf_glossy_ggx_vcavities,

                       custom_curve_layer(

                         layer:
                 bsdf_glossy_ggx_vcavities,

                         base:
                 diffuse_reflection_bsdf

                       ),

                     ),

                     normal: () // under-clearcoat normal

                   ),

                   normal: () // clearcoat normal

                 )

          |

             |
                 A weighted_layer of any subset of the above construct
                 with an optional clearcoat on top.

          |

             |transmissive_pbr
             |surface.scattering = custom_curve_layer( // clearcoat

                   layer: bsdf_glossy_ggx_vcavities,

                   base: weighted_layer(

                     layer: normalized_mix(

                       bsdf_glossy_ggx_vcavities,

                       custom_curve_layer(

                         layer:
                 bsdf_glossy_ggx_vcavities,

                         base:
                 normalized_mix(


                 bsdf_glossy_ggx_vcavities(scatter_transmit)


                 diffuse_reflection_bsdf

                         ),

                       ),

                     ),

                     normal: () // under-clearcoat normal

                   ),

                   normal: () // clearcoat normal

                 )

          |

             |
                 A weighted_layer of any subset of the above construct
                 with an optional clearcoat on top.

          |


        :type material: :py:class:`ICompiled_material`
        :param material:           The material to be distilled.
        :type target: string
        :param target:             The target model. See #get_target_count() and #get_target_name().
        :param distiller_options:  Options for the distiller. Supported options are:
                  - ``"top_layer_weight"`` of type ``mi::IFloat32``. This weight is given to the top
                    layer if a Fresnel layered BSDF is simplified to a single diffuse BSDF in the
                    'diffuse' distilling target. The base layer uses one minus this weight.
                    Default: 0.04.
                  - ``"layer_normal"`` of type ``mi::IBoolean``. If ``true``, it enables the aggregation
                    of the local normal maps of BSDF layerers to combine them with the global normal
                    map. Default: ``true``.

        :param errors:             An optional pointer to an #mi::Sint32 to which an error code will
                                      be written. The error codes have the following meaning:
                                      -  0: Success.
                                      - -1: Invalid parameters (``NULL`` pointer).
                                      - -2: Invalid target model.
                                      - -3: Unspecified failure.
        :rtype: :py:class:`ICompiled_material`
        :return: The distilled material, or ``NULL`` in case of failure.
        """
        return _pymdlsdk._IMdl_distiller_api_distill_material(self, material, target, distiller_options)

    def create_baker(self, *args):
        r"""
        Creates a baker for texture baking.

        :type material: :py:class:`ICompiled_material`
        :param material:           The material of which a subexpression is to be baked.
        :type path: string
        :param path:               The path from the material root to the expression that should be
                                      baked, e.g., ``"surface.scattering.tint"``.
        :type resource: int, optional
        :param resource:           The resource to be used for baking.
        :type gpu_device_id: int, optional
        :param gpu_device_id:      The device ID of the GPU to be used for baking (as identified by
                                      the CUDA runtime or driver API). Ignored if ``resource`` is
                                      #BAKE_ON_CPU.
        :rtype: :py:class:`IBaker`
        :return: A baker for the expression of the given material identified by
           ``path``, or ``NULL`` in case of failure. Note that returned baker
                                      depends on the transaction that was used to access the material.
        """
        return _pymdlsdk._IMdl_distiller_api_create_baker(self, *args)

# Register _IMdl_distiller_api in _pymdlsdk:
_pymdlsdk._IMdl_distiller_api_swigregister(_IMdl_distiller_api)

class Interface_declare_IBaker(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IBaker_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IBaker

# Register Interface_declare_IBaker in _pymdlsdk:
_pymdlsdk.Interface_declare_IBaker_swigregister(Interface_declare_IBaker)

def Interface_declare_IBaker_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IBaker_compare_iid(iid)

class _IBaker(Interface_declare_IBaker):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_pixel_type(self):
        r""" Returns the pixel type that matches the expression to be baked best."""
        return _pymdlsdk._IBaker_get_pixel_type(self)

    def is_uniform(self):
        r"""
        Indicates whether the expression to be baked is uniform or varying.

        Typically, varying expressions are baked into textures, and uniform expressions into
        constant. However, it is also possible to do it the other way round.
        """
        return _pymdlsdk._IBaker_is_uniform(self)

    def bake_texture(self, texture, samples=1):
        r"""
        Bakes the expression as texture.

        :type texture: :py:class:`ICanvas`
        :param texture:   The baked texture will be stored in this canvas. If the pixel type of
           ``canvas`` does not match the pixel type of the expression to be baked (as
                             indicated by #get_pixel_type()), then the pixel data is converted as
                             described in #mi::neuraylib::IImage_api::convert().
        :type samples: int, optional
        :param samples:   The number of samples (per pixel).
        :rtype: int
        :return: 
                             -  0: Success.
                             - -1: Invalid parameters (``NULL`` pointer).
                             - -2: The transaction that is bound to this baker is no longer open.
                             - -3: The execution of the MDL code failed.
        """
        return _pymdlsdk._IBaker_bake_texture(self, texture, samples)

    def bake_constant(self, constant, samples=1):
        r"""
        Bakes the expression as constant.

        :type constant: :py:class:`IData`
        :param constant:  An instance of #mi::IData of suitable type such that the baked constant can
                             be stored in this argument. For pixel types ``"Float32"`` and
           ``"Float32<3>"`` the type name of this argument needs to match the pixel type.
                             For pixel type ``"Rgb_fp"`` this argument needs to have the type name
           ``"Color"``.
        :type samples: int, optional
        :param samples:   The (total) number of samples.
        :rtype: int
        :return: 
                             -  0: Success.
                             - -1: Invalid parameters (``NULL`` pointer).
                             - -2: The transaction that is bound to this baker is no longer open.
                             - -3: The execution of the MDL code failed.
                             - -4: The type of ``constant`` does not match the pixel type corresponding
                                    to the expression to be baked.
        """
        return _pymdlsdk._IBaker_bake_constant(self, constant, samples)

# Register _IBaker in _pymdlsdk:
_pymdlsdk._IBaker_swigregister(_IBaker)

class Interface_declare_IMessage(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IMessage_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IMessage

# Register Interface_declare_IMessage in _pymdlsdk:
_pymdlsdk.Interface_declare_IMessage_swigregister(Interface_declare_IMessage)

def Interface_declare_IMessage_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IMessage_compare_iid(iid)

class _IMessage(Interface_declare_IMessage):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    MSG_COMILER_CORE = _pymdlsdk._IMessage_MSG_COMILER_CORE
    r""" MDL Core compiler message."""
    MSG_COMILER_BACKEND = _pymdlsdk._IMessage_MSG_COMILER_BACKEND
    r""" MDL Core compiler backend message."""
    MSG_COMPILER_DAG = _pymdlsdk._IMessage_MSG_COMPILER_DAG
    r""" MDL Core DAG generator message."""
    MSG_COMPILER_ARCHIVE_TOOL = _pymdlsdk._IMessage_MSG_COMPILER_ARCHIVE_TOOL
    r""" MDL Core archive tool message."""
    MSG_IMP_EXP = _pymdlsdk._IMessage_MSG_IMP_EXP
    r""" MDL import/exporter message."""
    MSG_INTEGRATION = _pymdlsdk._IMessage_MSG_INTEGRATION
    r""" MDL integration message."""
    MSG_UNCATEGORIZED = _pymdlsdk._IMessage_MSG_UNCATEGORIZED
    r""" Uncategorized messages do not have a code."""
    MSG_FORCE_32_BIT = _pymdlsdk._IMessage_MSG_FORCE_32_BIT

    def get_kind(self):
        r""" Returns the kind of message."""
        return _pymdlsdk._IMessage_get_kind(self)

    def get_severity(self):
        r""" Returns the severity of the message."""
        return _pymdlsdk._IMessage_get_severity(self)

    def get_string(self):
        r""" Returns the message string."""
        return _pymdlsdk._IMessage_get_string(self)

    def get_code(self):
        r""" Returns a unique identifier for the message."""
        return _pymdlsdk._IMessage_get_code(self)

    def get_notes_count(self):
        r"""
        Returns the number of notes associated with the message

        Notes can be used to describe an error message further or add additional details.
        """
        return _pymdlsdk._IMessage_get_notes_count(self)

    def get_note(self, index):
        r""" Returns the note at index or ``NULL``, if no such index exists."""
        return _pymdlsdk._IMessage_get_note(self, index)

# Register _IMessage in _pymdlsdk:
_pymdlsdk._IMessage_swigregister(_IMessage)

class Interface_declare_IMdl_execution_context(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IMdl_execution_context_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IMdl_execution_context

# Register Interface_declare_IMdl_execution_context in _pymdlsdk:
_pymdlsdk.Interface_declare_IMdl_execution_context_swigregister(Interface_declare_IMdl_execution_context)

def Interface_declare_IMdl_execution_context_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IMdl_execution_context_compare_iid(iid)

class _IMdl_execution_context(Interface_declare_IMdl_execution_context):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_messages_count(self):
        r""" Returns the number of messages."""
        return _pymdlsdk._IMdl_execution_context_get_messages_count(self)

    def get_error_messages_count(self):
        r""" Returns the number of error messages."""
        return _pymdlsdk._IMdl_execution_context_get_error_messages_count(self)

    def get_message(self, index):
        r""" Returns the message at index or ``NULL``, if no such index exists."""
        return _pymdlsdk._IMdl_execution_context_get_message(self, index)

    def get_error_message(self, index):
        r""" Returns the error message at index or ``NULL``, if no such index exists."""
        return _pymdlsdk._IMdl_execution_context_get_error_message(self, index)

    def clear_messages(self):
        r""" Clears all messages."""
        return _pymdlsdk._IMdl_execution_context_clear_messages(self)

    def add_message(self, kind, severity, code, message):
        r""" Adds a message."""
        return _pymdlsdk._IMdl_execution_context_add_message(self, kind, severity, code, message)

    def get_option_count(self):
        r""" Returns the number of supported options."""
        return _pymdlsdk._IMdl_execution_context_get_option_count(self)

    def get_option_name(self, index):
        r""" Returns the option name at index."""
        return _pymdlsdk._IMdl_execution_context_get_option_name(self, index)

    def get_option_type(self, name):
        r""" Returns the option type name at index."""
        return _pymdlsdk._IMdl_execution_context_get_option_type(self, name)

    def get_option(self, *args):
        r"""
        *Overload 1:*
        Returns a string option.

        :type name: string
        :param name:          The name of the option.
        :type value: string, out
        :param value:    The value of the option.
        :rtype: int
        :return: 
                                 -  0: Success.
                                 - -1: Invalid option name.
                                 - -2: The option type does not match the value type.

        |

        *Overload 2:*
        Returns an int option.

        :type name: string
        :param name:          The name of the option.
        :type value: int, out
        :param value:    The value of the option.
        :rtype: int
        :return: 
                                 -  0: Success.
                                 - -1: Invalid option name.
                                 - -2: The option type does not match the value type.

        |

        *Overload 3:*
        Returns a float option.

        :type name: string
        :param name:          The name of the option.
        :type value: float, out
        :param value:    The value of the option.
        :rtype: int
        :return: 
                                 -  0: Success.
                                 - -1: Invalid option name.
                                 - -2: The option type does not match the value type.

        |

        *Overload 4:*
        Returns a bool option.

        :type name: string
        :param name:          The name of the option.
        :type value: boolean, out
        :param value:    The value of the option.
        :rtype: int
        :return: 
                                 -  0: Success.
                                 - -1: Invalid option name.
                                 - -2: The option type does not match the value type.

        |

        *Overload 5:*
        Returns an interface option.

        :type name: string
        :param name:          The name of the option.
        :type value: mi::base::IInterface, out
        :param value:    The value of the option.
        :rtype: int
        :return: 
                                 -  0: Success.
                                 - -1: Invalid option name.
                                 - -2: The option type does not match the value type.
        """
        return _pymdlsdk._IMdl_execution_context_get_option(self, *args)

    def set_option(self, *args):
        r"""
        *Overload 1:*
        Sets a string option.

        :type name: string
        :param name:     The name of the option.
        :type value: string
        :param value:    The value of the option.
        :rtype: int
        :return: 
                            -  0: Success.
                            - -1: Invalid option name.
                            - -2: The option type does not match the value type.

        |

        *Overload 2:*
        Sets an int option.

        :type name: string
        :param name:     The name of the option.
        :type value: int
        :param value:    The value of the option.
        :rtype: int
        :return: 
                            -  0: Success.
                            - -1: Invalid option name.
                            - -2: The option type does not match the value type.

        |

        *Overload 3:*
        Sets a float option.

        :type name: string
        :param name:     The name of the option.
        :type value: float
        :param value:    The value of the option.
        :rtype: int
        :return: 
                            -  0: Success.
                            - -1: Invalid option name.
                            - -2: The option type does not match the value type.

        |

        *Overload 4:*
        Sets a bool option.

        :type name: string
        :param name:     The name of the option.
        :type value: boolean
        :param value:    The value of the option.
        :rtype: int
        :return: 
                            -  0: Success.
                            - -1: Invalid option name.
                            - -2: The option type does not match the value type.
                            - -3: The value is invalid in the context of the option.

        |

        *Overload 5:*
        Sets an interface option.

        :type name: string
        :param name:     The name of the option.
        :type value: mi::base::IInterface
        :param value:    The value of the option.
        :rtype: int
        :return: 
                            -  0: Success.
                            - -1: Invalid option name.
                            - -2: The option type does not match the value type.
                            - -3: The value is invalid in the context of the option.
        """
        return _pymdlsdk._IMdl_execution_context_set_option(self, *args)

# Register _IMdl_execution_context in _pymdlsdk:
_pymdlsdk._IMdl_execution_context_swigregister(_IMdl_execution_context)

class Interface_declare_IMdl_factory(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IMdl_factory_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IMdl_factory

# Register Interface_declare_IMdl_factory in _pymdlsdk:
_pymdlsdk.Interface_declare_IMdl_factory_swigregister(Interface_declare_IMdl_factory)

def Interface_declare_IMdl_factory_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IMdl_factory_compare_iid(iid)

class _IMdl_factory(Interface_declare_IMdl_factory):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def create_type_factory(self, transaction):
        r""" Returns an MDL type factory for the given transaction."""
        return _pymdlsdk._IMdl_factory_create_type_factory(self, transaction)

    def create_value_factory(self, transaction):
        r""" Returns an MDL value factory for the given transaction."""
        return _pymdlsdk._IMdl_factory_create_value_factory(self, transaction)

    def create_expression_factory(self, transaction):
        r""" Returns an MDL expression factory for the given transaction."""
        return _pymdlsdk._IMdl_factory_create_expression_factory(self, transaction)

    def create_execution_context(self):
        r""" Creates an execution context."""
        return _pymdlsdk._IMdl_factory_create_execution_context(self)

    def clone(self, context):
        r"""
        Clones an execution context.

        Creates a new execution context if ``context`` is NULL (as in #create_execution_context()).
        There is *no* deep copy of option values of type #mi::base::IInterface, they are shared
        by both instances.

        Useful to change options temporarily.
        """
        return _pymdlsdk._IMdl_factory_clone(self, context)

    def create_texture_with_ret(self, transaction, file_path, shape, gamma, selector, shared):
        r"""
        Creates a value referencing a texture identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the texture. The MDL
                                 search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shape: int
        :param shape:         The value that is returned by
                                 #mi::neuraylib::IType_texture::get_shape() on the type corresponding
                                 to the return value.
        :type gamma: float
        :param gamma:         The value that is returned by #mi::neuraylib::ITexture::get_gamma()
                                 on the DB element referenced by the return value.
        :type selector: string
        :param selector:      The selector, or ``NULL``. See section 2.3.1 in ['MDLLS]' for
                                 details.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB elements for that texture
                                 if it has already been loaded, or if you want to create new DB elements
                                 in all cases. Note that sharing is based on the location where the
                                 texture is finally located and includes sharing with instances that
                                 have not explicitly been loaded via this method, e.g., textures in
                                 defaults.
        :type errors: int, optional
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path, or no suitable image
                                       plugin available.
        :rtype: :py:class:`IValue_texture`
        :return: The value referencing the texture, or ``NULL`` in case of failure.

        See also: #mi::neuraylib::IImage::reset_file() if you are given a plain filename instead of an
             MDL file path.
        """
        return _pymdlsdk._IMdl_factory_create_texture_with_ret(self, transaction, file_path, shape, gamma, selector, shared)

    def create_texture(self, transaction, file_path, shape, gamma, selector, shared):
        r"""
        Creates a value referencing a texture identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the texture. The MDL
                                 search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shape: int
        :param shape:         The value that is returned by
                                 #mi::neuraylib::IType_texture::get_shape() on the type corresponding
                                 to the return value.
        :type gamma: float
        :param gamma:         The value that is returned by #mi::neuraylib::ITexture::get_gamma()
                                 on the DB element referenced by the return value.
        :type selector: string
        :param selector:      The selector, or ``NULL``. See section 2.3.1 in ['MDLLS]' for
                                 details.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB elements for that texture
                                 if it has already been loaded, or if you want to create new DB elements
                                 in all cases. Note that sharing is based on the location where the
                                 texture is finally located and includes sharing with instances that
                                 have not explicitly been loaded via this method, e.g., textures in
                                 defaults.
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path, or no suitable image
                                       plugin available.
        :rtype: :py:class:`IValue_texture`
        :return: The value referencing the texture, or ``NULL`` in case of failure.

        See also: #mi::neuraylib::IImage::reset_file() if you are given a plain filename instead of an
             MDL file path.
        """
        return _pymdlsdk._IMdl_factory_create_texture(self, transaction, file_path, shape, gamma, selector, shared)

    def create_light_profile_with_ret(self, transaction, file_path, shared):
        r"""
        Creates a value referencing a light profile identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the light profile. The MDL
                                 search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB element for that light
                                 profile if it has already been loaded, or if you want to create a new
                                 DB element in all cases. Note that sharing is based on the location
                                 where the light profile is finally located and includes sharing with
                                 instances that have not explicitly been loaded via this method, e.g.,
                                 light profiles in defaults.
        :type errors: int, optional
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path.
        :rtype: :py:class:`IValue_light_profile`
        :return: The value referencing the light profile, or ``NULL`` in case of failure.

        See also: #mi::neuraylib::ILightprofile::reset_file() if you are given a plain filename instead
             of an MDL file path.
        """
        return _pymdlsdk._IMdl_factory_create_light_profile_with_ret(self, transaction, file_path, shared)

    def create_light_profile(self, transaction, file_path, shared):
        r"""
        Creates a value referencing a light profile identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the light profile. The MDL
                                 search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB element for that light
                                 profile if it has already been loaded, or if you want to create a new
                                 DB element in all cases. Note that sharing is based on the location
                                 where the light profile is finally located and includes sharing with
                                 instances that have not explicitly been loaded via this method, e.g.,
                                 light profiles in defaults.
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path.
        :rtype: :py:class:`IValue_light_profile`
        :return: The value referencing the light profile, or ``NULL`` in case of failure.

        See also: #mi::neuraylib::ILightprofile::reset_file() if you are given a plain filename instead
             of an MDL file path.
        """
        return _pymdlsdk._IMdl_factory_create_light_profile(self, transaction, file_path, shared)

    def create_bsdf_measurement_with_ret(self, transaction, file_path, shared):
        r"""
        Creates a value referencing a BSDF measurement identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the BSDF measurement. The
                                 MDL search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB element for that BSDF
                                 measurement if it has already been loaded, or if you want to create a
                                 new DB element in all cases. Note that sharing is based on the location
                                 where the BSDF measurement is finally located and includes sharing with
                                 instances that have not explicitly been loaded via this method, e.g.,
                                 BSDF measurements in defaults.
        :type errors: int, optional
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path.
        :rtype: :py:class:`IValue_bsdf_measurement`
        :return: The value referencing the BSDF measurement, or ``NULL`` in case of
                                 failure.

        See also: #mi::neuraylib::IBsdf_measurement::reset_file() if you are given a plain filename
             instead of an MDL file path.
        """
        return _pymdlsdk._IMdl_factory_create_bsdf_measurement_with_ret(self, transaction, file_path, shared)

    def create_bsdf_measurement(self, transaction, file_path, shared):
        r"""
        Creates a value referencing a BSDF measurement identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the BSDF measurement. The
                                 MDL search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB element for that BSDF
                                 measurement if it has already been loaded, or if you want to create a
                                 new DB element in all cases. Note that sharing is based on the location
                                 where the BSDF measurement is finally located and includes sharing with
                                 instances that have not explicitly been loaded via this method, e.g.,
                                 BSDF measurements in defaults.
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path.
        :rtype: :py:class:`IValue_bsdf_measurement`
        :return: The value referencing the BSDF measurement, or ``NULL`` in case of
                                 failure.

        See also: #mi::neuraylib::IBsdf_measurement::reset_file() if you are given a plain filename
             instead of an MDL file path.
        """
        return _pymdlsdk._IMdl_factory_create_bsdf_measurement(self, transaction, file_path, shared)

    def create_module_builder(self, transaction, module_name, min_module_version, max_module_version, context):
        r"""
        Creates a module builder for a given module.

        :type transaction: :py:class:`ITransaction`
        :param transaction:          The transaction to be used.
        :type module_name: string
        :param module_name:          The DB name of the MDL module to build. If there is no such
                                        module, then an empty module with this name and
           ``min_module_version`` is created. Otherwise, the existing module
                                        is edited. Builtin modules or MDLE modules cannot be built or
                                        edited.
        :type min_module_version: int
        :param min_module_version:   The initial MDL version of the new module. Ignored if the
                                        module exists already.
        :type max_module_version: int
        :param max_module_version:   The maximal desired MDL version of the module. If higher than
                                        the current MDL version of the module, then the module builder
                                        will upgrade the MDL version as necessary to handle requests
                                        requiring newer features.
        :type context: :py:class:`IMdl_execution_context`
        :param context:              An execution context which can be queried for detailed error
                                        messages after the operation has finished. Can be ``NULL``.
        :rtype: :py:class:`IMdl_module_builder`
        :return: The module builder for the given module, or ``NULL`` in
                                        case of errors.
        """
        return _pymdlsdk._IMdl_factory_create_module_builder(self, transaction, module_name, min_module_version, max_module_version, context)

    def create_module_transformer(self, transaction, module_name, context):
        r"""
        Creates a module transformer for a given module.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type module_name: string
        :param module_name:   The DB name of the MDL module to transform. Builtin modules cannot be
                                 transformed.
        :type context: :py:class:`IMdl_execution_context`
        :param context:       An execution context which can be queried for detailed error messages
                                 after the operation has finished. Can be ``NULL``.
        :rtype: mi::neuraylib::IMdl_module_transformer
        :return: The module transformer for the given module, or ``NULL`` in case of
                                 errors.
        """
        return _pymdlsdk._IMdl_factory_create_module_transformer(self, transaction, module_name, context)

    def get_db_module_name(self, mdl_name):
        r"""
        Returns the DB name for the MDL name of a module (or file path for MDLE modules).

        For example, given ``"::state"``, the method returns ``"mdl::state"``.

        Notes: This method does not check for existence of the corresponding DB element, nor does it
              check that the input is a valid module name.

        Usage of this method is strongly recommended instead of manually prepending ``"mdl"``,
              since (a) the mapping is more complicated than that, e.g., for MDLE modules, and (b)
              the mapping might change in the future.

        :type mdl_name: string
        :param mdl_name:      The MDL name of the module (non-MDLE and MDLE module), or the file path
                                 of an MDLE module.
        :rtype: :py:class:`IString`
        :return: The DB name of that module, or ``NULL`` if ``mdl_name`` is invalid.
        """
        return _pymdlsdk._IMdl_factory_get_db_module_name(self, mdl_name)

    def get_db_definition_name(self, mdl_name):
        r"""
        Returns the DB name for the MDL name of an material or function definition.

        For example, given ``"::state::normal()"``, the method returns ``"mdl::state::normal()"``.

        Notes: This method does not check for existence of the corresponding DB element, nor does it
              check that the input is a valid material or definition name.

        Usage of this method is strongly recommended instead of manually prepending ``"mdl"``,
              since (a) the mapping is more complicated than that, e.g., for MDLE modules, and (b)
              the mapping might change in the future.

        :type mdl_name: string
        :param mdl_name:      The MDL name of the material or function definition.
        :rtype: :py:class:`IString`
        :return: The DB name of that material or function definition, or ``NULL`` if
                                 ``mdl_name`` is invalid.
        """
        return _pymdlsdk._IMdl_factory_get_db_definition_name(self, mdl_name)

    def analyze_uniform(self, transaction, root_name, root_uniform, query_expr, query_result, error_path, context):
        r"""
         Analyzes whether an expression graph violates the uniform constraints.

         Notes: This method can be used to check already created graphs, but it can also be used to
               check whether a hypothetical connection would observe the uniform constraints: First,
               invoke the method with the root of the existing graph, ``root_uniform`` set to
        ``false`` (at least for materials), and ``query_expr`` set to the graph node to be
               replaced. If the call returns with ``query_result`` set to ``false`` (and no errors in
               the context), then any (valid) subgraph can be connected. Otherwise, invoke the
               method again with the root of the to-be-connected subgraph, ``root_uniform`` set to
        ``true``, and ``query_expr`` set to ``NULL``. If there are no errors, then the subgraph
               can be connected.

         Make sure that ``query_expr`` (if not ``NULL)`` can be reached from ``root_name``,
               otherwise ``query_result`` is always ``false``. In particular, arguments passed during
               call creation (or later for argument changes) are cloned, and the expression that is
               part of the graph is different from the one that was used to construct the graph
               (equal, but not identical).

         :type transaction: :py:class:`ITransaction`
         :param transaction:             The transaction to be used.
         :type root_name: string
         :param root_name:               DB name of the root node of the graph (material instance or
                                            function call).
         :type root_uniform: boolean
         :param root_uniform:            Indicates whether the root node should be uniform.
         :type query_expr: :py:class:`IExpression`
         :param query_expr:              A node of the call graph for which the uniform property is
                                            to be queried. This expression is *only* used to identify
                                            the corresponding node in the graph, i.e., it even makes
                                            sense to pass constant expressions (which by themselves are
                                            always uniform) to determine whether a to-be-connected call
                                            expression has to be uniform. Can be ``NULL``.
         :type query_result: boolean, out
         :param query_result:       Indicates whether ``query_expr`` needs to be uniform (or
                                            ``false`` if ``query_expr`` is ``NULL``, or in case of errors).
         :type error_path: :py:class:`IString`, out
         :param error_path:         A path to a node of the graph that violates the uniform
                                            constraints, or the empty string if there is no such node
                                            (or in case of errors). Such violations are also reported
                                            via ``context``. Can be ``NULL``.
         :type context: :py:class:`IMdl_execution_context`
         :param context:                 The execution context can be used to pass options and to
                                            retrieve error and/or warning messages. Can be ``NULL``.
        """
        return _pymdlsdk._IMdl_factory_analyze_uniform(self, transaction, root_name, root_uniform, query_expr, query_result, error_path, context)

    def decode_name(self, name):
        r"""
        Decodes a DB or MDL name.

        :type name: string
        :param name:   The encoded DB or MDL name to be decoded.
        :rtype: :py:class:`IString`
        :return: The decoded DB or MDL name, or ``NULL`` if ``name`` is ``NULL``. Returns the
                          input string if encoded names are disabled.

        Notes: This method should only be used for display purposes. Do *not* use the returned
              name to identify functions or materials since this representation is ambiguous. For
              modules, it is possible to re-encode their name without loss of information, see
              #encode_module_name(). This is *not* possible for names of function or material
              definitions.

        This method does not require the corresponding module to be loaded. The method does
              not check whether the given name is valid, nor whether it is defined in the
              corresponding module.
        """
        return _pymdlsdk._IMdl_factory_decode_name(self, name)

    def encode_module_name(self, name):
        r"""
        Encodes a DB or MDL module name.

        :type name: string
        :param name:    The decoded DB or MDL module name to be encoded.
        :rtype: :py:class:`IString`
        :return: The encoded DB or MDL module name, or ``NULL`` if ``name`` is ``NULL``. Returns
                           the input string if encoded names are disabled.

        Notes: This method does not require the corresponding module to be loaded. The method does
              not check whether the given name is valid.

        See also: #mi::neuraylib::IMdl_factory::encode_function_definition_name(),
             #mi::neuraylib::IMdl_factory::encode_type_name()
        """
        return _pymdlsdk._IMdl_factory_encode_module_name(self, name)

    def encode_function_definition_name(self, name, parameter_types):
        r"""
        Encodes a DB or MDL function or material definition name.

        :type name: string
        :param name:             The decoded DB or MDL name of a function or material definition
                                    *without* signature.
        :type parameter_types: :py:class:`IArray`
        :param parameter_types:  A static or dynamic array with elements of type #mi::IString
                                    representing decoded positional parameter type names. The value
                                    ``NULL`` can be used for functions or materials without parameters
                                    (treated like an empty array).
        :rtype: :py:class:`IString`
        :return: The encoded function or material definition name, or ``NULL`` if
                                    ``name`` or one of the array elements is ``NULL``. If encoded names
                                    are disabled, then the individual components of the name are joined
                                    by parentheses and commas without further encoding.

        Notes: This method does not require the corresponding module to be loaded. The method does
              not check whether the given name is valid, nor whether it is defined in the
              corresponding module.

        See also: #mi::neuraylib::IMdl_factory::encode_module_name(),
             #mi::neuraylib::IMdl_factory::encode_type_name()
        """
        return _pymdlsdk._IMdl_factory_encode_function_definition_name(self, name, parameter_types)

    def encode_type_name(self, name):
        r"""
        Encodes an MDL type name.

        :type name: string
        :param name:             The decoded MDL name of a type.
        :rtype: :py:class:`IString`
        :return: The encoded MDL name of the type, or ``NULL`` if ``name`` is ``NULL``.
                                    Returns the input string if encoded names are disabled

        Notes: This method does not require the corresponding module to be loaded. The method does
              not check whether the given name is valid, nor whether it is defined in the
              corresponding module.

        See also: #mi::neuraylib::IMdl_factory::encode_function_definition_name(),
             #mi::neuraylib::IMdl_factory::encode_module_name()
        """
        return _pymdlsdk._IMdl_factory_encode_type_name(self, name)

    def deprecated_create_variants(self, transaction, module_name, variant_data):
        return _pymdlsdk._IMdl_factory_deprecated_create_variants(self, transaction, module_name, variant_data)

    def deprecated_create_materials(self, *args):
        return _pymdlsdk._IMdl_factory_deprecated_create_materials(self, *args)

# Register _IMdl_factory in _pymdlsdk:
_pymdlsdk._IMdl_factory_swigregister(_IMdl_factory)

class Interface_declare_IMdl_impexp_api(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IMdl_impexp_api_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IMdl_impexp_api

# Register Interface_declare_IMdl_impexp_api in _pymdlsdk:
_pymdlsdk.Interface_declare_IMdl_impexp_api_swigregister(Interface_declare_IMdl_impexp_api)

def Interface_declare_IMdl_impexp_api_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IMdl_impexp_api_compare_iid(iid)

class _IMdl_impexp_api(Interface_declare_IMdl_impexp_api):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def load_module(self, transaction, argument, context=None):
        r"""
        Loads an MDL module from disk (or a builtin module) into the database.

        The module is located on disk according to the module search paths
        (see #mi::neuraylib::IMdl_configuration::add_mdl_path()), loaded, and compiled.
        If successful, the method creates DB elements for the module and all
        its imported modules, as well as for all material and function definitions contained in
        these modules.

        The method can also be used for builtin modules for which the first step, locating the
        module on disk, is skipped.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type argument: string
        :param argument:      The MDL name of the module (for non-MDLE modules), or an MDLE file
                                 path (absolute or relative to the current working directory).
        :type context: :py:class:`IMdl_execution_context`, optional
        :param context:       The execution context can be used to pass options to control the
                                 behavior of the MDL compiler. The following options are supported
                                 by this operation:
                                 - string "internal_space" = "coordinate_object"|"coordinate_world"
                                   (default = "coordinate_world")
                                 .
                                 During module loading, compiler messages
                                 like errors or warnings are stored in the context. Can be ``NULL``.
        :rtype: int
        :return: 
                                 -  1: Success (module exists already, loading from file was skipped).
                                 -  0: Success (module was actually loaded from file or is a builtin
                                       module).
                                 - -1: The MDL module name/MDLE file path ``argument`` is
                                       invalid or a ``NULL`` pointer.
                                 - -2: Failed to find or to compile the module ``argument``.
                                 - -3: The DB name for an imported module is already in use but is not
                                       an MDL module, or the DB name for a definition in this module is
                                       already in use.
                                 - -4: Initialization of an imported module failed.

        See also: #mi::neuraylib::IMdl_impexp_api::get_mdl_module_name()
        """
        return _pymdlsdk._IMdl_impexp_api_load_module(self, transaction, argument, context)

    def load_module_from_string(self, transaction, module_name, module_source, context=None):
        r"""
        Loads an MDL module from memory into the database.

        The provided module source is compiled. If successful, the method creates DB elements for
        the module and all its imported modules, as well as for all material and function
        definitions contained in these modules.

        Notes: String-based module have limitations compared to regular modules loaded from disk:
        - no support for resources, and
        - string-based modules referenced in an import statement need to be loaded explicitly
          upfront (no automatic recursive loading as for file-based modules).

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type module_name: string
        :param module_name:   The MDL name of the module.
        :type module_source: string
        :param module_source: The MDL source code of the module.
        :type context: :py:class:`IMdl_execution_context`, optional
        :param context:       The execution context can be used to pass options to control the
                                 behavior of the MDL compiler. The following options are supported
                                 by this operation:
                                 - string "internal_space" = "coordinate_object"|"coordinate_world"
                                   (default = "coordinate_world")
                                 .
                                 During module loading, compiler messages
                                 like errors or warnings are stored in the context. Can be ``NULL``.
        :rtype: int
        :return: 
                                 -  1: Success (module exists already, creating from ``module_source``
                                       was skipped).
                                 -  0: Success (module was actually created from ``module_source)``.
                                 - -1: The module name ``module_name`` is invalid, or ``module_name`` or
                                       ``module_source`` is a ``NULL`` pointer.
                                 - -2: Shadows a file-based module or failed to compile the module
           ``module_name``.
                                 - -3: The DB name for an imported module is already in use but is not
                                       an MDL module, or the DB name for a definition in this module is
                                       already in use.
                                 - -4: Initialization of an imported module failed.

        See also: #mi::neuraylib::IMdl_impexp_api::get_mdl_module_name()
        """
        return _pymdlsdk._IMdl_impexp_api_load_module_from_string(self, transaction, module_name, module_source, context)

    def export_module(self, transaction, module_name, filename, context=None):
        r"""
        Exports an MDL module from the database to disk.

        The following options are supported:
        - ``"bundle_resources"`` of type bool: If ``true``, referenced resources are exported
          into the same directory as the module, even if they can be found via the module search
          path. Default: ``false``.

        :type transaction: :py:class:`ITransaction`
        :param transaction:       The transaction to be used.
        :type module_name: string
        :param module_name:       The DB name of the MDL module to export.
        :type filename: string
        :param filename:          The name of the file to be used for the export.
        :type context: :py:class:`IMdl_execution_context`, optional
        :param context:           The execution context can be used to pass options to control the
                                     behavior of the MDL compiler. During module loading, compiler
                                     messages like errors or warnings are stored in the context.
                                     Can be ``NULL``.
        :rtype: int
        :return: 
                                     -     0: Success.
                                     -    -1: Invalid parameters (``NULL`` pointer).
                                     -    -2: Failed to open ``filename`` for write operations.
                                     - -6002: There is no MDL module in the database of the given name.
                                     - -6003: The export failed for unknown reasons.
                                     - -6004: The MDL module can not be exported since it is a builtin
                                              module.
                                     - -6005: The MDL module can not be exported since ``filename`` does
                                              not result in a valid MDL identifier.
                                     - -6010: Incorrect type for a referenced resource.
                                     - -6013: The export of a file-based resource failed.
                                     - -6014: The export of a memory-based resource failed.
                                     - -6016: The export of an archive-based resource failed.
        """
        return _pymdlsdk._IMdl_impexp_api_export_module(self, transaction, module_name, filename, context)

    def export_module_to_string(self, transaction, module_name, exported_module, context=None):
        r"""
        Exports an MDL module from the database to string.

        Notes: See #load_module_from_string() for limitations of string-based modules.

        :type transaction: :py:class:`ITransaction`
        :param transaction:       The transaction to be used.
        :type module_name: string
        :param module_name:       The DB name of the MDL module to export.
        :type exported_module: :py:class:`IString`
        :param exported_module:   The exported module source code is written to this string.
        :type context: :py:class:`IMdl_execution_context`, optional
        :param context:           The execution context can be used to pass options to control the
                                     behavior of the MDL compiler. During module loading, compiler
                                     messages like errors or warnings are stored in the context.
                                     Can be ``NULL``.
        :rtype: int
        :return: 
                                     -     0: Success.
                                     -    -1: Invalid parameters (``NULL`` pointer).
                                     - -6002: There is no MDL module in the database of the given name.
                                     - -6003: The export failed for unknown reasons.
                                     - -6004: The MDL module can not be exported since it is a builtin
                                              module.
                                     - -6006: The option ``bundle_resources`` is not supported for
                                              string-based exports.
                                     - -6010: Incorrect type for a referenced resource.
                                     - -6011: The export of file-based resources is not supported for
                                              string-based exports.
                                     - -6012: The export of memory-based resources is not supported for
                                              string-based exports.
                                     - -6013: The export of a file-based resource failed.
                                     - -6014: The export of a memory-based resource failed.
                                     - -6015: The export of archive-based resources is not supported for
                                              string-based exports.
                                     - -6016: The export of an archive-based resource failed.
        """
        return _pymdlsdk._IMdl_impexp_api_export_module_to_string(self, transaction, module_name, exported_module, context)

    def export_canvas(self, filename, canvas, quality=100, force_default_gamma=False):
        r"""
        Exports a canvas to a file on disk.

        If the image plugin that is selected for the export based on the ``filename`` parameter is
        not capable of handling the pixel type of ``canvas``, the canvas is internally converted into
        one of the pixel types supported by that image plugin for export. If the image plugin
        supports multiple pixel types for export, the "best" of them (w.r.t. the pixel type of the
        canvas) is chosen.

        The "best" pixel type is determined by attempting to apply the following conversions in the
        given order to the pixel type of the canvas:
        - use an equivalent pixel type (``"Color"`` instead of ``"Float32<4>"`` and vice versa,
          similar for ``"Rgb_fp"`` / ``"Float32<3>"`` and ``"Rgba"`` / ``"Sint32"``),
        - add an alpha channel (if not already present),
        - increase bits per channel (smaller increase preferred),
        - add additional channels (if possible),
        - decrease bits per channel (smaller decrease preferred), and
        - drop one or more channels.

        :type filename: string
        :param filename:              The file name of the resource to export the canvas to. The
                                         ending of the file name determines the image format, e.g.,
                                         ``".jpg"``. Note that support for a given image format requires
                                         an image plugin capable of handling that format.
        :type canvas: :py:class:`ICanvas`
        :param canvas:                The canvas to export.
        :type quality: int, optional
        :param quality:               The compression quality is an integer in the range from 0 to
                                         100, where 0 is the lowest quality, and 100 is the highest
                                         quality.
        :type force_default_gamma: boolean, optional
        :param force_default_gamma:   If enabled, adjusts the gamma value of the exported pixel data
                                         according to the pixel type chosen for export (1.0 for HDR
                                         pixel types, 2.2 for LDR pixel types).
        :rtype: int
        :return: 
                                        -  0: Success.
                                        - -1: Invalid file name.
                                        - -2: Invalid canvas.
                                        - -3: Invalid quality.
                                        - -4: Unspecified failure.
        """
        return _pymdlsdk._IMdl_impexp_api_export_canvas(self, filename, canvas, quality, force_default_gamma)

    def export_lightprofile(self, filename, lightprofile):
        r"""
        Exports a light profile to disk.

        :type filename: string
        :param filename:          The file name of the resource to export the light profile to.
        :type lightprofile: :py:class:`ILightprofile`
        :param lightprofile:      The light profile to export.
        :rtype: int
        :return: 
                                     -  0: Success.
                                     - -1: Invalid file name.
                                     - -2: Invalid light profile.
                                     - -4: Unspecified failure.
        """
        return _pymdlsdk._IMdl_impexp_api_export_lightprofile(self, filename, lightprofile)

    def export_bsdf_data(self, filename, reflection, transmission):
        r"""
        Exports BSDF data to a file on disk.

        :type filename: string
        :param filename:          The file name of the resource to export the BSDF measurement to.
        :type reflection: mi::neuraylib::IBsdf_isotropic_data
        :param reflection:        The BSDF data for reflection to export. Can be ``NULL``.
        :type transmission: mi::neuraylib::IBsdf_isotropic_data
        :param transmission:      The BSDF data for transmission to export. Can be ``NULL``.
        :rtype: int
        :return: 
                                     -  0: Success.
                                     - -1: Invalid file name.
                                     - -4: Unspecified failure.
        """
        return _pymdlsdk._IMdl_impexp_api_export_bsdf_data(self, filename, reflection, transmission)
    SEARCH_OPTION_USE_FIRST = _pymdlsdk._IMdl_impexp_api_SEARCH_OPTION_USE_FIRST
    r""" Derive module name from the first search path that matches."""
    SEARCH_OPTION_USE_SHORTEST = _pymdlsdk._IMdl_impexp_api_SEARCH_OPTION_USE_SHORTEST
    r""" Derive module name from the shortest search path that matches."""
    SEARCH_OPTION_USE_LONGEST = _pymdlsdk._IMdl_impexp_api_SEARCH_OPTION_USE_LONGEST
    r""" Derive module name from the longest search path that matches."""
    SEARCH_OPTION_FORCE_32_BIT = _pymdlsdk._IMdl_impexp_api_SEARCH_OPTION_FORCE_32_BIT

    def get_mdl_module_name(self, *args):
        r"""
        Returns the MDL name for an MDL module identified by its filename.

        The return value can be passed to #mi::neuraylib::IMdl_impexp_api::load_module() or
        #mi::neuraylib::IMdl_factory::get_db_module_name().

        Notes: This method does not support MDLE modules. This is also not necessary, since in case
              of MDLEs the filename can be directly passed to
              #mi::neuraylib::IMdl_impexp_api::load_module() or
              #mi::neuraylib::IMdl_factory::get_db_module_name().

        :type filename: string
        :param filename:   The filename of an MDL module (excluding MDLE modules).
        :type option: int, optional
        :param option:     Controls the algorithm's behavior if several overlapping search paths
                              contain the given filename.
        :rtype: :py:class:`IString`
        :return: The MDL name of the given module, or ``NULL`` in case of failures.
        """
        return _pymdlsdk._IMdl_impexp_api_get_mdl_module_name(self, *args)

    def frame_uvtile_marker_to_string(self, marker, f, u, v):
        r"""
        Replaces a frame and/or uv-tile marker by coordinates of a given uv-tile.

        :type marker: string
        :param marker:   String containing a valid frame and/or uv-tile marker.
        :type f: int
        :param f:        The frame number of the uv-tile.
        :type u: int
        :param u:        The u coordinate of the uv-tile.
        :type v: int
        :param v:        The v coordinate of the uv-tile.
        :rtype: :py:class:`IString`
        :return: String with the frame and/or uv-tile marker replaced by the coordinates of
                            the uv-tile, or ``NULL`` in case of errors.
        """
        return _pymdlsdk._IMdl_impexp_api_frame_uvtile_marker_to_string(self, marker, f, u, v)

    def serialize_function_name(self, definition_name, argument_types, return_type, mdle_callback, context):
        r"""
        Serializes the name of a function or material definition.

        See also: 'mi_mdl_serialized_names'

        :type definition_name: string
        :param definition_name:   The DB name of the function or material definition.
        :type argument_types: :py:class:`IType_list`
        :param argument_types:    The arguments of the corresponding function call or material
                                     instance. Required for template-like functions, ignored (can be
                                     ``NULL)`` in all other cases.
        :type return_type: :py:class:`IType`
        :param return_type:       The arguments of the corresponding function call or material
                                     instance. Required for the cast operator, ignored (can be
                                     ``NULL)`` in all other cases.
        :type mdle_callback: :py:class:`IMdle_serialization_callback`
        :param mdle_callback:     Acallback to map the filename of MDLE modules. Ignored for
                                     non-MDLE modules. Can be ``NULL`` (which is treated like a callback
                                     implementing the identity transformation).
        :type context: :py:class:`IMdl_execution_context`
        :param context:           The execution context can be used to pass options and to retrieve
                                     error and/or warning messages. Can be ``NULL``.
        :rtype: :py:class:`ISerialized_function_name`
        :return: The serialized function name, or ``NULL`` in case of errors, or if
                                     encoded names are disabled.
        """
        return _pymdlsdk._IMdl_impexp_api_serialize_function_name(self, definition_name, argument_types, return_type, mdle_callback, context)

    def deserialize_function_name(self, *args):
        r"""
        *Overload 1:*
        Deserializes the serialized name of a function or material definition (first overload)

        See also: 'mi_mdl_serialized_names'

        :type transaction: :py:class:`ITransaction`
        :param transaction:       The transaction to be used.
        :type function_name: string
        :param function_name:     The serialized name of a function or material definition.
        :type mdle_callback: :py:class:`IMdle_deserialization_callback`
        :param mdle_callback:     Acallback to map the filename of MDLE modules. Ignored for
                                     non-MDLE modules. Can be ``NULL`` (which is treated like a callback
                                     implementing the identity transformation).
        :type context: :py:class:`IMdl_execution_context`
        :param context:           The execution context can be used to pass options and to retrieve
                                     error and/or warning messages. Can be ``NULL``.
        :rtype: :py:class:`IDeserialized_function_name`
        :return: The deserialized function name, or ``NULL`` in case of errors, or
                                     if encoded names are disabled.

        |

        *Overload 2:*
        Deserializes the serialized name of a function or material definition (second overload).

        If the corresponding module has not been loaded, it will be loaded as a side effect. The
        method also performs an overload resolution on the deserialized function or material
        definition (as in
        #mi::neuraylib::IModule::get_function_overloads(const char*,const IArray*)const).

        See also: 'mi_mdl_serialized_names'

        :type transaction: :py:class:`ITransaction`
        :param transaction:       The transaction to be used.
        :type module_name: string
        :param module_name:       The serialized name of a module.
        :type function_name_without_module_name: string
        :param function_name_without_module_name:    The serialized name of a function or material
                                                        definition without the module name and ``"::"``
                                                        (as returned by
                    #mi::neuraylib::ISerialized_function_name::get_function_name_without_module_name()).
        :type mdle_callback: :py:class:`IMdle_deserialization_callback`
        :param mdle_callback:     Acallback to map the filename of MDLE modules. Ignored for
                                     non-MDLE modules. Can be ``NULL`` (which is treated like a callback
                                     implementing the identity transformation).
        :type context: :py:class:`IMdl_execution_context`
        :param context:           The execution context can be used to pass options and to retrieve
                                     error and/or warning messages. Can be ``NULL``.
        :rtype: :py:class:`IDeserialized_function_name`
        :return: The deserialized function name, or ``NULL`` in case of errors, or
                                     if encoded names are disabled.
        """
        return _pymdlsdk._IMdl_impexp_api_deserialize_function_name(self, *args)

    def deserialize_module_name(self, module_name, mdle_callback, context):
        r"""
        Deserializes the serialized name of a module.

        If the corresponding module has not been loaded, it will be loaded as a side effect. The
        method also performs an overload resolution on the deserialized function or material
        definition (as in
        #mi::neuraylib::IModule::get_function_overloads(const char*,const IArray*)const).

        See also: 'mi_mdl_serialized_names'

        :type module_name: string
        :param module_name:       The serialized name of a module.
        :type mdle_callback: :py:class:`IMdle_deserialization_callback`
        :param mdle_callback:     Acallback to map the filename of MDLE modules. Ignored for
                                     non-MDLE modules. Can be ``NULL`` (which is treated like a callback
                                     implementing the identity transformation).
        :type context: :py:class:`IMdl_execution_context`
        :param context:           The execution context can be used to pass options and to retrieve
                                     error and/or warning messages. Can be ``NULL``.
        :rtype: :py:class:`IDeserialized_module_name`
        :return: The deserialized module name, or ``NULL`` in case of errors, or
                                     if encoded names are disabled.
        """
        return _pymdlsdk._IMdl_impexp_api_deserialize_module_name(self, module_name, mdle_callback, context)

    def create_reader(self, *args):
        r"""
        *Overload 1:*
        Creates a random-access reader for a given buffer.

        |

        *Overload 2:*
        Returns a random-access reader for a given file.

        :type filename: string
        :param filename:   The filename of the file to get the reader for.
        :rtype: mi::neuraylib::IReader
        :return: A reader that can be used to read the file, or ``NULL`` in case of
                              failures (e.g., there is no such file).
        """
        return _pymdlsdk._IMdl_impexp_api_create_reader(self, *args)

    def create_writer(self, filename):
        r"""
        Returns a random-access writer for a given file.

        :type filename: string
        :param filename:   The filename of the file to get the writer for.
        :rtype: mi::neuraylib::IWriter
        :return: A writer that can be used to write to that file, or ``NULL`` in case of
                              failures (e.g., insufficient permissions).
        """
        return _pymdlsdk._IMdl_impexp_api_create_writer(self, filename)

    def deprecated_uvtile_string_to_marker(self, str, marker):
        return _pymdlsdk._IMdl_impexp_api_deprecated_uvtile_string_to_marker(self, str, marker)

    def deprecated_frame_string_to_marker(self, str, digits):
        return _pymdlsdk._IMdl_impexp_api_deprecated_frame_string_to_marker(self, str, digits)

# Register _IMdl_impexp_api in _pymdlsdk:
_pymdlsdk._IMdl_impexp_api_swigregister(_IMdl_impexp_api)

class Interface_declare_ISerialized_function_name(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_ISerialized_function_name_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_ISerialized_function_name

# Register Interface_declare_ISerialized_function_name in _pymdlsdk:
_pymdlsdk.Interface_declare_ISerialized_function_name_swigregister(Interface_declare_ISerialized_function_name)

def Interface_declare_ISerialized_function_name_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_ISerialized_function_name_compare_iid(iid)

class _ISerialized_function_name(Interface_declare_ISerialized_function_name):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_function_name(self):
        r"""
        Returns the serialized function name.

        Useful for serialization schemes that support only a single string entity.

        Pass to the first overload of
        #mi::neuraylib::IMdl_impexp_api::deserialize_function_name() during deserialization.
        """
        return _pymdlsdk._ISerialized_function_name_get_function_name(self)

    def get_module_name(self):
        r"""
        Returns the serialized module name.

        Useful for serialization schemes that support two string entities.

        Pass to #mi::neuraylib::IMdl_impexp_api::deserialize_module_name() or the second overload
        of #mi::neuraylib::IMdl_impexp_api::deserialize_function_name() during deserialization.
        """
        return _pymdlsdk._ISerialized_function_name_get_module_name(self)

    def get_function_name_without_module_name(self):
        r"""
        Returns the serialized function name (without the module name).

        Useful for serialization schemes that support two string entities.

        Pass to the second overload
        of #mi::neuraylib::IMdl_impexp_api::deserialize_function_name() during deserialization.
        """
        return _pymdlsdk._ISerialized_function_name_get_function_name_without_module_name(self)

# Register _ISerialized_function_name in _pymdlsdk:
_pymdlsdk._ISerialized_function_name_swigregister(_ISerialized_function_name)

class Interface_declare_IDeserialized_function_name(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IDeserialized_function_name_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IDeserialized_function_name

# Register Interface_declare_IDeserialized_function_name in _pymdlsdk:
_pymdlsdk.Interface_declare_IDeserialized_function_name_swigregister(Interface_declare_IDeserialized_function_name)

def Interface_declare_IDeserialized_function_name_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IDeserialized_function_name_compare_iid(iid)

class _IDeserialized_function_name(Interface_declare_IDeserialized_function_name):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_db_name(self):
        r""" Returns the DB name of the function of material definition."""
        return _pymdlsdk._IDeserialized_function_name_get_db_name(self)

    def get_argument_types(self):
        r"""
        Returns the argument types of the serialized function call or material instance.

        The argument types are identical to the parameter types of the corresponding definition,
        unless it is one of the 'mi_neuray_mdl_template_like_function_definitions'. The remarks
        about the expression list for creating calls to the 'mi_neuray_mdl_cast_operator' apply
        correspondingly.
        """
        return _pymdlsdk._IDeserialized_function_name_get_argument_types(self)

# Register _IDeserialized_function_name in _pymdlsdk:
_pymdlsdk._IDeserialized_function_name_swigregister(_IDeserialized_function_name)

class Interface_declare_IDeserialized_module_name(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IDeserialized_module_name_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IDeserialized_module_name

# Register Interface_declare_IDeserialized_module_name in _pymdlsdk:
_pymdlsdk.Interface_declare_IDeserialized_module_name_swigregister(Interface_declare_IDeserialized_module_name)

def Interface_declare_IDeserialized_module_name_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IDeserialized_module_name_compare_iid(iid)

class _IDeserialized_module_name(Interface_declare_IDeserialized_module_name):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_db_name(self):
        r""" Returns the DB name of the module."""
        return _pymdlsdk._IDeserialized_module_name_get_db_name(self)

    def get_load_module_argument(self):
        r""" Returns a string suitable for #mi::neuraylib::IMdl_impexp_api::load_module()."""
        return _pymdlsdk._IDeserialized_module_name_get_load_module_argument(self)

# Register _IDeserialized_module_name in _pymdlsdk:
_pymdlsdk._IDeserialized_module_name_swigregister(_IDeserialized_module_name)

class Interface_declare_IMdle_serialization_callback(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IMdle_serialization_callback_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IMdle_serialization_callback

# Register Interface_declare_IMdle_serialization_callback in _pymdlsdk:
_pymdlsdk.Interface_declare_IMdle_serialization_callback_swigregister(Interface_declare_IMdle_serialization_callback)

def Interface_declare_IMdle_serialization_callback_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IMdle_serialization_callback_compare_iid(iid)

class _IMdle_serialization_callback(Interface_declare_IMdle_serialization_callback):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_serialized_filename(self, filename):
        r"""
        Returns a serialized filename for the given MDLE filename.

        The implemented mapping should be reversible, otherwise you will run into problems
        implementing the corresponding instance of #mi::neuraylib::IMdle_deserialization_callback.

        The callback might get involved several times with the same argument. You might want to
        cache results if the computation is expensive.

        :type filename: string
        :param filename:   The current filename of an MDLE module.
        :rtype: :py:class:`IString`
        :return: The "serialized filename" of that MDLE module. Technically, this can be
                              any string with ``".mdle"`` suffix, it does *not* need to refer to an
                              existing MDLE file on disk.
        """
        return _pymdlsdk._IMdle_serialization_callback_get_serialized_filename(self, filename)

# Register _IMdle_serialization_callback in _pymdlsdk:
_pymdlsdk._IMdle_serialization_callback_swigregister(_IMdle_serialization_callback)

class Interface_declare_IMdle_deserialization_callback(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IMdle_deserialization_callback_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IMdle_deserialization_callback

# Register Interface_declare_IMdle_deserialization_callback in _pymdlsdk:
_pymdlsdk.Interface_declare_IMdle_deserialization_callback_swigregister(Interface_declare_IMdle_deserialization_callback)

def Interface_declare_IMdle_deserialization_callback_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IMdle_deserialization_callback_compare_iid(iid)

class _IMdle_deserialization_callback(Interface_declare_IMdle_deserialization_callback):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_deserialized_filename(self, serialized_filename):
        r"""
        Returns a the filename of an MDLE module given its serialized filename.

        The callback might get involved several times with the same argument. You might want to
        cache results if the computation is expensive.

        :type serialized_filename: string
        :param serialized_filename:   The "serialized filename" of an MDLE module. This is the string
                                         that has been returned by
                                #mi::neuraylib::IMdle_serialization_callback::get_serialized_filename().
        :rtype: :py:class:`IString`
        :return: The actual filename of that MDLE module.
        """
        return _pymdlsdk._IMdle_deserialization_callback_get_deserialized_filename(self, serialized_filename)

# Register _IMdle_deserialization_callback in _pymdlsdk:
_pymdlsdk._IMdle_deserialization_callback_swigregister(_IMdle_deserialization_callback)

class Interface_declare_IMdl_module_builder(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IMdl_module_builder_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IMdl_module_builder

# Register Interface_declare_IMdl_module_builder in _pymdlsdk:
_pymdlsdk.Interface_declare_IMdl_module_builder_swigregister(Interface_declare_IMdl_module_builder)

def Interface_declare_IMdl_module_builder_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IMdl_module_builder_compare_iid(iid)

class _IMdl_module_builder(Interface_declare_IMdl_module_builder):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def add_variant(self, name, prototype_name, defaults, annotations, return_annotations, is_exported, context):
        r"""
        Adds a variant to the module.

        :type name: string
        :param name:                    The simple name of the material or function variant.
        :type prototype_name: string
        :param prototype_name:          The DB name of the prototype of the new variant.
        :type defaults: :py:class:`IExpression_list`
        :param defaults:                Default values to set. If ``NULL``, the defaults of the
                                           original material or function are used. Feasible
                                           sub-expression kinds: constants and calls.
        :type annotations: :py:class:`IAnnotation_block`
        :param annotations:             Annotations to set. If ``NULL``, the annotations of the
                                           original material or function are used. Pass an empty block
                                           to remove all annotations.
        :type return_annotations: :py:class:`IAnnotation_block`
        :param return_annotations:      Return annotations to set. If ``NULL``, the annotations of
                                           the original material or function are used. Pass an empty
                                           block to remove all annotations. Materials require ``NULL`` or
                                           an empty annotation block here.
        :type is_exported: boolean
        :param is_exported:             Indicates whether the variant will have the 'export' keyword.
        :type context: :py:class:`IMdl_execution_context`
        :param context:                 The execution context can be used to pass options and to
                                           retrieve error and/or warning messages. Can be ``NULL``.
        :rtype: int
        :return: 0 in case of success, or -1 in case of failure.
        """
        return _pymdlsdk._IMdl_module_builder_add_variant(self, name, prototype_name, defaults, annotations, return_annotations, is_exported, context)

    def add_function(self, name, body, parameters, defaults, parameter_annotations, annotations, return_annotations, is_exported, frequency_qualifier, context):
        r"""
        Adds a material or function to the module.

        :type name: string
        :param name:                    The simple name of the material or function.
        :type body: :py:class:`IExpression`
        :param body:                    The body of the new material or function (constants, direct
                                           calls, and parameter references). Feasible sub-expression
                                           kinds: constants, direct calls, and parameter references.
        :type parameters: :py:class:`IType_list`
        :param parameters:              Types and names of the parameters. Can be ``NULL`` (treated
                                           like an empty parameter list).
        :type defaults: :py:class:`IExpression_list`
        :param defaults:                Default values. Can be ``NULL`` or incomplete. Feasible
                                           sub-expression kinds: constants, calls, and direct calls.
        :type parameter_annotations: :py:class:`IAnnotation_list`
        :param parameter_annotations:   Parameter annotations. Can be ``NULL`` or incomplete.
        :type annotations: :py:class:`IAnnotation_block`
        :param annotations:             Annotations of the material or function. Can be ``NULL``.
        :type return_annotations: :py:class:`IAnnotation_block`
        :param return_annotations:      Return annotations of the function. Can be ``NULL`` for
                                           functions, must be ``NULL`` for materials.
        :type is_exported: boolean
        :param is_exported:             Indicates whether the material or function will have the
                                           'export' keyword.
        :type frequency_qualifier: int
        :param frequency_qualifier:     The frequency qualifier for functions, or
                                           #mi::neuraylib::IType::MK_NONE for materials.
        :type context: :py:class:`IMdl_execution_context`
        :param context:                 The execution context can be used to pass options and to
                                           retrieve error and/or warning messages. Can be ``NULL``.
        """
        return _pymdlsdk._IMdl_module_builder_add_function(self, name, body, parameters, defaults, parameter_annotations, annotations, return_annotations, is_exported, frequency_qualifier, context)

    def add_annotation(self, name, parameters, defaults, parameter_annotations, annotations, is_exported, context):
        r"""
        Adds an annotation to the module.

        :type name: string
        :param name:                    The simple name of the annotation.
        :type parameters: :py:class:`IType_list`
        :param parameters:              Types and names of the parameters. Can be ``NULL`` (treated
                                           like an empty parameter list).
        :type defaults: :py:class:`IExpression_list`
        :param defaults:                Default values. Can be ``NULL`` or incomplete. Feasible
                                           sub-expression kinds: constants, calls, and direct calls.
        :type parameter_annotations: :py:class:`IAnnotation_list`
        :param parameter_annotations:   Parameter annotations. Can be ``NULL`` or incomplete.
        :type annotations: :py:class:`IAnnotation_block`
        :param annotations:             Annotations of the annotation. Can be ``NULL``.
        :type is_exported: boolean
        :param is_exported:             Indicates whether the annotation will have the 'export'
                                           keyword.
        :type context: :py:class:`IMdl_execution_context`
        :param context:                 The execution context can be used to pass options and to
                                           retrieve error and/or warning messages. Can be ``NULL``.
        """
        return _pymdlsdk._IMdl_module_builder_add_annotation(self, name, parameters, defaults, parameter_annotations, annotations, is_exported, context)

    def add_enum_type(self, name, enumerators, enumerator_annotations, annotations, is_exported, context):
        r"""
        Adds an enum type to the module.

        Notes: Changing a particular enum type, i.e., removing it and re-adding it differently, is

        :type name: string
        :param name:                    The simple name of the enum type.
        :type enumerators: :py:class:`IExpression_list`
        :param enumerators:             Enumerators of the enum type. Must not be empty. Feasible
                                           sub-expression kinds: constants and direct calls.
        :type enumerator_annotations: :py:class:`IAnnotation_list`
        :param enumerator_annotations:  Enumerator annotations. Can be ``NULL`` or incomplete.
        :type annotations: :py:class:`IAnnotation_block`
        :param annotations:             Annotations of the enum type. Can be ``NULL``.
        :type is_exported: boolean
        :param is_exported:             Indicates whether the enum type will have the 'export'
                                           keyword.
        :type context: :py:class:`IMdl_execution_context`
        :param context:                 The execution context can be used to pass options and to
                                           retrieve error and/or warning messages. Can be ``NULL``.
        """
        return _pymdlsdk._IMdl_module_builder_add_enum_type(self, name, enumerators, enumerator_annotations, annotations, is_exported, context)

    def add_struct_type(self, name, fields, field_defaults, field_annotations, annotations, is_exported, context):
        r"""
        Adds a struct type to the module.

        Notes: Changing a particular struct type, i.e., removing it and re-adding it differently, is

        :type name: string
        :param name:                    The simple name of the enum type.
        :type fields: :py:class:`IType_list`
        :param fields:                  Fields of the struct type. Must not be empty.
        :type field_defaults: :py:class:`IExpression_list`
        :param field_defaults:          Defaults of the struct fields. Can be ``NULL`` or incomplete.
                                           Feasible sub-expression kinds: constants and direct calls.
        :type field_annotations: :py:class:`IAnnotation_list`
        :param field_annotations:       Field annotations of the struct type. Can be ``NULL`` or
                                           incomplete.
        :type annotations: :py:class:`IAnnotation_block`
        :param annotations:             Annotations of the struct type. Can be ``NULL``.
        :type is_exported: boolean
        :param is_exported:             Indicates whether the struct type will have the 'export'
                                           keyword.
        :type context: :py:class:`IMdl_execution_context`
        :param context:                 The execution context can be used to pass options and to
                                           retrieve error and/or warning messages. Can be ``NULL``.
        """
        return _pymdlsdk._IMdl_module_builder_add_struct_type(self, name, fields, field_defaults, field_annotations, annotations, is_exported, context)

    def add_constant(self, name, expr, annotations, is_exported, context):
        r"""
        Adds a constant to the module.

        :type name: string
        :param name:                    The simple name of the constant.
        :type expr: :py:class:`IExpression`
        :param expr:                    The value of the constant.
                                           Feasible sub-expression kinds: constants and direct calls.
        :type annotations: :py:class:`IAnnotation_block`
        :param annotations:             Annotations of the constant. Can be ``NULL``.
        :type is_exported: boolean
        :param is_exported:             Indicates whether the constant will have the 'export'
                                           keyword.
        :type context: :py:class:`IMdl_execution_context`
        :param context:                 The execution context can be used to pass options and to
                                           retrieve error and/or warning messages. Can be ``NULL``.
        """
        return _pymdlsdk._IMdl_module_builder_add_constant(self, name, expr, annotations, is_exported, context)

    def set_module_annotations(self, annotations, context):
        r"""
        Sets the annotations of the module itself.

        :type annotations: :py:class:`IAnnotation_block`
        :param annotations:             Annotations of the module. Pass ``NULL`` to remove existing
                                           annotations.
        :type context: :py:class:`IMdl_execution_context`
        :param context:                 The execution context can be used to pass options and to
                                           retrieve error and/or warning messages. Can be ``NULL``.
        """
        return _pymdlsdk._IMdl_module_builder_set_module_annotations(self, annotations, context)

    def remove_entity(self, name, index, context):
        r"""
        Removes a material, function, enum or struct type from the module.

        :type name: string
        :param name:                    The simple name of material, function, enum or struct type to
                                           be removed.
        :type index: int
        :param index:                   The index of the function with the given name to be removed.
                                           Used to distinguish overloads of functions. Zero 0 for
                                           materials, enum or struct types.
        :type context: :py:class:`IMdl_execution_context`
        :param context:                 The execution context can be used to pass options and to
                                           retrieve error and/or warning messages. Can be ``NULL``.
        """
        return _pymdlsdk._IMdl_module_builder_remove_entity(self, name, index, context)

    def clear_module(self, context):
        r""" Clears the module, i.e., removes all declarations from the module."""
        return _pymdlsdk._IMdl_module_builder_clear_module(self, context)

    def analyze_uniform(self, root_expr, root_expr_uniform, context):
        r"""
        Analyzes which parameters need to be uniform.

        :type root_expr: :py:class:`IExpression`
        :param root_expr:               Root expression of the graph, i.e., the body of the new
                                           material or function.
        :type root_expr_uniform: boolean
        :param root_expr_uniform:       Indicates whether the root expression should be uniform.
        :type context: :py:class:`IMdl_execution_context`
        :param context:                 The execution context can be used to pass options and to
                                           retrieve error and/or warning messages. Can be ``NULL``.
        :rtype: :py:class:`IArray`
        :return: Indicates which parameters need to be uniform. The array
                                           might be shorter than expected if trailing parameters are
                                           not referenced by ``root_expr`` (or in case of errors).
        """
        return _pymdlsdk._IMdl_module_builder_analyze_uniform(self, root_expr, root_expr_uniform, context)

# Register _IMdl_module_builder in _pymdlsdk:
_pymdlsdk._IMdl_module_builder_swigregister(_IMdl_module_builder)

class Interface_declare_IModule(_IScene_element):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IModule_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IModule

# Register Interface_declare_IModule in _pymdlsdk:
_pymdlsdk.Interface_declare_IModule_swigregister(Interface_declare_IModule)

def Interface_declare_IModule_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IModule_compare_iid(iid)

class _IModule(Interface_declare_IModule):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_filename(self):
        r"""
        Returns the name of the MDL source file from which this module was created.

        :rtype: string
        :return: The full pathname of the source file from which this MDL module was created,
                            or ``NULL`` if no such file exists.
        """
        return _pymdlsdk._IModule_get_filename(self)

    def get_mdl_name(self):
        r"""
        Returns the MDL name of the module.

        Notes: The MDL name of the module is different from the name of the DB element.
              Use #mi::neuraylib::ITransaction::name_of() to obtain the name of the DB element.

        :rtype: string
        :return: The MDL name of the module.
        """
        return _pymdlsdk._IModule_get_mdl_name(self)

    def get_mdl_package_component_count(self):
        r""" Returns the number of package components in the MDL name."""
        return _pymdlsdk._IModule_get_mdl_package_component_count(self)

    def get_mdl_package_component_name(self, index):
        r"""
        Returns the name of a package component in the MDL name.

        :rtype: string
        :return: The ``index`` -th package component name, or ``NULL`` if ``index`` is out of
                            bounds.
        """
        return _pymdlsdk._IModule_get_mdl_package_component_name(self, index)

    def get_mdl_simple_name(self):
        r"""
        Returns the simple MDL name of the module.

        The simple name is the last component of the MDL name, i.e., without any packages and scope
        qualifiers.

        :rtype: string
        :return: The simple MDL name of the module.
        """
        return _pymdlsdk._IModule_get_mdl_simple_name(self)

    def get_mdl_version(self):
        r""" Returns the MDL version of this module."""
        return _pymdlsdk._IModule_get_mdl_version(self)

    def get_import_count(self):
        r""" Returns the number of modules imported by the module."""
        return _pymdlsdk._IModule_get_import_count(self)

    def get_import(self, index):
        r"""
        Returns the DB name of the imported module at ``index``.

        :type index: int
        :param index:    The index of the imported module.
        :rtype: string
        :return: The DB name of the imported module.
        """
        return _pymdlsdk._IModule_get_import(self, index)

    def get_types(self):
        r""" Returns the types exported by this module."""
        return _pymdlsdk._IModule_get_types(self)

    def get_constants(self):
        r""" Returns the constants exported by this module."""
        return _pymdlsdk._IModule_get_constants(self)

    def get_function_count(self):
        r""" Returns the number of function definitions exported by the module."""
        return _pymdlsdk._IModule_get_function_count(self)

    def get_function(self, index):
        r"""
        Returns the DB name of the function definition at ``index``.

        :type index: int
        :param index:    The index of the function definition.
        :rtype: string
        :return: The DB name of the function definition. The method may return ``NULL`` for
                            valid indices if the corresponding function definition has already been
                            removed from the DB.
        """
        return _pymdlsdk._IModule_get_function(self, index)

    def get_material_count(self):
        r""" Returns the number of material definitions exported by the module."""
        return _pymdlsdk._IModule_get_material_count(self)

    def get_material(self, index):
        r"""
        Returns the DB name of the material definition at ``index``.

        :type index: int
        :param index:    The index of the material definition.
        :rtype: string
        :return: The DB name of the material definition. The method may return ``NULL`` for
                            valid indices if the corresponding material definition has already been
                            removed from the DB.
        """
        return _pymdlsdk._IModule_get_material(self, index)

    def get_resources_count(self):
        r"""
        Returns the number of resources defined in the module.

        Resources defined in a module that is imported by this module are not included.
        """
        return _pymdlsdk._IModule_get_resources_count(self)

    def get_resource(self, index):
        r"""
        Returns a resource defined in the module.

        Resources defined in a module that is imported by this module are not included.
        """
        return _pymdlsdk._IModule_get_resource(self, index)

    def get_annotation_definition_count(self):
        r""" Returns the number of annotations defined in the module."""
        return _pymdlsdk._IModule_get_annotation_definition_count(self)

    def get_annotation_definition(self, *args):
        r"""
        *Overload 1:*
        Returns the annotation definition at ``index``.

        :type index: int
        :param index:    The index of the annotation definition.
        :rtype: :py:class:`IAnnotation_definition`
        :return: The annotation definition or ``NULL`` if
                            ``index`` is out of range.

        |

        *Overload 2:*
        Returns the annotation definition of the given ``name``.

        :type name: string
        :param name:     The name of the annotation definition.
        :rtype: :py:class:`IAnnotation_definition`
        :return: The annotation definition or ``NULL`` if there is no such definition.
        """
        return _pymdlsdk._IModule_get_annotation_definition(self, *args)

    def get_annotations(self):
        r""" Returns the annotations of the module, or ``NULL`` if there are no such annotations."""
        return _pymdlsdk._IModule_get_annotations(self)

    def is_standard_module(self):
        r"""
        Indicates whether this module is a standard module.

        Examples for standard modules are ``"limits"``, ``"anno"``, ``"state"``, ``"math"``, ``"tex"``,
        ``"noise"``, and ``"df"``.
        """
        return _pymdlsdk._IModule_is_standard_module(self)

    def is_mdle_module(self):
        r""" Indicates whether this module results from an ``.mdle`` file."""
        return _pymdlsdk._IModule_is_mdle_module(self)

    def get_function_overloads(self, *args):
        r"""
        *Overload 1:*
        Returns overloads of a function or material definition.

        The method returns overloads of a function or material definition of this module, either
        all overloads or just the overloads matching a given set of arguments.

        :type name: string
        :param name:             The DB name of a function or material definition from this module
                                    *without* signature.
        :type arguments: :py:class:`IExpression_list`, optional
        :param arguments:        Optional arguments to select specific overload(s). If present, the
                                    method returns only the overloads of ``name`` whose signature
                                    matches the provided arguments, i.e., a call to
                                    #mi::neuraylib::IFunction_definition::create_function_call() with
                                    these arguments would succeed.
        :rtype: :py:class:`IArray`
        :return: The DB names of overloads of the given function or material
                                    definition, or ``NULL`` if ``name`` is invalid.

        |

        *Overload 2:*
        Returns overloads of a function or material definition.

        The method returns the best-matching overloads of a function or material definition of this
        module, given a list of positional parameter types.

        Notes: This overload should only be used if no actual arguments are available. If arguments
              are available, consider using
              #get_function_overloads(const char*,const IExpression_list*)const instead.

        This method does not work for the function definitions with the following semantics:
              - #mi::neuraylib::IFunction_definition::DS_CAST,
              - #mi::neuraylib::IFunction_definition::DS_TERNARY,
              - #mi::neuraylib::IFunction_definition::DS_ARRAY_INDEX,
              - #mi::neuraylib::IFunction_definition::DS_INTRINSIC_DAG_ARRAY_CONSTRUCTOR,
              - #mi::neuraylib::IFunction_definition::DS_INTRINSIC_DAG_ARRAY_LENGTH. and
              - #mi::neuraylib::IFunction_definition::DS_INTRINSIC_DAG_FIELD_ACCESS.
              These are the 'mi_neuray_mdl_template_like_function_definitions' plus the field
              access function definitions.

        :type name: string
        :param name:             The DB name of a function or material definition from this module
                                    *without* signature.
        :type parameter_types: :py:class:`IArray`
        :param parameter_types:  A static or dynamic array with elements of type #mi::IString
                                    representing positional parameter type names as returned by
                                    #mi::neuraylib::IFunction_definition::get_mdl_parameter_type_name().
        :rtype: :py:class:`IArray`
        :return: The DB names of overloads of the given function or material
                                    definition, or ``NULL`` if ``name`` is invalid.
        """
        return _pymdlsdk._IModule_get_function_overloads(self, *args)

    def is_valid(self, context):
        r"""
        Returns ``true`` if all imports of the module are valid.

        :type context: :py:class:`IMdl_execution_context`
        :param context:     In case of failure, the execution context can be checked for error
                               messages. Can be ``NULL``.
        """
        return _pymdlsdk._IModule_is_valid(self, context)

    def reload(self, recursive, context):
        r"""
        Reload the module from disk.

        Notes: This function works for file-based modules, only.

        :type context: :py:class:`IMdl_execution_context`
        :param context:     In case of failure, the execution context can be checked for error
                               messages. Can be ``NULL``.
        :type recursive: boolean
        :param recursive:   If ``true``, all imported file based modules are reloaded
                               prior to this one.
        :rtype: int
        :return: 
                          -     0: Success
                          -    -1: Reloading failed, check the context for details.
        """
        return _pymdlsdk._IModule_reload(self, recursive, context)

    def reload_from_string(self, module_source, recursive, context):
        r"""
        Reload the module from string.

        Notes: This function works for string/memory-based modules, only. Standard modules and
        the built-in If: MDL_SOURCE_RELEASE { module mdl::base }Else: modules  {``mdl::base`` and
        ``mdl::nvidia::distilling_support`` } cannot be reloaded.

        :type module_source: string
        :param module_source: The module source code.
        :type recursive: boolean
        :param recursive:     If ``true``, all imported file based modules are reloaded
                                 prior to this one.
        :type context: :py:class:`IMdl_execution_context`
        :param context:       In case of failure, the execution context can be checked for error
                                 messages. Can be ``NULL``.
        :rtype: int
        :return: 
                          -     0: Success
                          -    -1: Reloading failed, check the context for details.
        """
        return _pymdlsdk._IModule_reload_from_string(self, module_source, recursive, context)

    def deprecated_get_function_overloads(self, name, param_sig):
        return _pymdlsdk._IModule_deprecated_get_function_overloads(self, name, param_sig)

    def deprecated_get_resource_type(self, index):
        return _pymdlsdk._IModule_deprecated_get_resource_type(self, index)

    def deprecated_get_resource_mdl_file_path(self, index):
        return _pymdlsdk._IModule_deprecated_get_resource_mdl_file_path(self, index)

    def deprecated_get_resource_name(self, index):
        return _pymdlsdk._IModule_deprecated_get_resource_name(self, index)

# Register _IModule in _pymdlsdk:
_pymdlsdk._IModule_swigregister(_IModule)

class Interface_declare_INeuray(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_INeuray_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_INeuray

# Register Interface_declare_INeuray in _pymdlsdk:
_pymdlsdk.Interface_declare_INeuray_swigregister(Interface_declare_INeuray)

def Interface_declare_INeuray_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_INeuray_compare_iid(iid)

class _INeuray(Interface_declare_INeuray):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_interface_version(self):
        r"""
        Returns the interface version of the MDL SDK library.

        This number changes whenever the abstract interfaces of the MDL SDK APIchanges.
        """
        return _pymdlsdk._INeuray_get_interface_version(self)

    def get_version(self):
        r"""
        Returns the version of the MDL SDK library.

        This string contains the product version, build number, build date, and platform of the
        current library.
        """
        return _pymdlsdk._INeuray_get_version(self)

    def start(self, blocking=True):
        r"""
        Starts the operation of the MDL SDK library.

        All configuration which is marked to be done before the start of the library must be done
        before calling this function. When calling this function the MDL SDKwill start
        threads and start network operations etc. The MDL SDK librarymay not be ready for
        operation after the call returned if blocking mode is not used.

        If: IRAY_API {
        Notes: Starting the MDL SDK librarymultiple times, i.e., calling #shutdown() then calling
              #start() again, is not yet supported. This is true even if the first call to
              #start() fails.
        }

        :type blocking: boolean, optional
        :param blocking:If: MDL_SDK_API { Unused. The startup is always done in blocking mode.
                           }Else: Indicates whether the startup should be done in blocking mode. If {
                           ``true`` the method will not return before all initialization was done. If
                           ``false`` the method will return immediately and the startup is done in a
                           separate thread. The status of the startup sequence can be checked via
                           #get_status(). }
        :rtype: int
        :return: 
                               -  0: Success
                               - -1: Unspecified failure.
                               - -2: Authentication failure (challenge-response).
                               - -4: Provided license expired.
                               - -5: No professional GPU as required by the license in use was found.
                               - -6: Authentication failure (FLEXlm).
                               - -7: No NVIDIA VCA as required by the license in use was found.
        """
        return _pymdlsdk._INeuray_start(self, blocking)
    PRE_STARTING = _pymdlsdk._INeuray_PRE_STARTING
    r""" The library or the cluster has not yet been started."""
    STARTING = _pymdlsdk._INeuray_STARTING
    r""" The library or the cluster is starting."""
    STARTED = _pymdlsdk._INeuray_STARTED
    r""" The library or the cluster is ready for operation."""
    SHUTTINGDOWN = _pymdlsdk._INeuray_SHUTTINGDOWN
    r""" The library or the cluster is shutting down."""
    SHUTDOWN = _pymdlsdk._INeuray_SHUTDOWN
    r""" The library or the cluster has been shut down."""
    FAILURE = _pymdlsdk._INeuray_FAILURE
    r""" There was a failure during operation."""
    FORCE_32_BIT = _pymdlsdk._INeuray_FORCE_32_BIT

    def shutdown(self, blocking=True):
        r"""
        Shuts down the library.

        For proper shutdown this may only be called after all transactions have been committed and
        all rendering is finished.

        You also need to release all interface pointers related to functionality obtained after
        startup before calling this method. In case you use the #mi::base::Handle class (or another
        handle class), you need to make sure that all such handles have been reset or destroyed.

        If: IRAY_API {
        Notes: Starting the MDL SDK librarymultiple times, i.e., calling #shutdown() then calling
              #start() again, is not yet supported. This is true even if the first call to
              #start() fails.
        }

        :type blocking: boolean, optional
        :param blocking:If: MDL_SDK_API { Unused. The shutdown is always done in blocking mode.
                           }Else: Indicates whether the shutdown should be done in blocking mode. If {
                           ``true`` the method will not return before shutdown has completed.
                           If ``false`` the method will return immediately and the shutdown is done
                           in a separate thread. The status of the shutdown sequence can be checked
                           via #get_status(). }
        :rtype: int
        :return: 0, in case of success, -1 in case of failure
        """
        return _pymdlsdk._INeuray_shutdown(self, blocking)

    def _get_status(self):
        r"""
        Returns the status of the library.

        :rtype: int
        :return: The status
        """
        return _pymdlsdk._INeuray__get_status(self)

    def _get_api_component(self, uuid):
        r"""
        Returns an API component from the MDL SDK API.

        See also: 'mi_neuray_api_components' for a list of built-in API components.

        See also: #register_api_component(), #unregister_api_component()

        :type uuid: :py:class:`Uuid`
        :param uuid:        The UUID under which the API components was registered. For built-in
                               API components this is the interface ID of the corresponding interface.
        :rtype: mi::base::IInterface
        :return: A pointer to the API component or ``NULL`` if the API component is not
                               supported or currently not available.
        """
        return _pymdlsdk._INeuray__get_api_component(self, uuid)

    def register_api_component(self, uuid, api_component):
        r"""
        Registers an API component with the MDL SDK API

        API components are a way for plugins to provide access to their functionality. The
        registration makes the API component available for subsequent calls of #get_api_component().

        :type uuid: :py:class:`Uuid`
        :param uuid:            The ID of the API component to register, e.g., the interface ID of
                                   the corresponding interface.
        :type api_component: mi::base::IInterface
        :param api_component:   The API component to register.
        :rtype: int
        :return: 
                                   -  0: Success.
                                   - -1: Invalid parameters (``NULL`` pointer).
                                   - -2: There is already an API component registered under the
                                         ID ``uuid``.
        """
        return _pymdlsdk._INeuray_register_api_component(self, uuid, api_component)

    def unregister_api_component(self, uuid):
        r"""
        Unregisters an API component with the MDL SDK API

        The API component will no longer be accessible via #get_api_component().

        :type uuid: :py:class:`Uuid`
        :param uuid:        The ID of the API component to unregister.
        :rtype: int
        :return: 
                               -  0: Success.
                               - -1: There is no API component registered under the ID ``uuid``.
        """
        return _pymdlsdk._INeuray_unregister_api_component(self, uuid)

# Register _INeuray in _pymdlsdk:
_pymdlsdk._INeuray_swigregister(_INeuray)

class Interface_declare_IPlugin_configuration(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IPlugin_configuration_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IPlugin_configuration

# Register Interface_declare_IPlugin_configuration in _pymdlsdk:
_pymdlsdk.Interface_declare_IPlugin_configuration_swigregister(Interface_declare_IPlugin_configuration)

def Interface_declare_IPlugin_configuration_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IPlugin_configuration_compare_iid(iid)

class _IPlugin_configuration(Interface_declare_IPlugin_configuration):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def load_plugin_library(self, path):
        r"""
        Loads a plugin library.

        This function loads the specified shared library, enumerates all plugin classes in the
        specified shared library, and adds them to the system.

        This function can only be called before the MDL SDKhas been started.

        :type path: string
        :param path:     The path of the shared library to be loaded. This shared library needs to be
                            a valid plugin for the MDL SDK.
        :rtype: int
        :return: 0, in case of success, -1 in case of failure.
        """
        return _pymdlsdk._IPlugin_configuration_load_plugin_library(self, path)

    def load_plugins_from_directory(self, path):
        r"""
        Loads all plugins from a given directory.

        Enumerates all plugins in the given directory in alphabetic order and calls
        #load_plugin_library() for each of them in turn. On Windows, all files with the extension
        ``.dll`` are considered, while on Linux and MacOS X all files with the extension ``.so`` are
        considered. Additionally, on MacOS X all files with extension ``.dylib`` are considered.

        :type path: string
        :param path:     The path of the directory.
        :rtype: int
        :return: 0, in case of success, -1 in case of failure.
        """
        return _pymdlsdk._IPlugin_configuration_load_plugins_from_directory(self, path)

    def get_plugin_length(self):
        r"""
        Returns the number of loaded plugins.

        :rtype: int
        :return: The number of loaded plugins.
        """
        return _pymdlsdk._IPlugin_configuration_get_plugin_length(self)

    def get_plugin_descriptor(self, index):
        r"""
        Returns a descriptor for the ``index`` -th loaded plugin.

        :rtype: mi::base::IPlugin_descriptor
        :return: A descriptor for the ``index`` -th loaded plugin, or ``NULL`` in
                            case of failure.
        """
        return _pymdlsdk._IPlugin_configuration_get_plugin_descriptor(self, index)

# Register _IPlugin_configuration in _pymdlsdk:
_pymdlsdk._IPlugin_configuration_swigregister(_IPlugin_configuration)

class Interface_declare_IScope(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IScope_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IScope

# Register Interface_declare_IScope in _pymdlsdk:
_pymdlsdk.Interface_declare_IScope_swigregister(Interface_declare_IScope)

def Interface_declare_IScope_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IScope_compare_iid(iid)

class _IScope(Interface_declare_IScope):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def create_transaction(self):
        r"""
        Creates a new transaction associated with this scope.

        If: DICE_API { DiCE users should treat ``ITransaction`` as an opaque type. Instead, you should
        use #mi::neuraylib::IDice_transaction which is better suited for the needs of DiCE. To
        create such a DiCE transaction call the templated variant
        #mi::neuraylib::IScope::create_transaction<mi::neuraylib::IDice_transaction>(). }

        If: MDL_SDK_API { Notes: The MDL SDK currently supports only one transaction at a time. }

        :rtype: :py:class:`ITransaction`
        :return: A transaction associated with this scope.
        """
        return _pymdlsdk._IScope_create_transaction(self)

    def get_id(self):
        r"""
        Returns the ID of the scope.

        Can be used to retrieve the scope from the database later.

        :rtype: string
        :return: The ID of the scope.
        """
        return _pymdlsdk._IScope_get_id(self)

    def get_privacy_level(self):
        r"""
        Returns the privacy level of the scope.

        The global scope has privacy level 0, all other scopes have higher privacy levels. On each
        path from the global scope to any other scope in the scope tree the privacy levels are
        strictly increasing.

        :rtype: mi::Uint8
        :return: The privacy level of the scope.
        """
        return _pymdlsdk._IScope_get_privacy_level(self)

    def get_name(self):
        r"""
        Returns the name of the scope.

        :rtype: string
        :return: The name of the scope, or ``NULL`` if the scope has no name.
        """
        return _pymdlsdk._IScope_get_name(self)

    def get_parent(self):
        r"""
        Returns the parent scope.

        :rtype: :py:class:`IScope`
        :return: The parent scope or ``NULL`` if the scope is the global scope.
        """
        return _pymdlsdk._IScope_get_parent(self)

# Register _IScope in _pymdlsdk:
_pymdlsdk._IScope_swigregister(_IScope)

TEXTURE_NO_COMPRESSION = _pymdlsdk.TEXTURE_NO_COMPRESSION
r""" no compression"""
TEXTURE_MEDIUM_COMPRESSION = _pymdlsdk.TEXTURE_MEDIUM_COMPRESSION
r""" medium compression ratio"""
TEXTURE_HIGH_COMPRESSION = _pymdlsdk.TEXTURE_HIGH_COMPRESSION
r""" high compression ratio"""
TEXTURE_COMPRESSION_FORCE_32_BIT = _pymdlsdk.TEXTURE_COMPRESSION_FORCE_32_BIT
FILTER_BOX = _pymdlsdk.FILTER_BOX
r""" box filter"""
FILTER_TRIANGLE = _pymdlsdk.FILTER_TRIANGLE
r""" triangle filter"""
FILTER_GAUSS = _pymdlsdk.FILTER_GAUSS
r""" Gaussian filter"""
FILTER_CMITCHELL = _pymdlsdk.FILTER_CMITCHELL
r""" clipped Mitchell filter"""
FILTER_CLANCZOS = _pymdlsdk.FILTER_CLANCZOS
r""" clipped Lanczos filter"""
FILTER_FAST = _pymdlsdk.FILTER_FAST
r""" a fast filter, could be GPU anti-aliasing, or any"""
FILTER_FORCE_32_BIT = _pymdlsdk.FILTER_FORCE_32_BIT
class Interface_declare_ITexture(_IScene_element):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_ITexture_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_ITexture

# Register Interface_declare_ITexture in _pymdlsdk:
_pymdlsdk.Interface_declare_ITexture_swigregister(Interface_declare_ITexture)

def Interface_declare_ITexture_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_ITexture_compare_iid(iid)

class _ITexture(Interface_declare_ITexture):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_image(self, name):
        r"""
        Sets the referenced image.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: There is no element with that name.
                      - -3: The element can not be referenced because it is in a more private scope
                            than the texture.
                      - -4: The element is not an image.
        """
        return _pymdlsdk._ITexture_set_image(self, name)

    def get_image(self):
        r"""
        Returns the referenced image.

        :rtype: string
        :return: The referenced image, or ``NULL`` if no image is referenced.
        """
        return _pymdlsdk._ITexture_get_image(self)

    def set_volume(self, name):
        r"""
        Sets the referenced volume.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: There is no element with that name.
                      - -3: The element can not be referenced because it is in a more private scope
                            than the texture.
                      - -4: The element is not a volume.
        """
        return _pymdlsdk._ITexture_set_volume(self, name)

    def get_volume(self):
        r"""
        Returns the referenced volume data.

        :rtype: string
        :return: The referenced volume, or ``NULL`` if no volume is referenced.
        """
        return _pymdlsdk._ITexture_get_volume(self)

    def set_gamma(self, gamma):
        r"""
        Sets the gamma value of this texture.

        The gamma value of the texture is an override for the gamma value of the underlying
        image. The special value 0.0 means that the override is not set.

        This override value is also used when MDL source code is to be generated:
        - a value of 1.0 is converted to ``"::tex::gamma_linear"``,
        - a value of 2.2 is converted to ``"::tex::gamma_srgb"``, and
        - all other values are converted to ``"::tex::gamma_default"``.
        Therefore, if you want to avoid ``"::tex::gamma_default"`` in generated MDL source code, it
        makes sense to replicate the gamma value of the underlying image here (instead of not using
        the override).

        See also: #get_gamma(), #get_effective_gamma()
        """
        return _pymdlsdk._ITexture_set_gamma(self, gamma)

    def get_gamma(self):
        r"""
        Returns the gamma value of this texture.

        See also: #set_gamma(), #get_effective_gamma()
        """
        return _pymdlsdk._ITexture_get_gamma(self)

    def get_effective_gamma(self, frame_id, uvtile_id):
        r"""
        Returns the effective gamma value.

        Returns the gamma value of this texture, unless no override is set. In this case the gamma
        value of the underlying image at the given frame and uvtile index is returned. If no such
        image exists, 0.0 is returned.

        :type frame_id: int
        :param frame_id:    The frame ID of the mipmap the gamma value is requested for when no
                               override is set.
        :type uvtile_id: int
        :param uvtile_id:   The uv-tile id of the mipmap the gamma value is requested for when no
                               override is set.

        See also: #set_gamma(), #get_gamma()
        """
        return _pymdlsdk._ITexture_get_effective_gamma(self, frame_id, uvtile_id)

    def get_selector(self):
        r""" Returns the selector (or ``NULL)``."""
        return _pymdlsdk._ITexture_get_selector(self)

    def set_compression(self, compression):
        r"""
        Sets the texture compression method.

        Notes: This setting does not affect the referenced image itself, it only affects image data
              that has been processed by the render modes. For example, in order to save GPU memory
              processed image data can be compressed before being uploaded to the GPU.

        See also: #mi::neuraylib::Texture_compression
        """
        return _pymdlsdk._ITexture_set_compression(self, compression)

    def get_compression(self):
        r"""
        Returns the texture compression method.

        Notes: This setting does not affect the referenced image itself, it only affects image data
              that has been processed by the render modes. For example, in order to save GPU memory
              processed image data can be compressed before being uploaded to the GPU.

        See also: #mi::neuraylib::Texture_compression
        """
        return _pymdlsdk._ITexture_get_compression(self)

# Register _ITexture in _pymdlsdk:
_pymdlsdk._ITexture_swigregister(_ITexture)

class Interface_declare_ITile(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_ITile_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_ITile

# Register Interface_declare_ITile in _pymdlsdk:
_pymdlsdk.Interface_declare_ITile_swigregister(Interface_declare_ITile)

def Interface_declare_ITile_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_ITile_compare_iid(iid)

class _ITile(Interface_declare_ITile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r"""
        Returns the pixel type used by the tile.

        See also: 'mi_neuray_types' for a list of supported pixel types
        """
        return _pymdlsdk._ITile_get_type(self)

    def get_resolution_x(self):
        r""" Returns the tile size in x direction"""
        return _pymdlsdk._ITile_get_resolution_x(self)

    def get_resolution_y(self):
        r""" Returns the tile size in y direction"""
        return _pymdlsdk._ITile_get_resolution_y(self)

    def get_data(self, *args):
        r"""
        *Overload 1:*
        Returns a pointer to the raw tile data according to the pixel type of the tile.

        This methods is used for fast, direct read access to the raw tile data. It is expected that
        the data is stored in row-major layout without any padding. In case of #mi::Color, the
        components are expected to be stored in RGBA order.

        The total size of the buffer in bytes is.. code-block:: c++

           x * y * bpp where ``x`` is the result
        of #get_resolution_x(), ``y`` is the result of #get_resolution_y(), and ``bpp`` is the number
        of bytes per pixel. If not: MDL_SDK_API { The number of bytes per pixel is the product of
        #mi::neuraylib::IImage_api::get_components_per_pixel() and
        #mi::neuraylib::IImage_api::get_bytes_per_component() when passing the result of #get_type()
        as pixel type. }

        |

        *Overload 2:*
        Returns a pointer to the raw tile data according to the pixel type of the tile.

        This methods is used for fast, direct write access to the raw tile data. It is expected that
        the data is stored in row-major layout without any padding. In case of #mi::Color, the
        components are expected to be stored in RGBA order.

        The total size of the buffer in bytes is.. code-block:: c++

           x * y * bpp where ``x`` is the result
        of #get_resolution_x(), ``y`` is the result of #get_resolution_y(), and ``bpp`` is the number
        of bytes per pixel. If not: MDL_SDK_API { The number of bytes per pixel is the product of
        #mi::neuraylib::IImage_api::get_components_per_pixel() and
        #mi::neuraylib::IImage_api::get_bytes_per_component() when passing the result of #get_type()
        as pixel type. }
        """
        return _pymdlsdk._ITile_get_data(self, *args)

    def get_pixel(self, *args):
        return _pymdlsdk._ITile_get_pixel(self, *args)

    def set_pixel(self, *args):
        return _pymdlsdk._ITile_set_pixel(self, *args)

# Register _ITile in _pymdlsdk:
_pymdlsdk._ITile_swigregister(_ITile)

class Interface_declare_IBsdf_measurement(_IScene_element):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IBsdf_measurement_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IBsdf_measurement

# Register Interface_declare_IBsdf_measurement in _pymdlsdk:
_pymdlsdk.Interface_declare_IBsdf_measurement_swigregister(Interface_declare_IBsdf_measurement)

def Interface_declare_IBsdf_measurement_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IBsdf_measurement_compare_iid(iid)

class _IBsdf_measurement(Interface_declare_IBsdf_measurement):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def reset_file(self, filename):
        r"""
        Sets the BSDF measurement to a file identified by ``filename``.

        :rtype: int
        :return: 
                              -  0: Success.
                              - -1: Invalid parameters (``NULL`` pointer).
                              - -2: Failure to resolve the given filename, e.g., the file does not
                                    exist.
                              - -3: Invalid file format or invalid filename extension (only ``.mbsdf`` is
                                    supported).

        See also: #mi::neuraylib::IMdl_factory::create_bsdf_measurement() for a way to create a BSDF
             measurement based on an MDL file path instead of a filename.
        """
        return _pymdlsdk._IBsdf_measurement_reset_file(self, filename)

    def reset_reader(self, reader):
        r"""
        Sets the BSDF measurement to the data provided by a reader.

        :type reader: mi::neuraylib::IReader
        :param reader:      The reader that provides the data for the BSDF measurement in ``.mbsdf``
                               format.
        :rtype: int
        :return: 
                               -  0: Success.
                               - -1: Invalid parameters (``NULL`` pointer).
                               - -3: Invalid file format.
        """
        return _pymdlsdk._IBsdf_measurement_reset_reader(self, reader)

    def get_filename(self):
        r"""
        Returns the resolved file name of the file containing the BSDF measurement.

        The method returns ``NULL`` if there is no file associated with the BSDF measurement, e.g.,
        after default construction, calls to #set_reflection() or #set_transmission(), or failures
        to resolves the file name passed to #reset_file().

        See also: #get_original_filename()
        """
        return _pymdlsdk._IBsdf_measurement_get_filename(self)

    def get_original_filename(self):
        r"""
        Returns the unresolved file name as passed to #reset_file().

        The method returns ``NULL`` after default construction or calls to #set_reflection() or
        #set_transmission().

        See also: #get_filename()
        """
        return _pymdlsdk._IBsdf_measurement_get_original_filename(self)

    def set_reflection(self, bsdf_data):
        r"""
        Sets the BSDF data for the reflection.

        :type bsdf_data: mi::neuraylib::IBsdf_isotropic_data
        :param bsdf_data:   The BSDF data to be used by this BSDF measurement. The value ``NULL``
                               can be used to remove the BSDF data for reflection.
        :rtype: int
        :return: 
                               -  0: Success.
                               - -2: The resolution or type of ``bsdf_data`` is invalid.
        """
        return _pymdlsdk._IBsdf_measurement_set_reflection(self, bsdf_data)

    def get_reflection(self):
        r"""
        Returns the BSDF data for the reflection.

        Note that it is not possible to manipulate the BSDF data.

        :rtype: mi::base::IInterface
        :return: The BSDF data for reflection, or ``NULL`` if there is none.
        """
        return _pymdlsdk._IBsdf_measurement_get_reflection(self)

    def set_transmission(self, bsdf_data):
        r"""
        Sets the BSDF data for transmission.

        :type bsdf_data: mi::neuraylib::IBsdf_isotropic_data
        :param bsdf_data:   The BSDF data to be used by this BSDF measurement. The value ``NULL``
                               can be used to remove the BSDF data for transmission.
        :rtype: int
        :return: 
                               -  0: Success.
                               - -2: The resolution or type of ``bsdf_data`` is invalid.
        """
        return _pymdlsdk._IBsdf_measurement_set_transmission(self, bsdf_data)

    def get_transmission(self):
        r"""
        Returns the BSDF data for transmission.

        Note that it is not possible to manipulate the BSDF data.

        :rtype: mi::base::IInterface
        :return: The BSDF data for transmission, or ``NULL`` if there is none.
        """
        return _pymdlsdk._IBsdf_measurement_get_transmission(self)

# Register _IBsdf_measurement in _pymdlsdk:
_pymdlsdk._IBsdf_measurement_swigregister(_IBsdf_measurement)

class Interface_declare_ICanvas_base(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_ICanvas_base_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_ICanvas_base

# Register Interface_declare_ICanvas_base in _pymdlsdk:
_pymdlsdk.Interface_declare_ICanvas_base_swigregister(Interface_declare_ICanvas_base)

def Interface_declare_ICanvas_base_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_ICanvas_base_compare_iid(iid)

class _ICanvas_base(Interface_declare_ICanvas_base):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_resolution_x(self):
        r""" Returns the resolution of the canvas in x direction."""
        return _pymdlsdk._ICanvas_base_get_resolution_x(self)

    def get_resolution_y(self):
        r""" Returns the resolution of the canvas in y direction."""
        return _pymdlsdk._ICanvas_base_get_resolution_y(self)

    def get_type(self):
        r"""
        Returns the pixel type used by the canvas.

        See also: 'mi_neuray_types' for a list of supported pixel types
        """
        return _pymdlsdk._ICanvas_base_get_type(self)

    def get_layers_size(self):
        r""" Returns the number of layers this canvas has."""
        return _pymdlsdk._ICanvas_base_get_layers_size(self)

    def get_gamma(self):
        r"""
        Returns the gamma value.

        The gamma value should be a positive number. Typical values are 2.2 for LDR pixel types, and
        1.0 for HDR pixel types.
        """
        return _pymdlsdk._ICanvas_base_get_gamma(self)

    def set_gamma(self, gamma):
        r"""
        Sets the gamma value.

        Notes: This method just sets the gamma value. It does *not* change the pixel data itself.
        """
        return _pymdlsdk._ICanvas_base_set_gamma(self, gamma)

# Register _ICanvas_base in _pymdlsdk:
_pymdlsdk._ICanvas_base_swigregister(_ICanvas_base)

class Interface_declare_ICanvas(_ICanvas_base):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_ICanvas_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_ICanvas

# Register Interface_declare_ICanvas in _pymdlsdk:
_pymdlsdk.Interface_declare_ICanvas_swigregister(Interface_declare_ICanvas)

def Interface_declare_ICanvas_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_ICanvas_compare_iid(iid)

class _ICanvas(Interface_declare_ICanvas):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_tile(self, *args):
        r"""
        *Overload 1:*
        Returns the tile for the given layer.

        :type layer: int, optional
        :param layer:     The layer of the pixel in the canvas.
        :rtype: :py:class:`ITile`
        :return: The tile that contains the pixel, or ``NULL`` in case of invalid
                             parameters.

        |

        *Overload 2:*
        Returns the tile for the given layer.

        :type layer: int, optional
        :param layer:     The layer of the pixel in the canvas.
        :rtype: :py:class:`ITile`
        :return: The tile that contains the pixel, or ``NULL`` in case of invalid
                             parameters.

        |

        *Overload 3:*
        Returns the tile for the given layer.

        :param layer:     The layer of the pixel in the canvas.
        :rtype: :py:class:`ITile`
        :return: The tile that contains the pixel, or ``NULL`` in case of invalid
                             parameters.
        """
        return _pymdlsdk._ICanvas_get_tile(self, *args)

# Register _ICanvas in _pymdlsdk:
_pymdlsdk._ICanvas_swigregister(_ICanvas)

SLOT_THIN_WALLED = _pymdlsdk.SLOT_THIN_WALLED
r""" Slot thin_walled"""
SLOT_SURFACE_SCATTERING = _pymdlsdk.SLOT_SURFACE_SCATTERING
r""" Slot surface.scattering"""
SLOT_SURFACE_EMISSION_EDF_EMISSION = _pymdlsdk.SLOT_SURFACE_EMISSION_EDF_EMISSION
r""" Slot surface.emission.emission"""
SLOT_SURFACE_EMISSION_INTENSITY = _pymdlsdk.SLOT_SURFACE_EMISSION_INTENSITY
r""" Slot surface.emission.intensity"""
SLOT_SURFACE_EMISSION_MODE = _pymdlsdk.SLOT_SURFACE_EMISSION_MODE
r""" Slot surface.emission.mode"""
SLOT_BACKFACE_SCATTERING = _pymdlsdk.SLOT_BACKFACE_SCATTERING
r""" Slot backface.scattering"""
SLOT_BACKFACE_EMISSION_EDF_EMISSION = _pymdlsdk.SLOT_BACKFACE_EMISSION_EDF_EMISSION
r""" Slot backface.emission.emission"""
SLOT_BACKFACE_EMISSION_INTENSITY = _pymdlsdk.SLOT_BACKFACE_EMISSION_INTENSITY
r""" Slot backface.emission.intensity"""
SLOT_BACKFACE_EMISSION_MODE = _pymdlsdk.SLOT_BACKFACE_EMISSION_MODE
r""" Slot backface.emission.mode"""
SLOT_IOR = _pymdlsdk.SLOT_IOR
r""" Slot ior"""
SLOT_VOLUME_SCATTERING = _pymdlsdk.SLOT_VOLUME_SCATTERING
r""" Slot volume.scattering"""
SLOT_VOLUME_ABSORPTION_COEFFICIENT = _pymdlsdk.SLOT_VOLUME_ABSORPTION_COEFFICIENT
r""" Slot volume.absorption_coefficient"""
SLOT_VOLUME_SCATTERING_COEFFICIENT = _pymdlsdk.SLOT_VOLUME_SCATTERING_COEFFICIENT
r""" Slot volume.scattering_coefficient"""
SLOT_GEOMETRY_DISPLACEMENT = _pymdlsdk.SLOT_GEOMETRY_DISPLACEMENT
r""" Slot geometry.displacement"""
SLOT_GEOMETRY_CUTOUT_OPACITY = _pymdlsdk.SLOT_GEOMETRY_CUTOUT_OPACITY
r""" Slot geometry.cutout_opacity"""
SLOT_GEOMETRY_NORMAL = _pymdlsdk.SLOT_GEOMETRY_NORMAL
r""" Slot geometry.normal"""
SLOT_HAIR = _pymdlsdk.SLOT_HAIR
r""" Slot hair"""
SLOT_FIRST = _pymdlsdk.SLOT_FIRST
r""" First slot"""
SLOT_LAST = _pymdlsdk.SLOT_LAST
r""" Last slot"""
SLOT_FORCE_32_BIT = _pymdlsdk.SLOT_FORCE_32_BIT
OPACITY_OPAQUE = _pymdlsdk.OPACITY_OPAQUE
r""" material is opaque"""
OPACITY_TRANSPARENT = _pymdlsdk.OPACITY_TRANSPARENT
r""" material is transparent"""
OPACITY_UNKNOWN = _pymdlsdk.OPACITY_UNKNOWN
r""" material might be transparent"""
OPACITY_FORCE_32_BIT = _pymdlsdk.OPACITY_FORCE_32_BIT
class Interface_declare_ICompiled_material(_IScene_element):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_ICompiled_material_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_ICompiled_material

# Register Interface_declare_ICompiled_material in _pymdlsdk:
_pymdlsdk.Interface_declare_ICompiled_material_swigregister(Interface_declare_ICompiled_material)

def Interface_declare_ICompiled_material_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_ICompiled_material_compare_iid(iid)

class _ICompiled_material(Interface_declare_ICompiled_material):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_body(self):
        r""" Returns the direct call expression that represents the body of the compiled material."""
        return _pymdlsdk._ICompiled_material_get_body(self)

    def get_temporary_count(self):
        r""" Returns the number of temporaries used by this compiled material."""
        return _pymdlsdk._ICompiled_material_get_temporary_count(self)

    def get_temporary(self, index):
        r"""
        Returns the expression of a temporary.

        :type index: int
        :param index:            The index of the temporary.
        :rtype: :py:class:`IExpression`
        :return: The expression of the temporary, or ``NULL`` if ``index`` is out of
                                    range.
        """
        return _pymdlsdk._ICompiled_material_get_temporary(self, index)

    def get_mdl_meters_per_scene_unit(self):
        r""" Returns the conversion ration between meters and scene units for this material."""
        return _pymdlsdk._ICompiled_material_get_mdl_meters_per_scene_unit(self)

    def get_mdl_wavelength_min(self):
        r""" Returns the smallest supported wavelength."""
        return _pymdlsdk._ICompiled_material_get_mdl_wavelength_min(self)

    def get_mdl_wavelength_max(self):
        r""" Returns the largest supported wavelength."""
        return _pymdlsdk._ICompiled_material_get_mdl_wavelength_max(self)

    def depends_on_state_transform(self):
        r"""
        Indicates whether this material depends on coordinate space transformations like
        ``%state::transform()`` and related functions.
        """
        return _pymdlsdk._ICompiled_material_depends_on_state_transform(self)

    def depends_on_state_object_id(self):
        r""" Indicates whether this material depends on ``state::object_id()``."""
        return _pymdlsdk._ICompiled_material_depends_on_state_object_id(self)

    def depends_on_global_distribution(self):
        r""" Indicates whether this material depends on global distribution (edf)."""
        return _pymdlsdk._ICompiled_material_depends_on_global_distribution(self)

    def depends_on_uniform_scene_data(self):
        r""" Indicates whether this material depends on uniform scene data."""
        return _pymdlsdk._ICompiled_material_depends_on_uniform_scene_data(self)

    def get_referenced_scene_data_count(self):
        r""" Returns the number of scene data attributes referenced by this instance."""
        return _pymdlsdk._ICompiled_material_get_referenced_scene_data_count(self)

    def get_referenced_scene_data_name(self, index):
        r"""
        Return the name of a scene data attribute referenced by this instance.

        :type index: int
        :param index:  the index of the scene data attribute
        """
        return _pymdlsdk._ICompiled_material_get_referenced_scene_data_name(self, index)

    def get_parameter_count(self):
        r""" Returns the number of parameters used by this compiled material."""
        return _pymdlsdk._ICompiled_material_get_parameter_count(self)

    def get_parameter_name(self, index):
        r"""
        Returns the name of a parameter.

        Note that the parameter name is only available if the corresponding parameter of the
        original material instance has a constant as argument. If that argument is a call,
        ``NULL`` is returned.
        """
        return _pymdlsdk._ICompiled_material_get_parameter_name(self, index)

    def get_argument(self, index):
        r"""
        Returns the value of an argument.

        :type index: int
        :param index:            The index of the argument.
        :rtype: :py:class:`IValue`
        :return: The value of the argument, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk._ICompiled_material_get_argument(self, index)

    def get_hash(self):
        r"""
        Returns a hash of the body and all temporaries.

        The hash allows to quickly identify compiled materials that have the same body and
        temporaries. Note that the arguments are not included in the hash value.

        Notes: For performance reasons, the hash for resources does not include the actual resource
              data, but certain properties to identify resources: If the absolute MDL file path is
              available, it is used (including the gamma value for textures). If the absolute MDL
              file path is not available, some internal IDs that identify the resource in the
              database are used instead.

              For the latter case, the following applies: If two otherwise identical materials share
              a resource (in the sense of there is one and only one DB element for that resource),
              then their hash is also identical. But if the materials use distinct (but otherwise
              identical) copies of the same DB element, then their IDs are different, resulting in
              different hashes. IDs are also different if a module is removed from the database, and
              later loaded again. IDs might be different if the module is loaded in different
              processes.

        See also: #get_slot_hash() for hashes for individual material slots
        """
        return _pymdlsdk._ICompiled_material_get_hash(self)

    def get_slot_hash(self, slot):
        r"""
        Returns the hash of a particular material slot.

        The slots hashes allow to quickly compare slots of compiled materials. Note that the
        arguments are not included in the hash value.

        Notes: For performance reasons, the hash for resources does not include the actual resource
              data, but certain properties to identify resources: If the absolute MDL file path is
              available, it is used (including the gamma value for textures). If the absolute MDL
              file path is not available, some internal IDs that identify the resource in the
              database are used instead.

              For the latter case, the following applies: If two otherwise identical materials share
              a resource (in the sense of there is one and only one DB element for that resource),
              then their hash is also identical. But if the materials use distinct (but otherwise
              identical) copies of the same DB element, then their IDs are different, resulting in
              different hashes. IDs are also different if a module is removed from the database, and
              later loaded again. IDs might be different if the module is loaded in different
              processes.

        See also: #get_hash() for a hash covering all slots together
        """
        return _pymdlsdk._ICompiled_material_get_slot_hash(self, slot)

    def lookup_sub_expression(self, path):
        r"""
        Looks up a sub-expression of the compiled material.

        :type path: string
        :param path:            The path from the material root to the expression that should be
                                   returned, e.g., ``"surface.scattering.tint"``.
        :rtype: :py:class:`IExpression`
        :return: A sub-expression for ``expr`` according to ``path``, or ``NULL`` in case
                                   of errors.
        """
        return _pymdlsdk._ICompiled_material_lookup_sub_expression(self, path)

    def get_connected_function_db_name_with_ret(self, material_instance_name, parameter_index):
        r"""
        Looks up the database name of the mdl instance connected to the argument of a compiled
        material.

        The parameters on the compiled material in class compilation mode can have more complex
        names if a shade graph has been compiled. The name corresponds to a path through the shade
        graph identifying a node and a parameter on that node whose value should be passed into
        the parameter of the compiled result. For example, the path "a.b.x" refers to a parameter
        named x on a node connected to a parameter named b on a node connected to the parameter a
        of the material that has been compiled.
        :type material_instance_name: string
        :param material_instance_name:   The name of the material instance this material was
                                            compiled from.
        :type parameter_index: int
        :param parameter_index:          The index of the parameter for which the database name of
                                            the connected function is to be looked up (e.g. if the
                                            compiled material has a parameter named ``"tint.s.texture"``
                                            the function returns the database name of the function
                                            connected to the tint parameter.
        :type errors: int, optional
        :param errors:                   An optional pointer to an #mi::Sint32 to which an error
                                               code will be written. The error codes have the following
                                               meaning:
                                               -  0: Success.
                                               - -1: The parameter material_instance_name is NULL or a
                                                     material instance of that name does not exist in
                                                     the database.
                                               - -2: The given parameter index exceeds the parameter
                                                     count of the compiled material.
                                               - -3: The function could not be found in the database.
                                                     This might be due to the fact that the given
                                                     parameter is not connected to a function or the
                                                     material instance has been changed after the
                                                     creation of this compiled material.
        :rtype: :py:class:`IString`
        :return: The database name of the connected function or NULL in case an error occurred.
        """
        return _pymdlsdk._ICompiled_material_get_connected_function_db_name_with_ret(self, material_instance_name, parameter_index)

    def get_connected_function_db_name(self, material_instance_name, parameter_index):
        r"""
        Looks up the database name of the mdl instance connected to the argument of a compiled
        material.

        The parameters on the compiled material in class compilation mode can have more complex
        names if a shade graph has been compiled. The name corresponds to a path through the shade
        graph identifying a node and a parameter on that node whose value should be passed into
        the parameter of the compiled result. For example, the path "a.b.x" refers to a parameter
        named x on a node connected to a parameter named b on a node connected to the parameter a
        of the material that has been compiled.
        :type material_instance_name: string
        :param material_instance_name:   The name of the material instance this material was
                                            compiled from.
        :type parameter_index: int
        :param parameter_index:          The index of the parameter for which the database name of
                                            the connected function is to be looked up (e.g. if the
                                            compiled material has a parameter named ``"tint.s.texture"``
                                            the function returns the database name of the function
                                            connected to the tint parameter.
        :param errors:                   An optional pointer to an #mi::Sint32 to which an error
                                               code will be written. The error codes have the following
                                               meaning:
                                               -  0: Success.
                                               - -1: The parameter material_instance_name is NULL or a
                                                     material instance of that name does not exist in
                                                     the database.
                                               - -2: The given parameter index exceeds the parameter
                                                     count of the compiled material.
                                               - -3: The function could not be found in the database.
                                                     This might be due to the fact that the given
                                                     parameter is not connected to a function or the
                                                     material instance has been changed after the
                                                     creation of this compiled material.
        :rtype: :py:class:`IString`
        :return: The database name of the connected function or NULL in case an error occurred.
        """
        return _pymdlsdk._ICompiled_material_get_connected_function_db_name(self, material_instance_name, parameter_index)

    def get_opacity(self):
        r"""
        Returns the opacity of the material.

        First, the cutout_opacity is checked. In case of opaque
        materials it is checked if a transmissive BSDF is present in the ``surface.scattering``
        slot of the material.
        """
        return _pymdlsdk._ICompiled_material_get_opacity(self)

    def get_surface_opacity(self):
        r"""
        Returns the surface opacity of the material by checking, if a
        transmissive BSDF is present in the ``surface.scattering`` slot of
        the material.
        """
        return _pymdlsdk._ICompiled_material_get_surface_opacity(self)

    def get_cutout_opacity(self, cutout_opacity):
        r"""
        Returns the cutout opacity of the material if it is constant.

        :type cutout_opacity: float, out
        :param cutout_opacity:  get the cutout_opacity value of the material

        :rtype: boolean
        :return: ``true`` in case of success, ``false`` if the value is not a constant, but depends on
                     parameters or complex user expressions
        """
        return _pymdlsdk._ICompiled_material_get_cutout_opacity(self, cutout_opacity)

    def is_valid(self, context):
        r"""
        Returns ``true``, if the compiled material is valid, ``false`` otherwise.

        :type context: :py:class:`IMdl_execution_context`
        :param context:     In case of failure, the execution context can be checked for error
                               messages. Can be ``NULL``.

        A compiled material becomes invalid, if any of the modules it uses definitions from has
        has been reloaded.
        """
        return _pymdlsdk._ICompiled_material_is_valid(self, context)

# Register _ICompiled_material in _pymdlsdk:
_pymdlsdk._ICompiled_material_swigregister(_ICompiled_material)

LIGHTPROFILE_CLOCKWISE = _pymdlsdk.LIGHTPROFILE_CLOCKWISE
r""" Clockwise order, contrary to the IES standard for these (incorrect) type B files."""
LIGHTPROFILE_COUNTER_CLOCKWISE = _pymdlsdk.LIGHTPROFILE_COUNTER_CLOCKWISE
r""" Counter-clockwise, standard-conforming order (default)."""
LIGHTPROFILE_ROTATE_TYPE_B = _pymdlsdk.LIGHTPROFILE_ROTATE_TYPE_B
r""" For 3dsmax"""
LIGHTPROFILE_ROTATE_TYPE_C_90_270 = _pymdlsdk.LIGHTPROFILE_ROTATE_TYPE_C_90_270
r""" For 3dsmax"""
LIGHTPROFILE_FLAGS_FORCE_32_BIT = _pymdlsdk.LIGHTPROFILE_FLAGS_FORCE_32_BIT
LIGHTPROFILE_HERMITE_BASE_1 = _pymdlsdk.LIGHTPROFILE_HERMITE_BASE_1
r""" Degree 1 = linear interpolation"""
LIGHTPROFILE_HERMITE_BASE_3 = _pymdlsdk.LIGHTPROFILE_HERMITE_BASE_3
r""" Degree 3 = cubic interpolation"""
LIGHTPROFILE_DEGREE_FORCE_32_BIT = _pymdlsdk.LIGHTPROFILE_DEGREE_FORCE_32_BIT
class Interface_declare_ILightprofile(_IScene_element):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_ILightprofile_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_ILightprofile

# Register Interface_declare_ILightprofile in _pymdlsdk:
_pymdlsdk.Interface_declare_ILightprofile_swigregister(Interface_declare_ILightprofile)

def Interface_declare_ILightprofile_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_ILightprofile_compare_iid(iid)

class _ILightprofile(Interface_declare_ILightprofile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def reset_file(self, *args):
        r"""
        Sets the light profile to a file identified by ``filename``.

        :type filename: string
        :param filename:           The new file containing the light profile data.
        :type resolution_phi: int, optional
        :param resolution_phi:     The desired resolution of the equidistant grid in phi-direction.


                                      The special value 0 leaves the choice of a suitable resolution to
                                      the implementation. Currently, the implementation behaves as
                                      follows: If the angles in phi-direction are already equidistant,
                                      the resolution in the file itself (after unfolding of symmetries)
                                      is kept unchanged. If the angles in phi-direction are not
                                      equidistant, a suitable resolution that maintains the angles given
                                      in the file is chosen. If that fails, a fixed resolution is
                                      chosen.
        :type resolution_theta: int, optional
        :param resolution_theta:   The desired resolution of the equidistant grid in theta-direction.


                                      The special value 0 leaves the choice of a suitable resolution to
                                      the implementation. Currently, the implementation behaves as
                                      follows: If the angles in theta-direction are already equidistant,
                                      the resolution in the file itself (after unfolding of symmetries)
                                      is kept unchanged. If the angles in theta-direction are not
                                      equidistant, a suitable resolution that maintains the angles given
                                      in the file is chosen. If that fails, a fixed resolution is
                                      chosen.
        :type degree: int, optional
        :param degree:             The interpolation method to use.
        :type flags: int, optional
        :param flags:              Flags to be used when interpreting the file data,
                                      see #mi::neuraylib::Lightprofile_flags for details.
        :rtype: int
        :return: 
                                      -  0: Success.
                                      - -1: Invalid parameters (``NULL`` pointer).
                                      - -2: Failure to resolve the given filename, e.g., the file does
                                            not exist.
                                      - -3: ``degree`` or ``flags`` is invalid (exactly one of
                                            #mi::neuraylib::LIGHTPROFILE_CLOCKWISE or
                                            #mi::neuraylib::LIGHTPROFILE_COUNTER_CLOCKWISE must be set).
                                      - -4: File format error.
                                      - -5: ``resolution_phi`` or ``resolution_theta`` is invalid (must
                                            not be 1).

        See also: #mi::neuraylib::IMdl_factory::create_light_profile() for a way to create a light
             profile based on an MDL file path instead of a filename.
        """
        return _pymdlsdk._ILightprofile_reset_file(self, *args)

    def reset_reader(self, *args):
        r"""
        Sets the light profile to the data provided by a reader.

        :type reader: mi::neuraylib::IReader
        :param reader:             The reader that provides the data for the BSDF measurement in
                                      ``.ies`` format.
        :type resolution_phi: int, optional
        :param resolution_phi:     The desired resolution of the equidistant grid in phi-direction.


                                      The special value 0 leaves the choice of a suitable resolution to
                                      the implementation. Currently, the implementation behaves as
                                      follows: If the angles in phi-direction are already equidistant,
                                      the resolution in the file itself (after unfolding of symmetries)
                                      is kept unchanged. If the angles in phi-direction are not
                                      equidistant, a suitable resolution that maintains the angles given
                                      in the file is chosen. If that fails, a fixed resolution is
                                      chosen.
        :type resolution_theta: int, optional
        :param resolution_theta:   The desired resolution of the equidistant grid in theta-direction.


                                      The special value 0 leaves the choice of a suitable resolution to
                                      the implementation. Currently, the implementation behaves as
                                      follows: If the angles in theta-direction are already equidistant,
                                      the resolution in the file itself (after unfolding of symmetries)
                                      is kept unchanged. If the angles in theta-direction are not
                                      equidistant, a suitable resolution that maintains the angles given
                                      in the file is chosen. If that fails, a fixed resolution is
                                      chosen.
        :type degree: int, optional
        :param degree:             The interpolation method to use.
        :type flags: int, optional
        :param flags:              Flags to be used when interpreting the data,
                                      see #mi::neuraylib::Lightprofile_flags for details.
        :rtype: int
        :return: 
                                      -  0: Success.
                                      - -1: Invalid parameters (``NULL`` pointer).
                                      - -3: ``degree`` or ``flags`` is invalid (exactly one of
                                            #mi::neuraylib::LIGHTPROFILE_CLOCKWISE or
                                            #mi::neuraylib::LIGHTPROFILE_COUNTER_CLOCKWISE must be set).
                                      - -4: File format error.
                                      - -5: ``resolution_phi`` or ``resolution_theta`` is invalid (must
                                            not be 1).
        """
        return _pymdlsdk._ILightprofile_reset_reader(self, *args)

    def get_filename(self):
        r"""
        Returns the resolved file name of the file containing the light profile.

        The method returns ``NULL`` if there is no file associated with the light profile, e.g.,
        after default construction or failures to resolve the file name passed to #reset_file().

        See also: #get_original_filename()
        """
        return _pymdlsdk._ILightprofile_get_filename(self)

    def get_original_filename(self):
        r"""
        Returns the unresolved file name as passed to #reset_file().

        The method returns ``NULL`` after default construction.

        See also: #get_filename()
        """
        return _pymdlsdk._ILightprofile_get_original_filename(self)

    def get_resolution_phi(self):
        r""" Returns the resolution of the grid in phi-direction, or 0 after default construction."""
        return _pymdlsdk._ILightprofile_get_resolution_phi(self)

    def get_resolution_theta(self):
        r""" Returns the resolution of the grid in theta-direction, or 0 after default construction."""
        return _pymdlsdk._ILightprofile_get_resolution_theta(self)

    def get_degree(self):
        r"""
        Returns the interpolation degree that was used to interpolate the grid data, or
        #mi::neuraylib::LIGHTPROFILE_HERMITE_BASE_1 after default construction.
        """
        return _pymdlsdk._ILightprofile_get_degree(self)

    def get_flags(self):
        r"""
        Returns flags that were used to interpret the light profile data in the file, or
        #mi::neuraylib::LIGHTPROFILE_COUNTER_CLOCKWISE after default construction.

        See also: #mi::neuraylib::Lightprofile_flags.
        """
        return _pymdlsdk._ILightprofile_get_flags(self)

    def get_phi(self, index):
        r"""
        Returns the ``index`` -th phi value.

        Note that the grid is an equidistant grid, i.e., the distance between subsequent phi values
        is always the same. If ``index`` is out of bounds or after default construction, 0 is
        returned.
        """
        return _pymdlsdk._ILightprofile_get_phi(self, index)

    def get_theta(self, index):
        r"""
        Returns the ``index`` -th theta value.

        Note that the grid is an equidistant grid, i.e., the distance between subsequent theta
        values is always the same. If ``index`` is out of bounds or after default construction, 0 is
        returned.
        """
        return _pymdlsdk._ILightprofile_get_theta(self, index)

    def get_data(self, *args):
        r"""
        *Overload 1:*
        Returns the normalized data of the entire grid.

        :rtype: float
        :return: A pointer to the normalized data for all vertices of the grid. The data values are
                      stored as array in column-major order (where all elements of a column have the
                      same phi value). Returns ``NULL`` after default construction.

        See also: #get_candela_multiplier()

        |

        *Overload 2:*
        Returns the normalized data for a grid vertex.

        :type index_phi: int
        :param index_phi:     Index in phi-direction of the vertex.
        :type index_theta: int
        :param index_theta:   Index in theta-direction of the vertex.
        :rtype: float
        :return: The normalized data for the grid point, or 0 in case of errors or after
                                 default construction.

        See also: #get_candela_multiplier(), #sample()
        """
        return _pymdlsdk._ILightprofile_get_data(self, *args)

    def get_candela_multiplier(self):
        r"""
        Returns the normalization factor.

        All data is normalized such that the maximum is 1.0. The values returned by methods like
        #get_data() need to be multiplied by this normalization factor to retrieve the true value.
        Returns 0 after default construction.
        """
        return _pymdlsdk._ILightprofile_get_candela_multiplier(self)

    def sample(self, phi, theta, candela):
        r"""
        Samples the light profile.

        The method computes a bi-linear interpolation of the light profile at (phi,theta) according
        to the resolution.

        :type phi: float
        :param phi:       First dimension of sample point.
        :type theta: float
        :param theta:     Second dimension of sample point.
        :type candela: boolean
        :param candela:   If ``false``, normalized values are returned, otherwise true values.
                             See #get_candela_multiplier().
        :rtype: float
        :return: The computed sample value, or 0 in case of errors or after default
                             construction.

        See also: #get_data()
        """
        return _pymdlsdk._ILightprofile_sample(self, phi, theta, candela)

# Register _ILightprofile in _pymdlsdk:
_pymdlsdk._ILightprofile_swigregister(_ILightprofile)

class Interface_declare_ITransaction(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_ITransaction_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_ITransaction

# Register Interface_declare_ITransaction in _pymdlsdk:
_pymdlsdk.Interface_declare_ITransaction_swigregister(Interface_declare_ITransaction)

def Interface_declare_ITransaction_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_ITransaction_compare_iid(iid)

class _ITransaction(Interface_declare_ITransaction):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def commit(self):
        r"""
        Commits the transaction.

        Note that a commit() implicitly closes the transaction.
        A closed transaction does not allow any future operations and needs to be released.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Unspecified failure.
                                - -3: The transaction is not open.
        """
        return _pymdlsdk._ITransaction_commit(self)

    def abort(self):
        r"""
        If not: MDL_SDK_API {
        Aborts the transaction.

        Note that an abort() implicitly closes the transaction.
        A closed transaction does not allow any future operations and needs to be released.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk._ITransaction_abort(self)

    def is_open(self):
        r"""
        Indicates whether the transaction is open.

        :rtype: boolean
        :return: ``true`` if the transaction is still open, or ``false`` if the transaction is
                      closed, i.e., it has been committed or aborted.
        """
        return _pymdlsdk._ITransaction_is_open(self)

    def create(self, type_name, argc=0, argv=0):
        r"""
        Creates an object of the type ``type_name``.

        Objects created with this method are typically If: IRAY_API { 'mi_neuray_types',
        'mi_neuray_scene_element' and 'mi_neuray_functors'. It is also possible to create
        instances of user-defined classes. }Else:  { and
        'mi_neuray_scene_element'. } Note that most types can also be created via the API
        component #mi::neuraylib::IFactory which does not require the context of a transaction.

        This method can not be used to create MDL modules, definitions, or function calls. To
        create instances of #mi::neuraylib::IFunction_call, use the method
        #mi::neuraylib::IFunction_definition::create_function_call().

        The created object will be initialized in a manner dependent upon the passed type
        name. Each class has its own policy on initialization. So, one should not make any
        assumptions on the values of the various class members.

        :type type_name: string
        :param type_name:    The type name of the object to create. See 'mi_neuray_types' for
                                possible type names. In addition, 'mi_neuray_scene_element'
                            If: IRAY_API { and 'mi_neuray_functors' } can be created by
                            passing the name of the requested interfaces without namespace
                            qualifiers and the leading ``"I"``, e.g., ``"Image"`` for
                            #mi::neuraylib::IImage. If: IRAY_API { Names of user-defined classes are
                            also valid arguments. } Note that you can not create instances of
                            #mi::neuraylib::IAttribute_set or #mi::neuraylib::IScene_element, only
                            instances of the derived interfaces If: IRAY_API { (see also
                            #mi::neuraylib::IAttribute_container) } .
        :type argc: int, optional
        :param argc:         The number of elements in ``argv``. Passed to the constructor of factory
                                of the object to create.
        :type argv: mi::base::IInterface, optional
        :param argv:         The array of arguments passed to the constructor. Passed to the
                                constructor of factory of the object to create.
        :rtype: mi::base::IInterface
        :return: A pointer to the created object, or ``NULL`` if ``type_name`` is invalid
                                (``NULL`` pointer) or not a valid type name.
        """
        return _pymdlsdk._ITransaction_create(self, type_name, argc, argv)
    LOCAL_SCOPE = _pymdlsdk._ITransaction_LOCAL_SCOPE
    r"""
    Symbolic privacy level for the privacy level of the scope of this transaction.

    This symbolic constant can be passed to #store() and #copy() to indicate the privacy level
    of the scope of this transaction. It has the same affect as passing the result of
    #mi::neuraylib::IScope::get_privacy_level(), but is more convenient.
    """

    def store(self, *args):
        r"""
        Stores the element ``db_element`` in the database under the name ``name`` and with the privacy
        level ``privacy``.

        After a successful store operation the passed interface pointer must no longer be used,
        except for releasing it. This is due to the fact that after a #store() the database
        retains ownership of the stored data. You can obtain the stored version from the database
        using the #access() or #edit() methods.

        Notes: **Overwriting vs editing of existing DB elements**

              While it is possible to overwrite existing DB elements, for performance reasons it is
              often better to edit the already existing DB element instead. Editing a DB element
              allows the DB to keep track of the type of changes which might help render modes to
              update their data structures more efficiently. When overwriting an existing DB element
              such information is not available and pessimistic assumptions have to be made which
              may result in lower performance.

        :type db_element: mi::base::IInterface
        :param db_element: The #mi::base::IInterface to store.
        :type name: string
        :param name:       The name under which to store ``db_element``. If there exists already a DB
                              element with that name then it will be overwritten If: IRAY_API { (but see
                          also return code -9 below) } .
        :type privacy: mi::Uint8, optional
        :param privacy:    The privacy level under which to store ``db_element`` (in the range from 0
                              to the privacy level of the scope of this transaction). In addition, the
                              constant #LOCAL_SCOPE can be used as a shortcut to indicate the privacy
                              level of the scope of this transaction without supplying the actual value
                              itself.
        :rtype: int
        :return: 
                   -  0: Success.
                   - -1: Unspecified failure.
                   - -2: Invalid parameters (``NULL`` pointer).
                   - -3: The transaction is not open.
                   - -4: ``db_element`` is not a DB element.
                   - -5: Invalid privacy level.
                   - -6: ``db_element`` has already been stored previously.
                   - -7: The element is to be stored in a transaction different from the one that was
                         used to create it.
                   - -8: The element is a user-defined class that has not been If: IRAY_API {
                     registered (see #mi::neuraylib::IExtension_api::register_class()). }Else:  {              registered. }

               - -9: There is already an element of name ``name`` and overwriting elements of that
                     type is not supported. This applies to elements of type
                     #mi::neuraylib::IModule, #mi::neuraylib::IMaterial_definition, and
                     #mi::neuraylib::IFunction_definition.
                     It also applies to elements of type #mi::neuraylib::IFunction_call
                     and #mi::neuraylib::IMaterial_instance that are used as defaults
                     in an #mi::neuraylib::IMaterial_definition or
                     #mi::neuraylib::IFunction_definition.
        """
        return _pymdlsdk._ITransaction_store(self, *args)

    def _access(self, name):
        r"""
        Retrieves an element from the database.

        The database searches for the most recent version of the named DB element visible for the
        current transaction. That version will be returned.

        :type name: string
        :param name:   The name of the element to retrieve.
        :rtype: mi::base::IInterface
        :return: The requested element from the database, or ``NULL`` if ``name`` is invalid, no
                          DB element with that name exists, or the transaction is already closed.
        """
        return _pymdlsdk._ITransaction__access(self, name)

    def _edit(self, name):
        r"""
        Retrieves an element from the database and returns it ready for editing.

        The database searches for the most recent version of the named DB element visible for the
        current transaction. It will then make a copy of that version and return the copy. The
        edited DB element will be committed to the database automatically, when the obtained
        interface is released. It is neither necessary nor possible to store the edited element
        manually in the database using the #store() method.

        :type name: string
        :param name:   The name of the element to retrieve.
        :rtype: mi::base::IInterface
        :return: The requested element from the database, or ``NULL`` if ``name`` is invalid, no
                          DB element with that name exists, or the transaction is already closed.
        """
        return _pymdlsdk._ITransaction__edit(self, name)

    def copy(self, source, target, privacy=0):
        r"""
        Creates a copy of a database element.

        Note that DB elements of type #mi::neuraylib::IModule, #mi::neuraylib::IMaterial_definition,
        and #mi::neuraylib::IFunction_definition can not be copied.

        :type source: string
        :param source:    The name of the element to be copied.
        :type target: string
        :param target:    The desired name of the copy.
        :type privacy: mi::Uint8, optional
        :param privacy:   The desired privacy level of the copy (in the range from
                             0 to the privacy level of the scope of this transaction). In addition, the
                             constant #LOCAL_SCOPE can be used as a shortcut to indicate the privacy
                             level of the scope of this transaction without supplying the actual value
                             itself.
        :rtype: int
        :return: 
                             -  0: Success.
                             - -2: Invalid parameters (``NULL`` pointer).
                             - -3: The transaction is not open.
                             - -4: There is no DB element named ``source`` visible in this transaction.
                             - -5: Invalid privacy level.
                             - -6: DB elements of this type cannot be copied.
                             - -9: There is already an element of name ``name`` and overwriting elements
                                   of that type is not supported. This applies to elements of type
                                   #mi::neuraylib::IModule, #mi::neuraylib::IMaterial_definition, and
                                   #mi::neuraylib::IFunction_definition.
                                   It also applies to elements of type #mi::neuraylib::IFunction_call
                                   and #mi::neuraylib::IMaterial_instance that are used as defaults
                                   in an #mi::neuraylib::IMaterial_definition or
                                   #mi::neuraylib::IFunction_definition.
        """
        return _pymdlsdk._ITransaction_copy(self, source, target, privacy)

    def remove(self, name, only_localized=False):
        r"""
        Removes the element with the name ``name`` from the database.

        Note that the element continues to be stored in the database as long as it is referenced by
        other elements. If it is no longer referenced, and the last transaction were it was
        referenced has been committed, it will be lazily removed by the garbage collection of the
        DB. There is no guarantee when this will happen.

        This implies that a #remove() call might actually remove an element that was stored later
        under the same name. This can potentially lead to invalid tag accesses. Those cases can be
        avoided by using #mi::neuraylib::IDatabase::garbage_collection() after a transaction was
        committed and before starting the next one to force garbage collection of all possible
        elements.

        If: IRAY_API {
        See also 'mi_neuray_database_reuse_of_names' for more details and correct usage patterns.
        }

        :type name: string
        :param name:           The name of the element in the database to remove.
        :type only_localized: boolean, optional
        :param only_localized: If: MDL_SDK_API { Unused. }Else: If  {``true``, the element is only removed
                              if it exists in the scope of the transaction; parent scopes are not
                              considered. }
        :rtype: int
        :return: 
                                  -  0: Success.
                                  - -1: There is no DB element named ``name`` visible in this
                                        transaction (``only_localize`` is ``false)`` or there is no
                                        DB element named ``name`` in the scope of this transaction
                                        (``only_localized`` is ``true)``.
                                  - -2: Invalid parameters (``NULL`` pointer).
                                  - -3: The transaction is not open.
        """
        return _pymdlsdk._ITransaction_remove(self, name, only_localized)

    def name_of(self, db_element):
        r"""
        Returns the name of a database element.

        :type db_element: mi::base::IInterface
        :param db_element:   The DB element.
        :rtype: string
        :return: The name of the DB element, or ``NULL`` if ``db_element`` is invalid
                                (``NULL`` pointer), the object is not in the database, or the
                                transaction is already closed.
        """
        return _pymdlsdk._ITransaction_name_of(self, db_element)

    def get_time_stamp(self, *args):
        r"""
        *Overload 1:*
        Returns the time stamp describing the current "time".

        Notes: The time stamp is not related to time in the classical meaning. It rather relates to
              the current transaction and the number of database changes since the start of the
              transaction.

        The time stamp is only meaningful for the current MDL SDKinstance. It
              should not be put into external storage and re-used for different or later
              MDL SDKinstances.

        The return value of this method is only valid until the next call of this method
              (or one of its overloads) on this instance.

        See also: has_changed_since_time_stamp(), #get_time_stamp(const char*)const

        |

        *Overload 2:*
        Returns the time stamp of the last change of a database element.

        Notes: The time stamp is not related to time in the classical meaning. It rather relates to
              the transaction and the number of database changes since the start of the transaction
              when the database element was changed last.

        The time stamp is only meaningful for the current MDL SDKinstance. It
              should not be put into external storage and re-used for different or later
              MDL SDKinstances.

        The return value of this method is only valid until the next call of this method
              (or one of its overloads) on this instance.

        See also: has_changed_since_time_stamp(), #get_time_stamp()
        """
        return _pymdlsdk._ITransaction_get_time_stamp(self, *args)

    def has_changed_since_time_stamp(self, element, time_stamp):
        r"""
        Checks whether an element has been stored or changed in the database since a given time
        stamp.

        Notes: ``time_stamp`` should not stem from another concurrent transaction. Such changes will
              never be visible in this transaction, but the method might still return ``true``
              depending on the start order of the two transactions.

        In case of multiple overlapping transactions the returned answer may not list
              all changes due to the isolation of the transactions. If accurate results are
              required, transactions changing elements should be committed before transactions
              querying the journal for such changes are started.

        See also: #get_time_stamp(), #get_time_stamp(const char*)const

        :type element: string
        :param element:     The name of the element.
        :type time_stamp: string
        :param time_stamp:  The time stamp obtained from #get_time_stamp() or
                               #get_time_stamp(const char*)const.
        :rtype: boolean
        :return: ``true`` if the element has been stored or changed since the time stamp
                               (or if ``element`` or ``time_stamp`` is invalid, or there is no element
                               with that name), ``false`` otherwise.
        """
        return _pymdlsdk._ITransaction_has_changed_since_time_stamp(self, element, time_stamp)

    def get_id(self):
        r"""
        Returns the ID of this transaction.

        The transaction ID is of most use when debugging an application as the value returned allows
        one to correlate log messages and admin HTTP server output with the API actions.

        :rtype: string
        :return: The ID of the transaction.
        """
        return _pymdlsdk._ITransaction_get_id(self)

    def get_scope(self):
        r""" Returns the scope of this transaction."""
        return _pymdlsdk._ITransaction_get_scope(self)

    def list_elements(self, root_element, name_pattern=None, type_names=None):
        r"""
        Returns scene elements of a subgraph originating at a given scene element.

        The method iterates over all elements of a subgraph originating at the given scene element
        and returns their names. Optionally, the results can be filtered by a regular expression
        for the element names and a list for type names.

        Note that the runtime of the method depends on the number of elements in the subgraph. It
        might be expensive to call this method for large subgraphs.

        The returned scene elements are in such an order that all elements referenced by a given
        element are listed before that element ("before" in the sense of "using smaller array
        indices").

        :type root_element: string
        :param root_element:   The root of the subgraph to traverse.
        :type name_pattern: string, optional
        :param name_pattern:   An extended regular expression that acts as filter on the names of
                                  returned scene elements (see ['OGBS7])'. The regular expression
                                  is matched to *any* *part* of the scene element name, not just to
                                  the *entire* scene element name. The value ``NULL`` is handled as
                                  ``".*"``.
        :type type_names: :py:class:`IArray`, optional
        :param type_names:     A list of type names that acts as filter on the names of returned
                                  scene elements. Only scene elements with a matching type name pass
                                  the filter. The value ``NULL`` lets all scene elements pass the filter
                                  irrespective of their type name.
        :rtype: :py:class:`IArray`
        :return: A list of name of scene elements in the subgraph matching the given
                                  regular expression and type name filter, or ``NULL`` in case of
                                  an invalid root element name or an invalid regular expression.
        """
        return _pymdlsdk._ITransaction_list_elements(self, root_element, name_pattern, type_names)

    def get_privacy_level(self, name):
        r"""
        Returns the privacy level of the element with the name ``name``.

        :type name: string
        :param name:          The name of the element.
        :rtype: int
        :return: 
                                 - >= 0: Success. The privacy level of the element (in the range 0-255).
                                 -   -2: Invalid parameters (``NULL`` pointer).
                                 -   -3: The transaction is not open.
                                 -   -4: There is no DB element named ``name`` visible in this
                                         transaction.
        """
        return _pymdlsdk._ITransaction_get_privacy_level(self, name)

# Register _ITransaction in _pymdlsdk:
_pymdlsdk._ITransaction_swigregister(_ITransaction)

class IAttribute_set(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IAttribute_set_swiginit(self, _pymdlsdk.new_IAttribute_set(*args))
    __swig_destroy__ = _pymdlsdk.delete_IAttribute_set

    def __deref__(self):
        return _pymdlsdk.IAttribute_set___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IAttribute_set___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IAttribute_set_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IAttribute_set___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IAttribute_set___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IAttribute_set_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IAttribute_set_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IAttribute_set__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk.IAttribute_set_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk.IAttribute_set_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IAttribute_set_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IAttribute_set_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk.IAttribute_set_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk.IAttribute_set_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk.IAttribute_set_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk.IAttribute_set_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk.IAttribute_set_enumerate_attributes(self, index)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IAttribute_set_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IAttribute_set__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IAttribute_set__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IAttribute_set_get_iid(self)

# Register IAttribute_set in _pymdlsdk:
_pymdlsdk.IAttribute_set_swigregister(IAttribute_set)

def IAttribute_set_IID():
    return _pymdlsdk.IAttribute_set_IID()

def IAttribute_set__get_interface(iface):
    return _pymdlsdk.IAttribute_set__get_interface(iface)

class IBaker(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IBaker_swiginit(self, _pymdlsdk.new_IBaker(*args))
    __swig_destroy__ = _pymdlsdk.delete_IBaker

    def __deref__(self):
        return _pymdlsdk.IBaker___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IBaker___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IBaker_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IBaker___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IBaker___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IBaker_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IBaker_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IBaker__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_pixel_type(self):
        r""" Returns the pixel type that matches the expression to be baked best."""
        return _pymdlsdk.IBaker_get_pixel_type(self)

    def is_uniform(self):
        r"""
        Indicates whether the expression to be baked is uniform or varying.

        Typically, varying expressions are baked into textures, and uniform expressions into
        constant. However, it is also possible to do it the other way round.
        """
        return _pymdlsdk.IBaker_is_uniform(self)

    def bake_texture(self, texture, samples=1):
        r"""
        Bakes the expression as texture.

        :type texture: :py:class:`ICanvas`
        :param texture:   The baked texture will be stored in this canvas. If the pixel type of
           ``canvas`` does not match the pixel type of the expression to be baked (as
                             indicated by #get_pixel_type()), then the pixel data is converted as
                             described in #mi::neuraylib::IImage_api::convert().
        :type samples: int, optional
        :param samples:   The number of samples (per pixel).
        :rtype: int
        :return: 
                             -  0: Success.
                             - -1: Invalid parameters (``NULL`` pointer).
                             - -2: The transaction that is bound to this baker is no longer open.
                             - -3: The execution of the MDL code failed.
        """
        return _pymdlsdk.IBaker_bake_texture(self, texture, samples)

    def bake_constant(self, constant, samples=1):
        r"""
        Bakes the expression as constant.

        :type constant: :py:class:`IData`
        :param constant:  An instance of #mi::IData of suitable type such that the baked constant can
                             be stored in this argument. For pixel types ``"Float32"`` and
           ``"Float32<3>"`` the type name of this argument needs to match the pixel type.
                             For pixel type ``"Rgb_fp"`` this argument needs to have the type name
           ``"Color"``.
        :type samples: int, optional
        :param samples:   The (total) number of samples.
        :rtype: int
        :return: 
                             -  0: Success.
                             - -1: Invalid parameters (``NULL`` pointer).
                             - -2: The transaction that is bound to this baker is no longer open.
                             - -3: The execution of the MDL code failed.
                             - -4: The type of ``constant`` does not match the pixel type corresponding
                                    to the expression to be baked.
        """
        return _pymdlsdk.IBaker_bake_constant(self, constant, samples)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IBaker_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IBaker__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IBaker__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IBaker_get_iid(self)

# Register IBaker in _pymdlsdk:
_pymdlsdk.IBaker_swigregister(IBaker)

def IBaker_IID():
    return _pymdlsdk.IBaker_IID()

def IBaker__get_interface(iface):
    return _pymdlsdk.IBaker__get_interface(iface)

class IBsdf_measurement(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IBsdf_measurement_swiginit(self, _pymdlsdk.new_IBsdf_measurement(*args))
    __swig_destroy__ = _pymdlsdk.delete_IBsdf_measurement

    def __deref__(self):
        return _pymdlsdk.IBsdf_measurement___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IBsdf_measurement___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IBsdf_measurement_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IBsdf_measurement___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IBsdf_measurement___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IBsdf_measurement_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IBsdf_measurement_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IBsdf_measurement__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def reset_file(self, filename):
        r"""
        Sets the BSDF measurement to a file identified by ``filename``.

        :rtype: int
        :return: 
                              -  0: Success.
                              - -1: Invalid parameters (``NULL`` pointer).
                              - -2: Failure to resolve the given filename, e.g., the file does not
                                    exist.
                              - -3: Invalid file format or invalid filename extension (only ``.mbsdf`` is
                                    supported).

        See also: #mi::neuraylib::IMdl_factory::create_bsdf_measurement() for a way to create a BSDF
             measurement based on an MDL file path instead of a filename.
        """
        return _pymdlsdk.IBsdf_measurement_reset_file(self, filename)

    def reset_reader(self, reader):
        r"""
        Sets the BSDF measurement to the data provided by a reader.

        :type reader: mi::neuraylib::IReader
        :param reader:      The reader that provides the data for the BSDF measurement in ``.mbsdf``
                               format.
        :rtype: int
        :return: 
                               -  0: Success.
                               - -1: Invalid parameters (``NULL`` pointer).
                               - -3: Invalid file format.
        """
        return _pymdlsdk.IBsdf_measurement_reset_reader(self, reader)

    def get_filename(self):
        r"""
        Returns the resolved file name of the file containing the BSDF measurement.

        The method returns ``NULL`` if there is no file associated with the BSDF measurement, e.g.,
        after default construction, calls to #set_reflection() or #set_transmission(), or failures
        to resolves the file name passed to #reset_file().

        See also: #get_original_filename()
        """
        return _pymdlsdk.IBsdf_measurement_get_filename(self)

    def get_original_filename(self):
        r"""
        Returns the unresolved file name as passed to #reset_file().

        The method returns ``NULL`` after default construction or calls to #set_reflection() or
        #set_transmission().

        See also: #get_filename()
        """
        return _pymdlsdk.IBsdf_measurement_get_original_filename(self)

    def set_reflection(self, bsdf_data):
        r"""
        Sets the BSDF data for the reflection.

        :type bsdf_data: mi::neuraylib::IBsdf_isotropic_data
        :param bsdf_data:   The BSDF data to be used by this BSDF measurement. The value ``NULL``
                               can be used to remove the BSDF data for reflection.
        :rtype: int
        :return: 
                               -  0: Success.
                               - -2: The resolution or type of ``bsdf_data`` is invalid.
        """
        return _pymdlsdk.IBsdf_measurement_set_reflection(self, bsdf_data)

    def get_reflection(self):
        r"""
        Returns the BSDF data for the reflection.

        Note that it is not possible to manipulate the BSDF data.

        :rtype: mi::base::IInterface
        :return: The BSDF data for reflection, or ``NULL`` if there is none.
        """
        return _pymdlsdk.IBsdf_measurement_get_reflection(self)

    def set_transmission(self, bsdf_data):
        r"""
        Sets the BSDF data for transmission.

        :type bsdf_data: mi::neuraylib::IBsdf_isotropic_data
        :param bsdf_data:   The BSDF data to be used by this BSDF measurement. The value ``NULL``
                               can be used to remove the BSDF data for transmission.
        :rtype: int
        :return: 
                               -  0: Success.
                               - -2: The resolution or type of ``bsdf_data`` is invalid.
        """
        return _pymdlsdk.IBsdf_measurement_set_transmission(self, bsdf_data)

    def get_transmission(self):
        r"""
        Returns the BSDF data for transmission.

        Note that it is not possible to manipulate the BSDF data.

        :rtype: mi::base::IInterface
        :return: The BSDF data for transmission, or ``NULL`` if there is none.
        """
        return _pymdlsdk.IBsdf_measurement_get_transmission(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IBsdf_measurement_compare_iid(self, iid)

    def get_element_type(self):
        r""" Indicates the actual scene element represented by interfaces derived from this interface."""
        return _pymdlsdk.IBsdf_measurement_get_element_type(self)

    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk.IBsdf_measurement_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk.IBsdf_measurement_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IBsdf_measurement_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IBsdf_measurement_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk.IBsdf_measurement_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk.IBsdf_measurement_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk.IBsdf_measurement_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk.IBsdf_measurement_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk.IBsdf_measurement_enumerate_attributes(self, index)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IBsdf_measurement__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IBsdf_measurement__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IBsdf_measurement_get_iid(self)

# Register IBsdf_measurement in _pymdlsdk:
_pymdlsdk.IBsdf_measurement_swigregister(IBsdf_measurement)

def IBsdf_measurement_IID():
    return _pymdlsdk.IBsdf_measurement_IID()

def IBsdf_measurement__get_interface(iface):
    return _pymdlsdk.IBsdf_measurement__get_interface(iface)

class ICanvas(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.ICanvas_swiginit(self, _pymdlsdk.new_ICanvas(*args))
    __swig_destroy__ = _pymdlsdk.delete_ICanvas

    def __deref__(self):
        return _pymdlsdk.ICanvas___deref__(self)

    def __ref__(self):
        return _pymdlsdk.ICanvas___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.ICanvas_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.ICanvas___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.ICanvas___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.ICanvas_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.ICanvas_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.ICanvas__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_tile(self, *args):
        r"""
        *Overload 1:*
        Returns the tile for the given layer.

        :type layer: int, optional
        :param layer:     The layer of the pixel in the canvas.
        :rtype: :py:class:`ITile`
        :return: The tile that contains the pixel, or ``NULL`` in case of invalid
                             parameters.

        |

        *Overload 2:*
        Returns the tile for the given layer.

        :type layer: int, optional
        :param layer:     The layer of the pixel in the canvas.
        :rtype: :py:class:`ITile`
        :return: The tile that contains the pixel, or ``NULL`` in case of invalid
                             parameters.

        |

        *Overload 3:*
        Returns the tile for the given layer.

        :param layer:     The layer of the pixel in the canvas.
        :rtype: :py:class:`ITile`
        :return: The tile that contains the pixel, or ``NULL`` in case of invalid
                             parameters.
        """
        return _pymdlsdk.ICanvas_get_tile(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.ICanvas_compare_iid(self, iid)

    def get_resolution_x(self):
        r""" Returns the resolution of the canvas in x direction."""
        return _pymdlsdk.ICanvas_get_resolution_x(self)

    def get_resolution_y(self):
        r""" Returns the resolution of the canvas in y direction."""
        return _pymdlsdk.ICanvas_get_resolution_y(self)

    def get_type(self):
        r"""
        Returns the pixel type used by the canvas.

        See also: 'mi_neuray_types' for a list of supported pixel types
        """
        return _pymdlsdk.ICanvas_get_type(self)

    def get_layers_size(self):
        r""" Returns the number of layers this canvas has."""
        return _pymdlsdk.ICanvas_get_layers_size(self)

    def get_gamma(self):
        r"""
        Returns the gamma value.

        The gamma value should be a positive number. Typical values are 2.2 for LDR pixel types, and
        1.0 for HDR pixel types.
        """
        return _pymdlsdk.ICanvas_get_gamma(self)

    def set_gamma(self, gamma):
        r"""
        Sets the gamma value.

        Notes: This method just sets the gamma value. It does *not* change the pixel data itself.
        """
        return _pymdlsdk.ICanvas_set_gamma(self, gamma)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.ICanvas__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.ICanvas__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.ICanvas_get_iid(self)

# Register ICanvas in _pymdlsdk:
_pymdlsdk.ICanvas_swigregister(ICanvas)

def ICanvas_IID():
    return _pymdlsdk.ICanvas_IID()

def ICanvas__get_interface(iface):
    return _pymdlsdk.ICanvas__get_interface(iface)

class ICanvas_base(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.ICanvas_base_swiginit(self, _pymdlsdk.new_ICanvas_base(*args))
    __swig_destroy__ = _pymdlsdk.delete_ICanvas_base

    def __deref__(self):
        return _pymdlsdk.ICanvas_base___deref__(self)

    def __ref__(self):
        return _pymdlsdk.ICanvas_base___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.ICanvas_base_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.ICanvas_base___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.ICanvas_base___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.ICanvas_base_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.ICanvas_base_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.ICanvas_base__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_resolution_x(self):
        r""" Returns the resolution of the canvas in x direction."""
        return _pymdlsdk.ICanvas_base_get_resolution_x(self)

    def get_resolution_y(self):
        r""" Returns the resolution of the canvas in y direction."""
        return _pymdlsdk.ICanvas_base_get_resolution_y(self)

    def get_type(self):
        r"""
        Returns the pixel type used by the canvas.

        See also: 'mi_neuray_types' for a list of supported pixel types
        """
        return _pymdlsdk.ICanvas_base_get_type(self)

    def get_layers_size(self):
        r""" Returns the number of layers this canvas has."""
        return _pymdlsdk.ICanvas_base_get_layers_size(self)

    def get_gamma(self):
        r"""
        Returns the gamma value.

        The gamma value should be a positive number. Typical values are 2.2 for LDR pixel types, and
        1.0 for HDR pixel types.
        """
        return _pymdlsdk.ICanvas_base_get_gamma(self)

    def set_gamma(self, gamma):
        r"""
        Sets the gamma value.

        Notes: This method just sets the gamma value. It does *not* change the pixel data itself.
        """
        return _pymdlsdk.ICanvas_base_set_gamma(self, gamma)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.ICanvas_base_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.ICanvas_base__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.ICanvas_base__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.ICanvas_base_get_iid(self)

# Register ICanvas_base in _pymdlsdk:
_pymdlsdk.ICanvas_base_swigregister(ICanvas_base)

def ICanvas_base_IID():
    return _pymdlsdk.ICanvas_base_IID()

def ICanvas_base__get_interface(iface):
    return _pymdlsdk.ICanvas_base__get_interface(iface)

class ICompiled_material(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.ICompiled_material_swiginit(self, _pymdlsdk.new_ICompiled_material(*args))
    __swig_destroy__ = _pymdlsdk.delete_ICompiled_material

    def __deref__(self):
        return _pymdlsdk.ICompiled_material___deref__(self)

    def __ref__(self):
        return _pymdlsdk.ICompiled_material___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.ICompiled_material_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.ICompiled_material___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.ICompiled_material___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.ICompiled_material_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.ICompiled_material_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.ICompiled_material__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_body(self):
        r""" Returns the direct call expression that represents the body of the compiled material."""
        return _pymdlsdk.ICompiled_material_get_body(self)

    def get_temporary_count(self):
        r""" Returns the number of temporaries used by this compiled material."""
        return _pymdlsdk.ICompiled_material_get_temporary_count(self)

    def get_temporary(self, index):
        r"""
        Returns the expression of a temporary.

        :type index: int
        :param index:            The index of the temporary.
        :rtype: :py:class:`IExpression`
        :return: The expression of the temporary, or ``NULL`` if ``index`` is out of
                                    range.
        """
        return _pymdlsdk.ICompiled_material_get_temporary(self, index)

    def get_mdl_meters_per_scene_unit(self):
        r""" Returns the conversion ration between meters and scene units for this material."""
        return _pymdlsdk.ICompiled_material_get_mdl_meters_per_scene_unit(self)

    def get_mdl_wavelength_min(self):
        r""" Returns the smallest supported wavelength."""
        return _pymdlsdk.ICompiled_material_get_mdl_wavelength_min(self)

    def get_mdl_wavelength_max(self):
        r""" Returns the largest supported wavelength."""
        return _pymdlsdk.ICompiled_material_get_mdl_wavelength_max(self)

    def depends_on_state_transform(self):
        r"""
        Indicates whether this material depends on coordinate space transformations like
        ``%state::transform()`` and related functions.
        """
        return _pymdlsdk.ICompiled_material_depends_on_state_transform(self)

    def depends_on_state_object_id(self):
        r""" Indicates whether this material depends on ``state::object_id()``."""
        return _pymdlsdk.ICompiled_material_depends_on_state_object_id(self)

    def depends_on_global_distribution(self):
        r""" Indicates whether this material depends on global distribution (edf)."""
        return _pymdlsdk.ICompiled_material_depends_on_global_distribution(self)

    def depends_on_uniform_scene_data(self):
        r""" Indicates whether this material depends on uniform scene data."""
        return _pymdlsdk.ICompiled_material_depends_on_uniform_scene_data(self)

    def get_referenced_scene_data_count(self):
        r""" Returns the number of scene data attributes referenced by this instance."""
        return _pymdlsdk.ICompiled_material_get_referenced_scene_data_count(self)

    def get_referenced_scene_data_name(self, index):
        r"""
        Return the name of a scene data attribute referenced by this instance.

        :type index: int
        :param index:  the index of the scene data attribute
        """
        return _pymdlsdk.ICompiled_material_get_referenced_scene_data_name(self, index)

    def get_parameter_count(self):
        r""" Returns the number of parameters used by this compiled material."""
        return _pymdlsdk.ICompiled_material_get_parameter_count(self)

    def get_parameter_name(self, index):
        r"""
        Returns the name of a parameter.

        Note that the parameter name is only available if the corresponding parameter of the
        original material instance has a constant as argument. If that argument is a call,
        ``NULL`` is returned.
        """
        return _pymdlsdk.ICompiled_material_get_parameter_name(self, index)

    def get_argument(self, index):
        r"""
        Returns the value of an argument.

        :type index: int
        :param index:            The index of the argument.
        :rtype: :py:class:`IValue`
        :return: The value of the argument, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk.ICompiled_material_get_argument(self, index)

    def get_hash(self):
        r"""
        Returns a hash of the body and all temporaries.

        The hash allows to quickly identify compiled materials that have the same body and
        temporaries. Note that the arguments are not included in the hash value.

        Notes: For performance reasons, the hash for resources does not include the actual resource
              data, but certain properties to identify resources: If the absolute MDL file path is
              available, it is used (including the gamma value for textures). If the absolute MDL
              file path is not available, some internal IDs that identify the resource in the
              database are used instead.

              For the latter case, the following applies: If two otherwise identical materials share
              a resource (in the sense of there is one and only one DB element for that resource),
              then their hash is also identical. But if the materials use distinct (but otherwise
              identical) copies of the same DB element, then their IDs are different, resulting in
              different hashes. IDs are also different if a module is removed from the database, and
              later loaded again. IDs might be different if the module is loaded in different
              processes.

        See also: #get_slot_hash() for hashes for individual material slots
        """
        return _pymdlsdk.ICompiled_material_get_hash(self)

    def get_slot_hash(self, slot):
        r"""
        Returns the hash of a particular material slot.

        The slots hashes allow to quickly compare slots of compiled materials. Note that the
        arguments are not included in the hash value.

        Notes: For performance reasons, the hash for resources does not include the actual resource
              data, but certain properties to identify resources: If the absolute MDL file path is
              available, it is used (including the gamma value for textures). If the absolute MDL
              file path is not available, some internal IDs that identify the resource in the
              database are used instead.

              For the latter case, the following applies: If two otherwise identical materials share
              a resource (in the sense of there is one and only one DB element for that resource),
              then their hash is also identical. But if the materials use distinct (but otherwise
              identical) copies of the same DB element, then their IDs are different, resulting in
              different hashes. IDs are also different if a module is removed from the database, and
              later loaded again. IDs might be different if the module is loaded in different
              processes.

        See also: #get_hash() for a hash covering all slots together
        """
        return _pymdlsdk.ICompiled_material_get_slot_hash(self, slot)

    def lookup_sub_expression(self, path):
        r"""
        Looks up a sub-expression of the compiled material.

        :type path: string
        :param path:            The path from the material root to the expression that should be
                                   returned, e.g., ``"surface.scattering.tint"``.
        :rtype: :py:class:`IExpression`
        :return: A sub-expression for ``expr`` according to ``path``, or ``NULL`` in case
                                   of errors.
        """
        return _pymdlsdk.ICompiled_material_lookup_sub_expression(self, path)

    def get_connected_function_db_name_with_ret(self, material_instance_name, parameter_index):
        r"""
        Looks up the database name of the mdl instance connected to the argument of a compiled
        material.

        The parameters on the compiled material in class compilation mode can have more complex
        names if a shade graph has been compiled. The name corresponds to a path through the shade
        graph identifying a node and a parameter on that node whose value should be passed into
        the parameter of the compiled result. For example, the path "a.b.x" refers to a parameter
        named x on a node connected to a parameter named b on a node connected to the parameter a
        of the material that has been compiled.
        :type material_instance_name: string
        :param material_instance_name:   The name of the material instance this material was
                                            compiled from.
        :type parameter_index: int
        :param parameter_index:          The index of the parameter for which the database name of
                                            the connected function is to be looked up (e.g. if the
                                            compiled material has a parameter named ``"tint.s.texture"``
                                            the function returns the database name of the function
                                            connected to the tint parameter.
        :type errors: int, optional
        :param errors:                   An optional pointer to an #mi::Sint32 to which an error
                                               code will be written. The error codes have the following
                                               meaning:
                                               -  0: Success.
                                               - -1: The parameter material_instance_name is NULL or a
                                                     material instance of that name does not exist in
                                                     the database.
                                               - -2: The given parameter index exceeds the parameter
                                                     count of the compiled material.
                                               - -3: The function could not be found in the database.
                                                     This might be due to the fact that the given
                                                     parameter is not connected to a function or the
                                                     material instance has been changed after the
                                                     creation of this compiled material.
        :rtype: :py:class:`IString`
        :return: The database name of the connected function or NULL in case an error occurred.
        """
        return _pymdlsdk.ICompiled_material_get_connected_function_db_name_with_ret(self, material_instance_name, parameter_index)

    def get_connected_function_db_name(self, material_instance_name, parameter_index):
        r"""
        Looks up the database name of the mdl instance connected to the argument of a compiled
        material.

        The parameters on the compiled material in class compilation mode can have more complex
        names if a shade graph has been compiled. The name corresponds to a path through the shade
        graph identifying a node and a parameter on that node whose value should be passed into
        the parameter of the compiled result. For example, the path "a.b.x" refers to a parameter
        named x on a node connected to a parameter named b on a node connected to the parameter a
        of the material that has been compiled.
        :type material_instance_name: string
        :param material_instance_name:   The name of the material instance this material was
                                            compiled from.
        :type parameter_index: int
        :param parameter_index:          The index of the parameter for which the database name of
                                            the connected function is to be looked up (e.g. if the
                                            compiled material has a parameter named ``"tint.s.texture"``
                                            the function returns the database name of the function
                                            connected to the tint parameter.
        :param errors:                   An optional pointer to an #mi::Sint32 to which an error
                                               code will be written. The error codes have the following
                                               meaning:
                                               -  0: Success.
                                               - -1: The parameter material_instance_name is NULL or a
                                                     material instance of that name does not exist in
                                                     the database.
                                               - -2: The given parameter index exceeds the parameter
                                                     count of the compiled material.
                                               - -3: The function could not be found in the database.
                                                     This might be due to the fact that the given
                                                     parameter is not connected to a function or the
                                                     material instance has been changed after the
                                                     creation of this compiled material.
        :rtype: :py:class:`IString`
        :return: The database name of the connected function or NULL in case an error occurred.
        """
        return _pymdlsdk.ICompiled_material_get_connected_function_db_name(self, material_instance_name, parameter_index)

    def get_opacity(self):
        r"""
        Returns the opacity of the material.

        First, the cutout_opacity is checked. In case of opaque
        materials it is checked if a transmissive BSDF is present in the ``surface.scattering``
        slot of the material.
        """
        return _pymdlsdk.ICompiled_material_get_opacity(self)

    def get_surface_opacity(self):
        r"""
        Returns the surface opacity of the material by checking, if a
        transmissive BSDF is present in the ``surface.scattering`` slot of
        the material.
        """
        return _pymdlsdk.ICompiled_material_get_surface_opacity(self)

    def get_cutout_opacity(self, cutout_opacity):
        r"""
        Returns the cutout opacity of the material if it is constant.

        :type cutout_opacity: float, out
        :param cutout_opacity:  get the cutout_opacity value of the material

        :rtype: boolean
        :return: ``true`` in case of success, ``false`` if the value is not a constant, but depends on
                     parameters or complex user expressions
        """
        return _pymdlsdk.ICompiled_material_get_cutout_opacity(self, cutout_opacity)

    def is_valid(self, context):
        r"""
        Returns ``true``, if the compiled material is valid, ``false`` otherwise.

        :type context: :py:class:`IMdl_execution_context`
        :param context:     In case of failure, the execution context can be checked for error
                               messages. Can be ``NULL``.

        A compiled material becomes invalid, if any of the modules it uses definitions from has
        has been reloaded.
        """
        return _pymdlsdk.ICompiled_material_is_valid(self, context)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.ICompiled_material_compare_iid(self, iid)

    def get_element_type(self):
        r""" Indicates the actual scene element represented by interfaces derived from this interface."""
        return _pymdlsdk.ICompiled_material_get_element_type(self)

    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk.ICompiled_material_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk.ICompiled_material_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.ICompiled_material_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.ICompiled_material_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk.ICompiled_material_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk.ICompiled_material_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk.ICompiled_material_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk.ICompiled_material_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk.ICompiled_material_enumerate_attributes(self, index)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.ICompiled_material__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.ICompiled_material__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.ICompiled_material_get_iid(self)

# Register ICompiled_material in _pymdlsdk:
_pymdlsdk.ICompiled_material_swigregister(ICompiled_material)

def ICompiled_material_IID():
    return _pymdlsdk.ICompiled_material_IID()

def ICompiled_material__get_interface(iface):
    return _pymdlsdk.ICompiled_material__get_interface(iface)

class IDatabase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IDatabase_swiginit(self, _pymdlsdk.new_IDatabase(*args))
    __swig_destroy__ = _pymdlsdk.delete_IDatabase

    def __deref__(self):
        return _pymdlsdk.IDatabase___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IDatabase___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IDatabase_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IDatabase___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IDatabase___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IDatabase_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IDatabase_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IDatabase__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_global_scope(self):
        r"""
        Returns the global scope which is the root of a tree of scopes

        :rtype: :py:class:`IScope`
        :return: The global scope which is guaranteed to exist after startup of the
                     system.
        """
        return _pymdlsdk.IDatabase_get_global_scope(self)

    def create_scope(self, parent, privacy_level=0, temp=False):
        r"""
        If not: MDL_SDK_API {
        Creates a new optionally temporary scope at the given privacy level with the
        given parent scope ID.

        Notes: A scope continues to exist if the pointer returned by this method is released. Use
              #remove_scope() to remove a scope.

        :type parent: :py:class:`IScope`
        :param parent:         The parent scope for this scope. If the value is ``NULL`` the created
                                  scope will be a child of the global scope.
        :type privacy_level: mi::Uint8, optional
        :param privacy_level:  The privacy level of the scope. This must be higher than the
                                  privacy level of the parent scope. The privacy level of the global
                                  scope is 0 (and the global scope is the only scope with privacy level
                                  0). The default value of 0 indicates the privacy level of the parent
                                  scope plus 1.
        :type temp: boolean, optional
        :param temp:           A bool indicating if the scope is temporary. If the scope is
                                  temporary, then when the host that created the scope is removed
                                  from the cluster the scope and all data contained in the scope
                                  will be removed. If the scope is not temporary, the default,
                                  then when the creating host is removed from the cluster the
                                  scope and all contained data will remain in the database.
        :rtype: :py:class:`IScope`
        :return: The created scope or ``NULL`` if something went wrong.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk.IDatabase_create_scope(self, parent, privacy_level, temp)

    def get_scope(self, id):
        r"""
        Looks up and returns a scope with a given ID.

        :type id: string
        :param id:             The ID of the scope as returned by #mi::neuraylib::IScope::get_id().
        :rtype: :py:class:`IScope`
        :return: The found scope or ``NULL`` if no such scope exists.
        """
        return _pymdlsdk.IDatabase_get_scope(self, id)

    def remove_scope(self, id):
        r"""
        If not: MDL_SDK_API {
        Removes a scope with the specified ID.

        Note that scopes are reference counted. The actual removal will not happen before all
        elements referencing the scope have been released, e.g., child scopes, transactions,
        database elements, including handles to the scope itself.

        It is not possible to remove the global scope.

        :type id: string
        :param id:             The ID of the scope as returned by #mi::neuraylib::IScope::get_id().
        :rtype: int
        :return: 0, in case of success, -1 in case of failure.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk.IDatabase_remove_scope(self, id)

    def lock(self, lock_id):
        r"""
        If not: MDL_SDK_API {
        Acquires a DB lock.

        The method blocks until the requested lock has been obtained. Recursively locking the
        same lock from within the same thread on the same host is supported.

        If the host holding a lock leaves the cluster, the lock is automatically released.

        :type lock_id: int
        :param lock_id:   The lock to acquire.

        Notes: The locking mechanism is kind of a co-operative locking mechanism: The lock does not
              prevent other threads from accessing or editing the DB. It only prevents other threads
              from obtaining the same lock.

        DB locks are not restricted to threads on a single host, they apply to all threads on
              all hosts in the cluster.

        DB locks are an expensive operation and should only be used when absolutely necessary.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk.IDatabase_lock(self, lock_id)

    def unlock(self, lock_id):
        r"""
        If not: MDL_SDK_API {
        Releases a previously obtained DB lock.

        If the lock has been locked several times from within the same thread on the same host,
        it simply decrements the lock count. If the lock count reaches zero, the lock is released.

        :type lock_id: int
        :param lock_id:   The lock to release.
        :rtype: int
        :return: 0, in case of success, -1 in case of failure, i.e, the lock is not held
                             by this thread on this host
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk.IDatabase_unlock(self, lock_id)

    def create_or_get_named_scope(self, name, parent=None, privacy_level=0):
        r"""
        If not: MDL_SDK_API {
        Creates or retrieves a new named scope at the given privacy level with the given parent
        scope ID.

        :type name: string
        :param name:           A name which can be used to lookup the scope.
                                  If a scope with the same name exists already then it will be returned
                                  if the parent and privacy level are identical. Otherwise
                                  creating the scope will fail.
        :type parent: :py:class:`IScope`, optional
        :param parent:         The parent scope for this scope. If the value is ``NULL`` the created
                                  scope will be a child of the global scope.
        :type privacy_level: mi::Uint8, optional
        :param privacy_level:  The privacy level of the scope. This must be higher than the
                                  privacy level of the parent scope. The privacy level of the global
                                  scope is 0 (and the global scope is the only scope with privacy level
                                  0). The default value of 0 indicates the privacy level of the parent
                                  scope plus 1.
        :rtype: :py:class:`IScope`
        :return: The created scope or ``NULL`` if something went wrong.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk.IDatabase_create_or_get_named_scope(self, name, parent, privacy_level)

    def get_named_scope(self, name):
        r"""
        If not: MDL_SDK_API {
        Looks up and returns a scope with a given name.

        :type name: string
        :param name:           The name of the scope
        :rtype: :py:class:`IScope`
        :return: The found scope or ``NULL`` if no such scope exists.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk.IDatabase_get_named_scope(self, name)

    def garbage_collection(self, *args):
        r"""
        Triggers a synchronous garbage collection run.

        The method sweeps through the entire database and removes all database elements which have
        been marked for removal and are no longer referenced. Note that it is not possible to remove
        database elements if there are open transactions in which such an element is still
        referenced.

        To mark an element for removal use If not: DICE_API { #mi::neuraylib::ITransaction::remove().
        }Else: #mi::neuraylib::IDice_transaction::remove() or {
        #mi::neuraylib::IDice_transaction::store_for_reference_counting(). }

        :type priority: int, optional
        :param priority:   The intended priority of the synchronous garbage collection run.
                          If: MDL_SDK_API { The MDL SDK does not support different priorities, and
                          the synchronous garbage collection always runs at highest priority.
                          }
        """
        return _pymdlsdk.IDatabase_garbage_collection(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IDatabase_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IDatabase__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IDatabase__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IDatabase_get_iid(self)

# Register IDatabase in _pymdlsdk:
_pymdlsdk.IDatabase_swigregister(IDatabase)

def IDatabase_IID():
    return _pymdlsdk.IDatabase_IID()

def IDatabase__get_interface(iface):
    return _pymdlsdk.IDatabase__get_interface(iface)

class IDeserialized_function_name(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IDeserialized_function_name_swiginit(self, _pymdlsdk.new_IDeserialized_function_name(*args))
    __swig_destroy__ = _pymdlsdk.delete_IDeserialized_function_name

    def __deref__(self):
        return _pymdlsdk.IDeserialized_function_name___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IDeserialized_function_name___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IDeserialized_function_name_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IDeserialized_function_name___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IDeserialized_function_name___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IDeserialized_function_name_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IDeserialized_function_name_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IDeserialized_function_name__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_db_name(self):
        r""" Returns the DB name of the function of material definition."""
        return _pymdlsdk.IDeserialized_function_name_get_db_name(self)

    def get_argument_types(self):
        r"""
        Returns the argument types of the serialized function call or material instance.

        The argument types are identical to the parameter types of the corresponding definition,
        unless it is one of the 'mi_neuray_mdl_template_like_function_definitions'. The remarks
        about the expression list for creating calls to the 'mi_neuray_mdl_cast_operator' apply
        correspondingly.
        """
        return _pymdlsdk.IDeserialized_function_name_get_argument_types(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IDeserialized_function_name_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IDeserialized_function_name__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IDeserialized_function_name__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IDeserialized_function_name_get_iid(self)

# Register IDeserialized_function_name in _pymdlsdk:
_pymdlsdk.IDeserialized_function_name_swigregister(IDeserialized_function_name)

def IDeserialized_function_name_IID():
    return _pymdlsdk.IDeserialized_function_name_IID()

def IDeserialized_function_name__get_interface(iface):
    return _pymdlsdk.IDeserialized_function_name__get_interface(iface)

class IDeserialized_module_name(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IDeserialized_module_name_swiginit(self, _pymdlsdk.new_IDeserialized_module_name(*args))
    __swig_destroy__ = _pymdlsdk.delete_IDeserialized_module_name

    def __deref__(self):
        return _pymdlsdk.IDeserialized_module_name___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IDeserialized_module_name___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IDeserialized_module_name_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IDeserialized_module_name___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IDeserialized_module_name___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IDeserialized_module_name_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IDeserialized_module_name_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IDeserialized_module_name__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_db_name(self):
        r""" Returns the DB name of the module."""
        return _pymdlsdk.IDeserialized_module_name_get_db_name(self)

    def get_load_module_argument(self):
        r""" Returns a string suitable for #mi::neuraylib::IMdl_impexp_api::load_module()."""
        return _pymdlsdk.IDeserialized_module_name_get_load_module_argument(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IDeserialized_module_name_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IDeserialized_module_name__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IDeserialized_module_name__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IDeserialized_module_name_get_iid(self)

# Register IDeserialized_module_name in _pymdlsdk:
_pymdlsdk.IDeserialized_module_name_swigregister(IDeserialized_module_name)

def IDeserialized_module_name_IID():
    return _pymdlsdk.IDeserialized_module_name_IID()

def IDeserialized_module_name__get_interface(iface):
    return _pymdlsdk.IDeserialized_module_name__get_interface(iface)

class IImage_api(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IImage_api_swiginit(self, _pymdlsdk.new_IImage_api(*args))
    __swig_destroy__ = _pymdlsdk.delete_IImage_api

    def __deref__(self):
        return _pymdlsdk.IImage_api___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IImage_api___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IImage_api_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IImage_api___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IImage_api___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IImage_api_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IImage_api_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IImage_api__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def create_tile(self, pixel_type, width, height):
        r"""
        Creates a tile with given pixel type, width, and height.

        This factory function allows to create instances of the abstract interface
        #mi::neuraylib::ITile based on an internal default implementation. However, you are not
        obligated to use this factory function and the internal default implementation. It is
        absolutely fine to use your own (correct) implementation of the #mi::neuraylib::ITile
        interface.

        :type pixel_type: string
        :param pixel_type:   The desired pixel type. See 'mi_neuray_types' for a list of supported
                                pixel types.
        :type width: int
        :param width:        The desired width.
        :type height: int
        :param height:       The desired height.
        :rtype: :py:class:`ITile`
        :return: The requested tile, or ``NULL`` in case of invalid pixel type, width, or
                                height, or memory allocation failures.
        """
        return _pymdlsdk.IImage_api_create_tile(self, pixel_type, width, height)

    def create_canvas(self, pixel_type, width, height, layers=1, is_cubemap=False, gamma=0.0):
        r"""
        Creates a canvas with given pixel type, resolution, and layers.

        This factory function allows to create instances of the abstract interface
        #mi::neuraylib::ICanvas based on an internal default implementation. However, you are not
        obligated to use this factory function and the internal default implementation. It is
        absolutely fine to use your own (correct) implementation of the #mi::neuraylib::ICanvas
        interface.

        :type pixel_type: string
        :param pixel_type:   The desired pixel type. See 'mi_neuray_types' for a list of
                                supported pixel types.
        :type width: int
        :param width:        The desired width.
        :type height: int
        :param height:       The desired height.
        :type layers: int, optional
        :param layers:       The desired number of layers (depth). Must be 6 for cubemaps.
        :type is_cubemap: boolean, optional
        :param is_cubemap:   Flag that indicates whether this canvas represents a cubemap.
        :type gamma: float, optional
        :param gamma:        The desired gamma value. The special value 0.0 represents the default
                                gamma which is 1.0 for HDR pixel types and 2.2 for LDR pixel types.
        :rtype: :py:class:`ICanvas`
        :return: The requested canvas, or ``NULL`` in case of invalid pixel type, width,
                                height, layers, or cubemap flag, or memory allocation failures.
        """
        return _pymdlsdk.IImage_api_create_canvas(self, pixel_type, width, height, layers, is_cubemap, gamma)

    def create_canvas_cuda(self, cuda_device_id, pixel_type, width, height, layers=1, gamma=0.0):
        r"""
        Creates a CUDA canvas with given pixel type, width, height, and layers.

        See also: #create_canvas()
        See also: #mi::neuraylib::IGpu_description::get_cuda_device_id()

        :type cuda_device_id: int
        :param cuda_device_id: The CUDA ID of the device on which the canvas will reside.
                                Note that this is the CUDA device ID, not the 1-based GPU index
                                used in If: IRAY_API { #mi::neuraylib::IRendering_configuration.
                            }Else: #mi::neuraylib::IDice_configuration.  {}
        :type pixel_type: string
        :param pixel_type:   The desired pixel type. See 'mi_neuray_types' for a list of
                                supported pixel types.
        :type width: int
        :param width:        The desired width.
        :type height: int
        :param height:       The desired height.
        :type layers: int, optional
        :param layers:       The desired number of layers.
        :type gamma: float, optional
        :param gamma:        The desired gamma value. The special value 0.0 represents the default
                                gamma which is 1.0 for HDR pixel types and 2.2 for LDR pixel types.
        :rtype: mi::neuraylib::ICanvas_cuda
        :return: The requested canvas, or ``NULL`` in case of invalid parameters or
                                CUDA errors.
        """
        return _pymdlsdk.IImage_api_create_canvas_cuda(self, cuda_device_id, pixel_type, width, height, layers, gamma)

    def create_mipmaps(self, canvas, gamma_override=0.0):
        r"""
        Creates mipmaps from the given canvas.

        Notes: The base level (the canvas that is passed in) is not included in the returned
        canvas array.

        :type canvas: :py:class:`ICanvas`
        :param canvas:           The canvas to create the mipmaps from.
        :type gamma_override: float, optional
        :param gamma_override:   If this parameter is different from zero, it is used instead of the
                                    canvas gamma during mipmap creation.
        :rtype: :py:class:`IArray`
        :return: An array of type #mi::IPointer containing pointers to
                                    the mipmaps of type #mi::neuraylib::ICanvas.
                                    If no mipmaps could be created, NULL is returned.
        """
        return _pymdlsdk.IImage_api_create_mipmaps(self, canvas, gamma_override)

    def read_raw_pixels(self, width, height, canvas, canvas_x, canvas_y, canvas_layer, buffer, buffer_topdown, buffer_pixel_type, buffer_padding=0):
        r"""
        Reads raw pixel data from a canvas.

        Reads a rectangular area of pixels from a canvas (possibly spanning multiple tiles),
        converts the pixel type if needed, and writes the pixel data to buffer in memory.
        Management of the buffer memory is the responsibility of the caller.

        :type width: int
        :param width:               The width of the rectangular pixel area.
        :type height: int
        :param height:              The height of the rectangular pixel area.
        :type canvas: :py:class:`ICanvas`
        :param canvas:              The canvas to read the pixel data from.
        :type canvas_x: int
        :param canvas_x:            The x-coordinate of the lower-left corner of the rectangle.
        :type canvas_y: int
        :param canvas_y:            The y-coordinate of the lower-left corner of the rectangle.
        :type canvas_layer: int
        :param canvas_layer:        The layer of the canvas that holds the rectangular area.
        :type buffer: void
        :param buffer:              The buffer to write the pixel data to.
        :type buffer_topdown: boolean
        :param buffer_topdown:      Indicates whether the buffer stores the rows in top-down order.
        :type buffer_pixel_type: string
        :param buffer_pixel_type:   The pixel type of the buffer. See 'mi_neuray_types' for a
                                       list of supported pixel types.
        :type buffer_padding: int, optional
        :param buffer_padding:      The padding between subsequent rows of the buffer in bytes.
        :rtype: int
        :return: 
                                       -  0: Success.
                                       - -1: Invalid parameters (``NULL`` pointer).
                                       - -2: ``width`` or ``height`` is zero.
                                       - -3: Invalid pixel type of the buffer.
                                       - -4: The rectangular area [``canvas_x``, ``canvas_x`` + ``width)``
                                             x [``canvas_y``, ``canvas_y`` + ``height)`` exceeds the size
                                             of the canvas, or ``canvas_layer`` is invalid.
        """
        return _pymdlsdk.IImage_api_read_raw_pixels(self, width, height, canvas, canvas_x, canvas_y, canvas_layer, buffer, buffer_topdown, buffer_pixel_type, buffer_padding)

    def write_raw_pixels(self, width, height, canvas, canvas_x, canvas_y, canvas_layer, buffer, buffer_topdown, buffer_pixel_type, buffer_padding=0):
        r"""
        Writes raw pixel data to a canvas.

        Reads a rectangular area of pixels from a buffer in memory, converts the pixel type if
        needed, and writes the pixel data to a canvas (possibly spanning multiple tiles).
        Management of the buffer memory is the responsibility of the caller.

        :type width: int
        :param width:               The width of the rectangular pixel area.
        :type height: int
        :param height:              The height of the rectangular pixel area.
        :type canvas: :py:class:`ICanvas`
        :param canvas:              The canvas to write the pixel data to.
        :type canvas_x: int
        :param canvas_x:            The x-coordinate of the lower-left corner of the rectangle.
        :type canvas_y: int
        :param canvas_y:            The y-coordinate of the lower-left corner of the rectangle.
        :type canvas_layer: int
        :param canvas_layer:        The layer of the canvas that holds the rectangular area.
        :type buffer: void
        :param buffer:              The buffer to read the pixel data from.
        :type buffer_topdown: boolean
        :param buffer_topdown:      Indicates whether the buffer stores the rows in top-down order.
        :type buffer_pixel_type: string
        :param buffer_pixel_type:   The pixel type of the buffer. See 'mi_neuray_types' for a
                                       list of supported pixel types.
        :type buffer_padding: int, optional
        :param buffer_padding:      The padding between subsequent rows of the buffer in bytes.
        :rtype: int
        :return: 
                                       -  0: Success.
                                       - -1: Invalid parameters (``NULL`` pointer).
                                       - -2: ``width`` or ``height`` is zero.
                                       - -3: Invalid pixel type of the buffer.
                                       - -4: The rectangular area [``canvas_x``, ``canvas_x`` + ``width)``
                                             x [``canvas_y``, ``canvas_y`` + ``height)`` exceeds the size
                                             of the canvas, or ``canvas_layer`` is invalid.
        """
        return _pymdlsdk.IImage_api_write_raw_pixels(self, width, height, canvas, canvas_x, canvas_y, canvas_layer, buffer, buffer_topdown, buffer_pixel_type, buffer_padding)

    def create_buffer_from_canvas(self, canvas, image_format, pixel_type, quality, force_default_gamma=False):
        r"""
        Encodes the pixel data of a canvas into a memory buffer.

        :type canvas: :py:class:`ICanvas`
        :param canvas:                The canvas whose contents are to be used.
        :type image_format: string
        :param image_format:          The desired image format of the image, e.g., ``"jpg"``. Note
                                         that support for a given image format requires an image plugin
                                         capable of handling that format.
        :type pixel_type: string
        :param pixel_type:            The desired pixel type. See 'mi_neuray_types' for a list of
                                         supported pixel types. Not every image plugin supports every
                                         pixel type. If the requested pixel type is not supported, the
                                         argument is ignored and one of the supported formats is chosen
                                         instead.
        :type quality: string
        :param quality:               The compression quality is an integer in the range from 0 to
                                         100, where 0 is the lowest quality, and 100 is the highest
                                         quality.
        :type force_default_gamma: boolean, optional
        :param force_default_gamma:   If enabled, adjusts the gamma value of the exported pixel data
                                         according to the pixel type chosen for export (1.0 for HDR
                                         pixel types, 2.2 for LDR pixel types).
        :rtype: mi::neuraylib::IBuffer
        :return: The created buffer, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IImage_api_create_buffer_from_canvas(self, canvas, image_format, pixel_type, quality, force_default_gamma)

    def create_canvas_from_buffer(self, buffer, image_format):
        r"""
        Decodes the pixel data of a memory buffer into a canvas.

        :type buffer: mi::neuraylib::IBuffer
        :param buffer:        The buffer that holds the encoded pixel data.
        :type image_format: string
        :param image_format:  The image format of the buffer, e.g., ``"jpg"``. Note that support for
                                 a given image format requires an image plugin capable of handling that
                                 format.
        :rtype: :py:class:`ICanvas`
        :return: The canvas with the decoded pixel data, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IImage_api_create_canvas_from_buffer(self, buffer, image_format)

    def create_canvas_from_reader(self, reader, image_format):
        r"""
        Decodes the pixel data from a reader into a canvas.

        :type reader: mi::neuraylib::IReader
        :param reader:        The reader that provides the data for the image. The reader needs to
                                 support absolute access.
        :type image_format: string
        :param image_format:  The image format of the buffer, e.g., ``"jpg"``. Note that support for
                                 a given image format requires an image plugin capable of handling that
                                 format.
        :rtype: :py:class:`ICanvas`
        :return: The canvas with the decoded pixel data, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IImage_api_create_canvas_from_reader(self, reader, image_format)

    def supports_format_for_decoding(self, image_format, reader=None):
        r"""
        Indicates whether a particular image format is supported for decoding.

        Support for a given image format requires an image plugin capable of handling that format.
        This method allows to check whether such a plugin has been loaded for a particular format.

        Decoding is used when the image is converted into a canvas from a If: DICE_API { memory
        buffer. }Else: memory buffer or a file  {}. Note that even if this method returns ``true``,
        #create_canvas_from_buffer() If: IRAY_API { or
        #mi::neuraylib::IImport_api::import_canvas() } can still fail for a particular image if
        that image uses an unsupported feature.

        :type image_format: string
        :param image_format:   The image format in question, e.g., ``"jpg"``.
        :type reader: mi::neuraylib::IReader, optional
        :param reader:         An optional reader If: IRAY_API { used by
                              #mi::neuraylib::IImage_plugin::test(). }
        :rtype: boolean
        :return: ``true`` if the image format is supported, ``false`` otherwise
        """
        return _pymdlsdk.IImage_api_supports_format_for_decoding(self, image_format, reader)

    def supports_format_for_encoding(self, image_format):
        r"""
        Indicates whether a particular image format is supported for encoding.

        Support for a given image format requires an image plugin capable of handling that format.
        This method allows to check whether such a plugin has been loaded for a particular format.

        Encoding is used when the image is converted from a canvas into a If: DICE_API { memory
        buffer. }Else: memory buffer or a file.  {}. Note that even if this method returns
        ``true``, #create_buffer_from_canvas() If: IRAY_API { or
        #mi::neuraylib::IExport_api::export_canvas } can still fail if the given canvas
        uses an unsupported feature, e.g., multiple layers.

        :type image_format: string
        :param image_format:   The image format in question, e.g., ``"jpg"``.
        :rtype: boolean
        :return: ``true`` if the image format is supported, ``false`` otherwise
        """
        return _pymdlsdk.IImage_api_supports_format_for_encoding(self, image_format)

    def convert(self, canvas, pixel_type):
        r"""
        Converts a canvas to a different pixel type.

        Notes: This method creates a copy if the passed-in canvas already has the desired pixel type.
        (It cannot return the passed-in canvas since this would require a const cast.) If
        performance is critical, you should compare pixel types yourself and skip the method call if
        pixel type conversion is not needed.)

        The conversion converts a given pixel as follows:

        - Floating-point values are linearly mapped to integers as follows: 0.0f is mapped to 0 and
          1.0f is mapped to 255 or 65535, respectively. Note that the pixel type ``"Sint8"`` is
          treated as the corresponding unsigned integer type ``"Uint8"`` here. Floating-point values
          are clamped to [0.0f, 1.0f] beforehand. The reverse conversion uses the corresponding
          inverse mapping.
        - Single-channel formats are converted to grey-scale RGB formats by duplicating the value
          in each channel.
        - RGB formats are converted to single-channel formats by mixing the RGB channels with
          weights 0.27f for red, 0.67f for green, and 0.06f for blue.
        - If an alpha channel is added, the values are set to 1.0f, 255, or 65535 respectively.
        - The pixel type ``"Float32<4>"`` is treated in the same way as ``"Color"``, ``"Float32<3>"``
          in the same way as ``"Rgb_fp"``, and ``"Sint32"`` in the same way as ``"Rgba"``.
        - The pixel type ``"Rgbe"`` is converted via ``"Rgb_fp"``. Similarly, ``"Rgbea"`` is converted
          via ``"Color"``.
        - ``"Float32<2>"`` is converted to single-channel formats by averaging the two channels. If
          ``"Float32<2>"`` is converted to three- or four-channel formats, the blue channel is set to
          0.0f, or 0, respectively. Conversion of single-channel formats to ``"Float32<2>"``
          duplicates the channel. Conversion of three- or four-channel formats to ``"Float32<2>"``
          drops the third and fourth channel.

        :type canvas: :py:class:`ICanvas`
        :param canvas:       The canvas to convert (or to copy).
        :type pixel_type: string
        :param pixel_type:   The desired pixel type. See 'mi_neuray_types' for a list of supported
                                pixel types. If this pixel type is the same as the pixel type of
           ``canvas``, then a copy of the canvas is returned.
        :rtype: :py:class:`ICanvas`
        :return: A canvas with the requested pixel type, or ``NULL`` in case of errors
                                (``canvas`` is ``NULL``, or ``pixel_type`` is not valid).
        """
        return _pymdlsdk.IImage_api_convert(self, canvas, pixel_type)

    def adjust_gamma(self, canvas, new_gamma):
        r"""
        Sets the gamma value of a canvas and adjusts the pixel data accordingly.

        Notes: Gamma adjustments are always done in pixel type "Color" or "Rgb_fp". If necessary,
              the pixel data is converted forth and back automatically (which needs temporary
              buffers).

        :type canvas: :py:class:`ICanvas`
        :param canvas:           The canvas whose pixel data is to be adjusted.
        :type new_gamma: float
        :param new_gamma:        The new gamma value.
        """
        return _pymdlsdk.IImage_api_adjust_gamma(self, canvas, new_gamma)

    def get_components_per_pixel(self, pixel_type):
        r"""
        Returns the number of components per pixel type.

        For example, for the pixel type "Color" the method returns 4 because it consists of four
        components R, G, B, and A. Returns 0 in case of invalid pixel types.

        See also: #get_bytes_per_component()
        """
        return _pymdlsdk.IImage_api_get_components_per_pixel(self, pixel_type)

    def get_bytes_per_component(self, pixel_type):
        r"""
        Returns the number of bytes used per pixel component.

        For example, for the pixel type "Color" the method returns 4 because its components are of
        type #mi::Float32 which needs 4 bytes. Returns 0 in case of invalid pixel types.

        See also: #get_components_per_pixel()
        """
        return _pymdlsdk.IImage_api_get_bytes_per_component(self, pixel_type)

    def get_pixel_type_for_channel(self, pixel_type, selector):
        r"""
        Returns the pixel type of an RGBA channel.

        Invalid pixel type/selector combinations are:
        - ``pixel_type`` is not an RGB or RGBA pixel type
        - ``selector`` is not an RGBA channel selector

        :type pixel_type: string
        :param pixel_type:   The pixel type of the mipmap/canvas/tile.
        :type selector: string
        :param selector:     The RGBA channel selector.
        :rtype: string
        :return: Returns PT_UNDEF for invalid pixel type/selector combinations.
                                Otherwise, returns PT_SINT8 or PT_FLOAT32, depending on
                                ``pixel_type``.
        """
        return _pymdlsdk.IImage_api_get_pixel_type_for_channel(self, pixel_type, selector)

    def extract_channel(self, *args):
        r"""
        *Overload 1:*
        Extracts an RGBA channel from a canvas.

        :type canvas: :py:class:`ICanvas`
        :param canvas:           The canvas to extract a channel from.
        :type selector: string
        :param selector:         The RGBA channel selector.
        :rtype: :py:class:`ICanvas`
        :return: The extracted channel, or ``NULL`` in case of invalid pixel type/
                                    channel selector combinations (see #get_pixel_type_for_channel()).

        |

        *Overload 2:*
        Extracts an RGBA channel from a tile.

        :type tile: :py:class:`ITile`
        :param tile:             The tile to extract a channel from.
        :type selector: string
        :param selector:         The RGBA channel selector.
        :rtype: :py:class:`ITile`
        :return: The extracted channel, or ``NULL`` in case of invalid pixel type/
                                    channel selector combinations (see #get_pixel_type_for_channel()).
        """
        return _pymdlsdk.IImage_api_extract_channel(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IImage_api_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IImage_api__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IImage_api__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IImage_api_get_iid(self)

# Register IImage_api in _pymdlsdk:
_pymdlsdk.IImage_api_swigregister(IImage_api)

def IImage_api_IID():
    return _pymdlsdk.IImage_api_IID()

def IImage_api__get_interface(iface):
    return _pymdlsdk.IImage_api__get_interface(iface)

class IMdl_configuration(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IMdl_configuration_swiginit(self, _pymdlsdk.new_IMdl_configuration(*args))
    __swig_destroy__ = _pymdlsdk.delete_IMdl_configuration

    def __deref__(self):
        return _pymdlsdk.IMdl_configuration___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IMdl_configuration___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IMdl_configuration_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IMdl_configuration___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IMdl_configuration___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IMdl_configuration_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IMdl_configuration_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IMdl_configuration__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def set_logger(self, logger):
        r"""
        Sets the logger.

        If: IRAY_API { Sets the receiving logger, see also
        #mi::neuraylib::ILogging_configuration::set_receiving_logger().}Else:  { Installs a custom logger, and deinstalls the previously installed logger.
        By default, an internal logger is installed that prints all messages of severity
        #mi::base::details::MESSAGE_SEVERITY_INFO or higher to stderr.}

        :type logger: mi::base::ILogger
        :param logger:   The new logger that receives all log messages. Passing ``NULL`` is allowed
                            to reinstall the default logger.
        """
        return _pymdlsdk.IMdl_configuration_set_logger(self, logger)

    def get_logger(self):
        r"""
        Returns the used logger.

        :rtype: mi::base::ILogger
        :return: If: IRAY_API { Returns the forwarding logger. See
                  also #mi::neuraylib::ILogging_configuration::get_forwarding_logger(). }Else: The {
                  currently used logger ( either explicitly installed via #set_logger(), or
                  the default logger). Never returns ``NULL``. }
        """
        return _pymdlsdk.IMdl_configuration_get_logger(self)

    def add_mdl_path(self, path):
        r"""
        Adds a path to the list of paths to search for MDL modules.

        This search path is also used for resources referenced in MDL modules. By default, the list
        of MDL paths is empty.

        :type path: string
        :param path:                The path to be added.
        :rtype: int
        :return: 
                                       -  0: Success.
                                       - -1: Invalid parameters ( ``NULL`` pointer).
                                       - -2: Invalid path.
        """
        return _pymdlsdk.IMdl_configuration_add_mdl_path(self, path)

    def remove_mdl_path(self, path):
        r"""
        Removes a path from the list of paths to search for MDL modules.

        This search path is also used for resources referenced in MDL modules. By default, the list
        of MDL paths is empty.

        :type path: string
        :param path:                The path to be removed.
        :rtype: int
        :return: 
                                       -  0: Success.
                                       - -1: Invalid parameters ( ``NULL`` pointer).
                                       - -2: There is no such path in the path list.
        """
        return _pymdlsdk.IMdl_configuration_remove_mdl_path(self, path)

    def clear_mdl_paths(self):
        r"""
        Clears the list of paths to search for MDL modules.

        This search path is also used for resources referenced in MDL modules. By default, the list
        of MDL paths is empty.
        """
        return _pymdlsdk.IMdl_configuration_clear_mdl_paths(self)

    def get_mdl_paths_length(self):
        r"""
        Returns the number of paths to search for MDL modules.

        This search path is also used for resources referenced in MDL modules. By default, the list
        of MDL paths is empty.

        :rtype: int
        :return: The number of currently configured paths.
        """
        return _pymdlsdk.IMdl_configuration_get_mdl_paths_length(self)

    def get_mdl_path(self, index):
        r"""
        Returns the ``index`` -th path to search for MDL modules.

        This search path is also used for resources referenced in MDL modules. By default, the list
        of MDL paths is empty.

        :rtype: :py:class:`IString`
        :return: The ``index`` -th path, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk.IMdl_configuration_get_mdl_path(self, index)

    def get_mdl_system_paths_length(self):
        r""" Returns the number of MDL system paths."""
        return _pymdlsdk.IMdl_configuration_get_mdl_system_paths_length(self)

    def get_mdl_system_path(self, index):
        r"""
        Returns the ``index`` -th path in the MDL system paths.

        The default MDL system path is
        - ``%%PROGRAMDATA%``\NVIDIA ``Corporation``\mdl (on Windows),
        - ``/opt/nvidia/mdl`` (on Linux), and
        - ``/Library/Application`` ``Support/NVIDIA`` ``Corporation/mdl`` (on Mac OS).

        The MDL system paths can be changed via the environment variable ``MDL_SYSTEM_PATH``. The
        environment variable can contain multiple paths which are separated by semicolons (on
        Windows) or colons (on Linux and Mac OS), respectively.

        :rtype: string
        :return: The ``index`` -th path, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk.IMdl_configuration_get_mdl_system_path(self, index)

    def add_mdl_system_paths(self):
        r""" Adds the MDL system paths to the MDL search path."""
        return _pymdlsdk.IMdl_configuration_add_mdl_system_paths(self)

    def get_mdl_user_paths_length(self):
        r""" Returns the number of MDL user paths."""
        return _pymdlsdk.IMdl_configuration_get_mdl_user_paths_length(self)

    def get_mdl_user_path(self, index):
        r"""
        Returns the ``index`` -th path in the MDL user paths.

        The default MDL user path is
        - ``%%DOCUMENTS%``\mdl (on Windows),
        - ``$HOME/Documents/mdl`` (on Linux), and
        - ``$HOME/Documents/mdl`` (on Mac OS),
        where %DOCUMENTS% refers to the standard folder identified by ``FOLDERID_Documents`` from
        the Windows API (usually ``%%USERPROFILE%``\Documents).

        The MDL user paths can be changed via the environment variable ``MDL_USER_PATH``. The
        environment variable can contain multiple paths which are separated by semicolons (on
        Windows) or colons (on Linux and Mac OS), respectively.

        :rtype: string
        :return: The ``index`` -th path, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk.IMdl_configuration_get_mdl_user_path(self, index)

    def add_mdl_user_paths(self):
        r""" Adds the MDL user paths to the MDL search path."""
        return _pymdlsdk.IMdl_configuration_add_mdl_user_paths(self)

    def add_resource_path(self, path):
        r"""
        Adds a path to the list of paths to search for resources, i.e., textures, light profiles,
        and BSDF measurements.

        Note that for MDL resources referenced in .``mdl`` files the MDL search paths are considered,
        not the resource search path. By default, the list of resource paths is empty.

        :type path: string
        :param path:                The path to be added.
        :rtype: int
        :return: 
                                       -  0: Success.
                                       - -1: Invalid parameters ( ``NULL`` pointer).
                                       - -2: Invalid path.
        """
        return _pymdlsdk.IMdl_configuration_add_resource_path(self, path)

    def remove_resource_path(self, path):
        r"""
        Removes a path from the list of paths to search for resources, i.e., textures, light
        profiles, and BSDF measurements.

        Note that for MDL resources referenced in .``mdl`` files the MDL search paths are considered,
        not the resource search path. By default, the list of resource paths is empty.

        :type path: string
        :param path:                The path to be removed.
        :rtype: int
        :return: 
                                       -  0: Success.
                                       - -1: Invalid parameters ( ``NULL`` pointer).
                                       - -2: There is no such path in the path list.
        """
        return _pymdlsdk.IMdl_configuration_remove_resource_path(self, path)

    def clear_resource_paths(self):
        r"""
        Clears the list of paths to search for resources, i.e., textures, light profiles,
        and BSDF measurements.

        Note that for MDL resources referenced in .``mdl`` files the MDL search paths are considered,
        not the resource search path. By default, the list of resource paths is empty.
        """
        return _pymdlsdk.IMdl_configuration_clear_resource_paths(self)

    def get_resource_paths_length(self):
        r"""
        Returns the number of paths to search for resources, i.e., textures, light profiles,
        and BSDF measurements.

        Note that for MDL resources referenced in .``mdl`` files the MDL search paths are considered,
        not the resource search path. By default, the list of resource paths is empty.

        :rtype: int
        :return: The number of currently configured paths.
        """
        return _pymdlsdk.IMdl_configuration_get_resource_paths_length(self)

    def get_resource_path(self, index):
        r"""
        Returns the ``index`` -th path to search for resources, i.e., textures, light profiles,
        and BSDF measurements.

        Note that for MDL resources referenced in .``mdl`` files the MDL search paths are considered,
        not the resource search path. By default, the list of resource paths is empty.

        :rtype: :py:class:`IString`
        :return: The ``index`` -th path, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk.IMdl_configuration_get_resource_path(self, index)

    def set_implicit_cast_enabled(self, value):
        r"""
        Defines whether a cast operator is automatically inserted for compatible argument types.

        If set to ``true``, an appropriate cast operator is automatically inserted if arguments for
        instances of #mi::neuraylib::IFunction_call have a different but compatible type. If set to
        ``false``, such an assignment fails and it is necessary to insert the cast operator
        explicitly. Default: ``true``.

        See also: #mi::neuraylib::IExpression_factory::create_cast().

        :type value: boolean
        :param value:    ``True`` to enable the feature, ``false`` otherwise.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: The method cannot be called at this point of time.
        """
        return _pymdlsdk.IMdl_configuration_set_implicit_cast_enabled(self, value)

    def get_implicit_cast_enabled(self):
        r"""
        Indicates whether the SDK is supposed to automatically insert the cast operator for
        compatible types.

        See also: #set_implicit_cast_enabled()
        """
        return _pymdlsdk.IMdl_configuration_get_implicit_cast_enabled(self)

    def set_expose_names_of_let_expressions(self, value):
        r"""
        Defines whether an attempt is made to expose names of let expressions.

        If set to ``true``, the MDL compiler attempts to represent let expressions as temporaries,
        and makes the name of let expressions available as names of such temporaries. In order to
        do so, certain optimizations are disabled, in particular, constant folding. These names are
        only available on material and functions definitions, not on compiled materials, which are
        always highly optimized. Default: ``true``.

        Notes: Since some optimizations are essential for inner workings of the MDL compiler, there

        See also: #mi::neuraylib::IFunction_definition::get_temporary_name()
        """
        return _pymdlsdk.IMdl_configuration_set_expose_names_of_let_expressions(self, value)

    def get_expose_names_of_let_expressions(self):
        r"""
        Indicates whether an attempt is made to expose names of let expressions.

        See also: #set_expose_names_of_let_expressions()
        """
        return _pymdlsdk.IMdl_configuration_get_expose_names_of_let_expressions(self)

    def set_simple_glossy_bsdf_legacy_enabled(self, value):
        r"""
        Configures the behavior of ``df::simple_glossy_bsdf()`` in MDL modules
        of versions smaller than 1.3.

        Notes: If: IRAY_API { This setting can only be configured before The MDL SDKhas been
              started. }Else: This function has no effect in the MDL SDK and always returns -1. {
              }

        :type value: boolean
        :param value:    ``True`` to enable the feature, ``false`` otherwise.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: The method cannot be called at this point of time.
        """
        return _pymdlsdk.IMdl_configuration_set_simple_glossy_bsdf_legacy_enabled(self, value)

    def get_simple_glossy_bsdf_legacy_enabled(self):
        r"""
        Returns ``true`` if the legacy behavior for bsdfs of type ``df::simple_glossy_bsdf()`` used
        in MDL modules with versions smaller that 1.3 is enabled, ``false`` otherwise.
        """
        return _pymdlsdk.IMdl_configuration_get_simple_glossy_bsdf_legacy_enabled(self)

    def get_entity_resolver(self):
        r"""
        Returns an instance of the built-in entity resolver.

        Notes: The returned instance contains a copy of the currently configured search paths,
              subsequent changes to the search paths are not reflected in this instance.
        """
        return _pymdlsdk.IMdl_configuration_get_entity_resolver(self)

    def set_entity_resolver(self, resolver):
        r"""
        Installs an external entity resolver.

        :type resolver: mi::neuraylib::IMdl_entity_resolver
        :param resolver:   The external entity resolver to be used instead of the built-in entity
                              resolver. Pass ``NULL`` to uninstall a previously installed external
                              entity resolver.

        Notes: MDL archive creation is not supported with an external entity resolver ( see
              #mi::neuraylib::IMdl_archive_api::create_archive()).
        """
        return _pymdlsdk.IMdl_configuration_set_entity_resolver(self, resolver)

    def set_materials_are_functions(self, value):
        r"""
        Defines whether materials are treated as functions.

        See also: 'mi_mdl_materials_are_functions', #get_materials_are_functions().
        """
        return _pymdlsdk.IMdl_configuration_set_materials_are_functions(self, value)

    def get_materials_are_functions(self):
        r"""
        Indicates whether materials are treated as functions.

        See also: 'mi_mdl_materials_are_functions', #set_materials_are_functions().
        """
        return _pymdlsdk.IMdl_configuration_get_materials_are_functions(self)

    def set_encoded_names_enabled(self, value):
        r"""
        Defines whether encoded names are enabled.

        See 'mi_mdl_encoded_names' for details.

        This feature is enabled by default. Support for the disabled feature will be deprecated and
        removed in a future release.

        This can only be configured before the MDL SDKhas been started.

        Notes: This feature does not yet support module names containing parentheses or commas.

        If: IRAY_API { Notes: All hosts in a cluster need to agree on this setting. }

        If: IRAY_API { Notes: This setting needs to be the identical during export and import of
                           ``.mib`` files. }

        If: IRAY_API { Notes: Support for Iray Bridge requires that this feature is enabled. }

        See also: #get_encoded_names_enabled().
        """
        return _pymdlsdk.IMdl_configuration_set_encoded_names_enabled(self, value)

    def get_encoded_names_enabled(self):
        r"""
        Indicates whether encoded names are enabled.

        See also: #set_encoded_names_enabled().
        """
        return _pymdlsdk.IMdl_configuration_get_encoded_names_enabled(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IMdl_configuration_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IMdl_configuration__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IMdl_configuration__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IMdl_configuration_get_iid(self)

# Register IMdl_configuration in _pymdlsdk:
_pymdlsdk.IMdl_configuration_swigregister(IMdl_configuration)

def IMdl_configuration_IID():
    return _pymdlsdk.IMdl_configuration_IID()

def IMdl_configuration__get_interface(iface):
    return _pymdlsdk.IMdl_configuration__get_interface(iface)

class IMdl_distiller_api(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IMdl_distiller_api_swiginit(self, _pymdlsdk.new_IMdl_distiller_api(*args))
    __swig_destroy__ = _pymdlsdk.delete_IMdl_distiller_api

    def __deref__(self):
        return _pymdlsdk.IMdl_distiller_api___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IMdl_distiller_api___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IMdl_distiller_api_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IMdl_distiller_api___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IMdl_distiller_api___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IMdl_distiller_api_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IMdl_distiller_api_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IMdl_distiller_api__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_target_count(self):
        r""" Returns the number of targets supported for distilling."""
        return _pymdlsdk.IMdl_distiller_api_get_target_count(self)

    def get_target_name(self, index):
        r"""
        Returns the ``index`` -th target name supported for distilling, or ``NULL`` if ``index`` is out
        of bounds.
        """
        return _pymdlsdk.IMdl_distiller_api_get_target_name(self, index)

    def distill_material_with_ret(self, material, target, distiller_options=None):
        r"""
        Distills a material.

        Material distilling refers to the translation of an arbitrary input material to a
        predefined target model.
        Supported target models are
        - diffuse
        - diffuse_glossy
        - specular_glossy
        - ue4
        - transmissive_pbr

        Depending on the structure of the input material and the
        complexity of the target model the resulting material can be as simple as a single bsdf
        or a set of bsdfs combined using layerers and mixes as illustrated in the table below
        using a pseudo-mdl notation.


             |diffuse
             |surface.scattering = diffuse_reflection_bsdf

                 geometry.normal = ()

           |

             |diffuse_glossy
             |surface.scattering = fresnel_layer(layer: simple_glossy_bsdf,
                 base: diffuse_reflection_bsdf)

                 geometry.normal = ()

          |

             |
                 surface.scattering = diffuse_reflection_bsdf

                 geometry.normal = ()

          |

             |
                 surface.scattering = simple_glossy_bsdf

                 geometry.normal = ()

          |

             |specular_glossy
             |surface.scattering = custom_curve_layer(layer: bsdf_glossy_ggx_vcavities,
                 base: diffuse_reflection_bsdf)

                 geometry.normal = ()

          |

             |
                 Any subset of the above construct, see ``diffuse_glossy``.

          |

             |ue4
             |surface.scattering = custom_curve_layer( // clearcoat

                   layer: bsdf_glossy_ggx_vcavities,

                   base: weighted_layer(

                     layer: normalized_mix(

                       bsdf_glossy_ggx_vcavities,

                       custom_curve_layer(

                         layer:
                 bsdf_glossy_ggx_vcavities,

                         base:
                 diffuse_reflection_bsdf

                       ),

                     ),

                     normal: () // under-clearcoat normal

                   ),

                   normal: () // clearcoat normal

                 )

          |

             |
                 A weighted_layer of any subset of the above construct
                 with an optional clearcoat on top.

          |

             |transmissive_pbr
             |surface.scattering = custom_curve_layer( // clearcoat

                   layer: bsdf_glossy_ggx_vcavities,

                   base: weighted_layer(

                     layer: normalized_mix(

                       bsdf_glossy_ggx_vcavities,

                       custom_curve_layer(

                         layer:
                 bsdf_glossy_ggx_vcavities,

                         base:
                 normalized_mix(


                 bsdf_glossy_ggx_vcavities(scatter_transmit)


                 diffuse_reflection_bsdf

                         ),

                       ),

                     ),

                     normal: () // under-clearcoat normal

                   ),

                   normal: () // clearcoat normal

                 )

          |

             |
                 A weighted_layer of any subset of the above construct
                 with an optional clearcoat on top.

          |


        :type material: :py:class:`ICompiled_material`
        :param material:           The material to be distilled.
        :type target: string
        :param target:             The target model. See #get_target_count() and #get_target_name().
        :type distiller_options: mi::IMap, optional
        :param distiller_options:  Options for the distiller. Supported options are:
                  - ``"top_layer_weight"`` of type ``mi::IFloat32``. This weight is given to the top
                    layer if a Fresnel layered BSDF is simplified to a single diffuse BSDF in the
                    'diffuse' distilling target. The base layer uses one minus this weight.
                    Default: 0.04.
                  - ``"layer_normal"`` of type ``mi::IBoolean``. If ``true``, it enables the aggregation
                    of the local normal maps of BSDF layerers to combine them with the global normal
                    map. Default: ``true``.

        :type errors: int, optional
        :param errors:             An optional pointer to an #mi::Sint32 to which an error code will
                                      be written. The error codes have the following meaning:
                                      -  0: Success.
                                      - -1: Invalid parameters (``NULL`` pointer).
                                      - -2: Invalid target model.
                                      - -3: Unspecified failure.
        :rtype: :py:class:`ICompiled_material`
        :return: The distilled material, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IMdl_distiller_api_distill_material_with_ret(self, material, target, distiller_options)

    def distill_material(self, material, target, distiller_options=None):
        r"""
        *Overload 1:*
        Distills a material.

        Material distilling refers to the translation of an arbitrary input material to a
        predefined target model.
        Supported target models are
        - diffuse
        - diffuse_glossy
        - specular_glossy
        - ue4
        - transmissive_pbr

        Depending on the structure of the input material and the
        complexity of the target model the resulting material can be as simple as a single bsdf
        or a set of bsdfs combined using layerers and mixes as illustrated in the table below
        using a pseudo-mdl notation.


             |diffuse
             |surface.scattering = diffuse_reflection_bsdf

                 geometry.normal = ()

           |

             |diffuse_glossy
             |surface.scattering = fresnel_layer(layer: simple_glossy_bsdf,
                 base: diffuse_reflection_bsdf)

                 geometry.normal = ()

          |

             |
                 surface.scattering = diffuse_reflection_bsdf

                 geometry.normal = ()

          |

             |
                 surface.scattering = simple_glossy_bsdf

                 geometry.normal = ()

          |

             |specular_glossy
             |surface.scattering = custom_curve_layer(layer: bsdf_glossy_ggx_vcavities,
                 base: diffuse_reflection_bsdf)

                 geometry.normal = ()

          |

             |
                 Any subset of the above construct, see ``diffuse_glossy``.

          |

             |ue4
             |surface.scattering = custom_curve_layer( // clearcoat

                   layer: bsdf_glossy_ggx_vcavities,

                   base: weighted_layer(

                     layer: normalized_mix(

                       bsdf_glossy_ggx_vcavities,

                       custom_curve_layer(

                         layer:
                 bsdf_glossy_ggx_vcavities,

                         base:
                 diffuse_reflection_bsdf

                       ),

                     ),

                     normal: () // under-clearcoat normal

                   ),

                   normal: () // clearcoat normal

                 )

          |

             |
                 A weighted_layer of any subset of the above construct
                 with an optional clearcoat on top.

          |

             |transmissive_pbr
             |surface.scattering = custom_curve_layer( // clearcoat

                   layer: bsdf_glossy_ggx_vcavities,

                   base: weighted_layer(

                     layer: normalized_mix(

                       bsdf_glossy_ggx_vcavities,

                       custom_curve_layer(

                         layer:
                 bsdf_glossy_ggx_vcavities,

                         base:
                 normalized_mix(


                 bsdf_glossy_ggx_vcavities(scatter_transmit)


                 diffuse_reflection_bsdf

                         ),

                       ),

                     ),

                     normal: () // under-clearcoat normal

                   ),

                   normal: () // clearcoat normal

                 )

          |

             |
                 A weighted_layer of any subset of the above construct
                 with an optional clearcoat on top.

          |


        :type material: :py:class:`ICompiled_material`
        :param material:           The material to be distilled.
        :type target: string
        :param target:             The target model. See #get_target_count() and #get_target_name().
        :type distiller_options: mi::IMap, optional
        :param distiller_options:  Options for the distiller. Supported options are:
                  - ``"top_layer_weight"`` of type ``mi::IFloat32``. This weight is given to the top
                    layer if a Fresnel layered BSDF is simplified to a single diffuse BSDF in the
                    'diffuse' distilling target. The base layer uses one minus this weight.
                    Default: 0.04.
                  - ``"layer_normal"`` of type ``mi::IBoolean``. If ``true``, it enables the aggregation
                    of the local normal maps of BSDF layerers to combine them with the global normal
                    map. Default: ``true``.

        :param errors:             An optional pointer to an #mi::Sint32 to which an error code will
                                      be written. The error codes have the following meaning:
                                      -  0: Success.
                                      - -1: Invalid parameters (``NULL`` pointer).
                                      - -2: Invalid target model.
                                      - -3: Unspecified failure.
        :rtype: :py:class:`ICompiled_material`
        :return: The distilled material, or ``NULL`` in case of failure.

        |

        *Overload 2:*
        Distills a material.

        Material distilling refers to the translation of an arbitrary input material to a
        predefined target model.
        Supported target models are
        - diffuse
        - diffuse_glossy
        - specular_glossy
        - ue4
        - transmissive_pbr

        Depending on the structure of the input material and the
        complexity of the target model the resulting material can be as simple as a single bsdf
        or a set of bsdfs combined using layerers and mixes as illustrated in the table below
        using a pseudo-mdl notation.


             |diffuse
             |surface.scattering = diffuse_reflection_bsdf

                 geometry.normal = ()

           |

             |diffuse_glossy
             |surface.scattering = fresnel_layer(layer: simple_glossy_bsdf,
                 base: diffuse_reflection_bsdf)

                 geometry.normal = ()

          |

             |
                 surface.scattering = diffuse_reflection_bsdf

                 geometry.normal = ()

          |

             |
                 surface.scattering = simple_glossy_bsdf

                 geometry.normal = ()

          |

             |specular_glossy
             |surface.scattering = custom_curve_layer(layer: bsdf_glossy_ggx_vcavities,
                 base: diffuse_reflection_bsdf)

                 geometry.normal = ()

          |

             |
                 Any subset of the above construct, see ``diffuse_glossy``.

          |

             |ue4
             |surface.scattering = custom_curve_layer( // clearcoat

                   layer: bsdf_glossy_ggx_vcavities,

                   base: weighted_layer(

                     layer: normalized_mix(

                       bsdf_glossy_ggx_vcavities,

                       custom_curve_layer(

                         layer:
                 bsdf_glossy_ggx_vcavities,

                         base:
                 diffuse_reflection_bsdf

                       ),

                     ),

                     normal: () // under-clearcoat normal

                   ),

                   normal: () // clearcoat normal

                 )

          |

             |
                 A weighted_layer of any subset of the above construct
                 with an optional clearcoat on top.

          |

             |transmissive_pbr
             |surface.scattering = custom_curve_layer( // clearcoat

                   layer: bsdf_glossy_ggx_vcavities,

                   base: weighted_layer(

                     layer: normalized_mix(

                       bsdf_glossy_ggx_vcavities,

                       custom_curve_layer(

                         layer:
                 bsdf_glossy_ggx_vcavities,

                         base:
                 normalized_mix(


                 bsdf_glossy_ggx_vcavities(scatter_transmit)


                 diffuse_reflection_bsdf

                         ),

                       ),

                     ),

                     normal: () // under-clearcoat normal

                   ),

                   normal: () // clearcoat normal

                 )

          |

             |
                 A weighted_layer of any subset of the above construct
                 with an optional clearcoat on top.

          |


        :type material: :py:class:`ICompiled_material`
        :param material:           The material to be distilled.
        :type target: string
        :param target:             The target model. See #get_target_count() and #get_target_name().
        :param distiller_options:  Options for the distiller. Supported options are:
                  - ``"top_layer_weight"`` of type ``mi::IFloat32``. This weight is given to the top
                    layer if a Fresnel layered BSDF is simplified to a single diffuse BSDF in the
                    'diffuse' distilling target. The base layer uses one minus this weight.
                    Default: 0.04.
                  - ``"layer_normal"`` of type ``mi::IBoolean``. If ``true``, it enables the aggregation
                    of the local normal maps of BSDF layerers to combine them with the global normal
                    map. Default: ``true``.

        :param errors:             An optional pointer to an #mi::Sint32 to which an error code will
                                      be written. The error codes have the following meaning:
                                      -  0: Success.
                                      - -1: Invalid parameters (``NULL`` pointer).
                                      - -2: Invalid target model.
                                      - -3: Unspecified failure.
        :rtype: :py:class:`ICompiled_material`
        :return: The distilled material, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IMdl_distiller_api_distill_material(self, material, target, distiller_options)

    def create_baker(self, *args):
        r"""
        Creates a baker for texture baking.

        :type material: :py:class:`ICompiled_material`
        :param material:           The material of which a subexpression is to be baked.
        :type path: string
        :param path:               The path from the material root to the expression that should be
                                      baked, e.g., ``"surface.scattering.tint"``.
        :type resource: int, optional
        :param resource:           The resource to be used for baking.
        :type gpu_device_id: int, optional
        :param gpu_device_id:      The device ID of the GPU to be used for baking (as identified by
                                      the CUDA runtime or driver API). Ignored if ``resource`` is
                                      #BAKE_ON_CPU.
        :rtype: :py:class:`IBaker`
        :return: A baker for the expression of the given material identified by
           ``path``, or ``NULL`` in case of failure. Note that returned baker
                                      depends on the transaction that was used to access the material.
        """
        return _pymdlsdk.IMdl_distiller_api_create_baker(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IMdl_distiller_api_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IMdl_distiller_api__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IMdl_distiller_api__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IMdl_distiller_api_get_iid(self)

# Register IMdl_distiller_api in _pymdlsdk:
_pymdlsdk.IMdl_distiller_api_swigregister(IMdl_distiller_api)

def IMdl_distiller_api_IID():
    return _pymdlsdk.IMdl_distiller_api_IID()

def IMdl_distiller_api__get_interface(iface):
    return _pymdlsdk.IMdl_distiller_api__get_interface(iface)

class IMdl_execution_context(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IMdl_execution_context_swiginit(self, _pymdlsdk.new_IMdl_execution_context(*args))
    __swig_destroy__ = _pymdlsdk.delete_IMdl_execution_context

    def __deref__(self):
        return _pymdlsdk.IMdl_execution_context___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IMdl_execution_context___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IMdl_execution_context_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IMdl_execution_context___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IMdl_execution_context___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IMdl_execution_context_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IMdl_execution_context_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IMdl_execution_context__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_messages_count(self):
        r""" Returns the number of messages."""
        return _pymdlsdk.IMdl_execution_context_get_messages_count(self)

    def get_error_messages_count(self):
        r""" Returns the number of error messages."""
        return _pymdlsdk.IMdl_execution_context_get_error_messages_count(self)

    def get_message(self, index):
        r""" Returns the message at index or ``NULL``, if no such index exists."""
        return _pymdlsdk.IMdl_execution_context_get_message(self, index)

    def get_error_message(self, index):
        r""" Returns the error message at index or ``NULL``, if no such index exists."""
        return _pymdlsdk.IMdl_execution_context_get_error_message(self, index)

    def clear_messages(self):
        r""" Clears all messages."""
        return _pymdlsdk.IMdl_execution_context_clear_messages(self)

    def add_message(self, kind, severity, code, message):
        r""" Adds a message."""
        return _pymdlsdk.IMdl_execution_context_add_message(self, kind, severity, code, message)

    def get_option_count(self):
        r""" Returns the number of supported options."""
        return _pymdlsdk.IMdl_execution_context_get_option_count(self)

    def get_option_name(self, index):
        r""" Returns the option name at index."""
        return _pymdlsdk.IMdl_execution_context_get_option_name(self, index)

    def get_option_type(self, name):
        r""" Returns the option type name at index."""
        return _pymdlsdk.IMdl_execution_context_get_option_type(self, name)

    def get_option(self, *args):
        r"""
        *Overload 1:*
        Returns a string option.

        :type name: string
        :param name:          The name of the option.
        :type value: string, out
        :param value:    The value of the option.
        :rtype: int
        :return: 
                                 -  0: Success.
                                 - -1: Invalid option name.
                                 - -2: The option type does not match the value type.

        |

        *Overload 2:*
        Returns an int option.

        :type name: string
        :param name:          The name of the option.
        :type value: int, out
        :param value:    The value of the option.
        :rtype: int
        :return: 
                                 -  0: Success.
                                 - -1: Invalid option name.
                                 - -2: The option type does not match the value type.

        |

        *Overload 3:*
        Returns a float option.

        :type name: string
        :param name:          The name of the option.
        :type value: float, out
        :param value:    The value of the option.
        :rtype: int
        :return: 
                                 -  0: Success.
                                 - -1: Invalid option name.
                                 - -2: The option type does not match the value type.

        |

        *Overload 4:*
        Returns a bool option.

        :type name: string
        :param name:          The name of the option.
        :type value: boolean, out
        :param value:    The value of the option.
        :rtype: int
        :return: 
                                 -  0: Success.
                                 - -1: Invalid option name.
                                 - -2: The option type does not match the value type.

        |

        *Overload 5:*
        Returns an interface option.

        :type name: string
        :param name:          The name of the option.
        :type value: mi::base::IInterface, out
        :param value:    The value of the option.
        :rtype: int
        :return: 
                                 -  0: Success.
                                 - -1: Invalid option name.
                                 - -2: The option type does not match the value type.
        """
        return _pymdlsdk.IMdl_execution_context_get_option(self, *args)

    def set_option(self, *args):
        r"""
        *Overload 1:*
        Sets a string option.

        :type name: string
        :param name:     The name of the option.
        :type value: string
        :param value:    The value of the option.
        :rtype: int
        :return: 
                            -  0: Success.
                            - -1: Invalid option name.
                            - -2: The option type does not match the value type.

        |

        *Overload 2:*
        Sets an int option.

        :type name: string
        :param name:     The name of the option.
        :type value: int
        :param value:    The value of the option.
        :rtype: int
        :return: 
                            -  0: Success.
                            - -1: Invalid option name.
                            - -2: The option type does not match the value type.

        |

        *Overload 3:*
        Sets a float option.

        :type name: string
        :param name:     The name of the option.
        :type value: float
        :param value:    The value of the option.
        :rtype: int
        :return: 
                            -  0: Success.
                            - -1: Invalid option name.
                            - -2: The option type does not match the value type.

        |

        *Overload 4:*
        Sets a bool option.

        :type name: string
        :param name:     The name of the option.
        :type value: boolean
        :param value:    The value of the option.
        :rtype: int
        :return: 
                            -  0: Success.
                            - -1: Invalid option name.
                            - -2: The option type does not match the value type.
                            - -3: The value is invalid in the context of the option.

        |

        *Overload 5:*
        Sets an interface option.

        :type name: string
        :param name:     The name of the option.
        :type value: mi::base::IInterface
        :param value:    The value of the option.
        :rtype: int
        :return: 
                            -  0: Success.
                            - -1: Invalid option name.
                            - -2: The option type does not match the value type.
                            - -3: The value is invalid in the context of the option.
        """
        return _pymdlsdk.IMdl_execution_context_set_option(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IMdl_execution_context_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IMdl_execution_context__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IMdl_execution_context__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IMdl_execution_context_get_iid(self)

# Register IMdl_execution_context in _pymdlsdk:
_pymdlsdk.IMdl_execution_context_swigregister(IMdl_execution_context)

def IMdl_execution_context_IID():
    return _pymdlsdk.IMdl_execution_context_IID()

def IMdl_execution_context__get_interface(iface):
    return _pymdlsdk.IMdl_execution_context__get_interface(iface)

class IMdle_deserialization_callback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IMdle_deserialization_callback_swiginit(self, _pymdlsdk.new_IMdle_deserialization_callback(*args))
    __swig_destroy__ = _pymdlsdk.delete_IMdle_deserialization_callback

    def __deref__(self):
        return _pymdlsdk.IMdle_deserialization_callback___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IMdle_deserialization_callback___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IMdle_deserialization_callback_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IMdle_deserialization_callback___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IMdle_deserialization_callback___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IMdle_deserialization_callback_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IMdle_deserialization_callback_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IMdle_deserialization_callback__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_deserialized_filename(self, serialized_filename):
        r"""
        Returns a the filename of an MDLE module given its serialized filename.

        The callback might get involved several times with the same argument. You might want to
        cache results if the computation is expensive.

        :type serialized_filename: string
        :param serialized_filename:   The "serialized filename" of an MDLE module. This is the string
                                         that has been returned by
                                #mi::neuraylib::IMdle_serialization_callback::get_serialized_filename().
        :rtype: :py:class:`IString`
        :return: The actual filename of that MDLE module.
        """
        return _pymdlsdk.IMdle_deserialization_callback_get_deserialized_filename(self, serialized_filename)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IMdle_deserialization_callback_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IMdle_deserialization_callback__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IMdle_deserialization_callback__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IMdle_deserialization_callback_get_iid(self)

# Register IMdle_deserialization_callback in _pymdlsdk:
_pymdlsdk.IMdle_deserialization_callback_swigregister(IMdle_deserialization_callback)

def IMdle_deserialization_callback_IID():
    return _pymdlsdk.IMdle_deserialization_callback_IID()

def IMdle_deserialization_callback__get_interface(iface):
    return _pymdlsdk.IMdle_deserialization_callback__get_interface(iface)

class IMdle_serialization_callback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IMdle_serialization_callback_swiginit(self, _pymdlsdk.new_IMdle_serialization_callback(*args))
    __swig_destroy__ = _pymdlsdk.delete_IMdle_serialization_callback

    def __deref__(self):
        return _pymdlsdk.IMdle_serialization_callback___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IMdle_serialization_callback___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IMdle_serialization_callback_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IMdle_serialization_callback___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IMdle_serialization_callback___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IMdle_serialization_callback_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IMdle_serialization_callback_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IMdle_serialization_callback__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_serialized_filename(self, filename):
        r"""
        Returns a serialized filename for the given MDLE filename.

        The implemented mapping should be reversible, otherwise you will run into problems
        implementing the corresponding instance of #mi::neuraylib::IMdle_deserialization_callback.

        The callback might get involved several times with the same argument. You might want to
        cache results if the computation is expensive.

        :type filename: string
        :param filename:   The current filename of an MDLE module.
        :rtype: :py:class:`IString`
        :return: The "serialized filename" of that MDLE module. Technically, this can be
                              any string with ``".mdle"`` suffix, it does *not* need to refer to an
                              existing MDLE file on disk.
        """
        return _pymdlsdk.IMdle_serialization_callback_get_serialized_filename(self, filename)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IMdle_serialization_callback_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IMdle_serialization_callback__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IMdle_serialization_callback__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IMdle_serialization_callback_get_iid(self)

# Register IMdle_serialization_callback in _pymdlsdk:
_pymdlsdk.IMdle_serialization_callback_swigregister(IMdle_serialization_callback)

def IMdle_serialization_callback_IID():
    return _pymdlsdk.IMdle_serialization_callback_IID()

def IMdle_serialization_callback__get_interface(iface):
    return _pymdlsdk.IMdle_serialization_callback__get_interface(iface)

class IMdl_factory(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IMdl_factory_swiginit(self, _pymdlsdk.new_IMdl_factory(*args))
    __swig_destroy__ = _pymdlsdk.delete_IMdl_factory

    def __deref__(self):
        return _pymdlsdk.IMdl_factory___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IMdl_factory___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IMdl_factory_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IMdl_factory___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IMdl_factory___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IMdl_factory_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IMdl_factory_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IMdl_factory__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def create_type_factory(self, transaction):
        r""" Returns an MDL type factory for the given transaction."""
        return _pymdlsdk.IMdl_factory_create_type_factory(self, transaction)

    def create_value_factory(self, transaction):
        r""" Returns an MDL value factory for the given transaction."""
        return _pymdlsdk.IMdl_factory_create_value_factory(self, transaction)

    def create_expression_factory(self, transaction):
        r""" Returns an MDL expression factory for the given transaction."""
        return _pymdlsdk.IMdl_factory_create_expression_factory(self, transaction)

    def create_execution_context(self):
        r""" Creates an execution context."""
        return _pymdlsdk.IMdl_factory_create_execution_context(self)

    def clone(self, context):
        r"""
        Clones an execution context.

        Creates a new execution context if ``context`` is NULL (as in #create_execution_context()).
        There is *no* deep copy of option values of type #mi::base::IInterface, they are shared
        by both instances.

        Useful to change options temporarily.
        """
        return _pymdlsdk.IMdl_factory_clone(self, context)

    def create_texture_with_ret(self, transaction, file_path, shape, gamma, selector, shared):
        r"""
        Creates a value referencing a texture identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the texture. The MDL
                                 search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shape: int
        :param shape:         The value that is returned by
                                 #mi::neuraylib::IType_texture::get_shape() on the type corresponding
                                 to the return value.
        :type gamma: float
        :param gamma:         The value that is returned by #mi::neuraylib::ITexture::get_gamma()
                                 on the DB element referenced by the return value.
        :type selector: string
        :param selector:      The selector, or ``NULL``. See section 2.3.1 in ['MDLLS]' for
                                 details.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB elements for that texture
                                 if it has already been loaded, or if you want to create new DB elements
                                 in all cases. Note that sharing is based on the location where the
                                 texture is finally located and includes sharing with instances that
                                 have not explicitly been loaded via this method, e.g., textures in
                                 defaults.
        :type errors: int, optional
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path, or no suitable image
                                       plugin available.
        :rtype: :py:class:`IValue_texture`
        :return: The value referencing the texture, or ``NULL`` in case of failure.

        See also: #mi::neuraylib::IImage::reset_file() if you are given a plain filename instead of an
             MDL file path.
        """
        return _pymdlsdk.IMdl_factory_create_texture_with_ret(self, transaction, file_path, shape, gamma, selector, shared)

    def create_texture(self, transaction, file_path, shape, gamma, selector, shared):
        r"""
        Creates a value referencing a texture identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the texture. The MDL
                                 search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shape: int
        :param shape:         The value that is returned by
                                 #mi::neuraylib::IType_texture::get_shape() on the type corresponding
                                 to the return value.
        :type gamma: float
        :param gamma:         The value that is returned by #mi::neuraylib::ITexture::get_gamma()
                                 on the DB element referenced by the return value.
        :type selector: string
        :param selector:      The selector, or ``NULL``. See section 2.3.1 in ['MDLLS]' for
                                 details.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB elements for that texture
                                 if it has already been loaded, or if you want to create new DB elements
                                 in all cases. Note that sharing is based on the location where the
                                 texture is finally located and includes sharing with instances that
                                 have not explicitly been loaded via this method, e.g., textures in
                                 defaults.
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path, or no suitable image
                                       plugin available.
        :rtype: :py:class:`IValue_texture`
        :return: The value referencing the texture, or ``NULL`` in case of failure.

        See also: #mi::neuraylib::IImage::reset_file() if you are given a plain filename instead of an
             MDL file path.
        """
        return _pymdlsdk.IMdl_factory_create_texture(self, transaction, file_path, shape, gamma, selector, shared)

    def create_light_profile_with_ret(self, transaction, file_path, shared):
        r"""
        Creates a value referencing a light profile identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the light profile. The MDL
                                 search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB element for that light
                                 profile if it has already been loaded, or if you want to create a new
                                 DB element in all cases. Note that sharing is based on the location
                                 where the light profile is finally located and includes sharing with
                                 instances that have not explicitly been loaded via this method, e.g.,
                                 light profiles in defaults.
        :type errors: int, optional
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path.
        :rtype: :py:class:`IValue_light_profile`
        :return: The value referencing the light profile, or ``NULL`` in case of failure.

        See also: #mi::neuraylib::ILightprofile::reset_file() if you are given a plain filename instead
             of an MDL file path.
        """
        return _pymdlsdk.IMdl_factory_create_light_profile_with_ret(self, transaction, file_path, shared)

    def create_light_profile(self, transaction, file_path, shared):
        r"""
        Creates a value referencing a light profile identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the light profile. The MDL
                                 search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB element for that light
                                 profile if it has already been loaded, or if you want to create a new
                                 DB element in all cases. Note that sharing is based on the location
                                 where the light profile is finally located and includes sharing with
                                 instances that have not explicitly been loaded via this method, e.g.,
                                 light profiles in defaults.
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path.
        :rtype: :py:class:`IValue_light_profile`
        :return: The value referencing the light profile, or ``NULL`` in case of failure.

        See also: #mi::neuraylib::ILightprofile::reset_file() if you are given a plain filename instead
             of an MDL file path.
        """
        return _pymdlsdk.IMdl_factory_create_light_profile(self, transaction, file_path, shared)

    def create_bsdf_measurement_with_ret(self, transaction, file_path, shared):
        r"""
        Creates a value referencing a BSDF measurement identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the BSDF measurement. The
                                 MDL search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB element for that BSDF
                                 measurement if it has already been loaded, or if you want to create a
                                 new DB element in all cases. Note that sharing is based on the location
                                 where the BSDF measurement is finally located and includes sharing with
                                 instances that have not explicitly been loaded via this method, e.g.,
                                 BSDF measurements in defaults.
        :type errors: int, optional
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path.
        :rtype: :py:class:`IValue_bsdf_measurement`
        :return: The value referencing the BSDF measurement, or ``NULL`` in case of
                                 failure.

        See also: #mi::neuraylib::IBsdf_measurement::reset_file() if you are given a plain filename
             instead of an MDL file path.
        """
        return _pymdlsdk.IMdl_factory_create_bsdf_measurement_with_ret(self, transaction, file_path, shared)

    def create_bsdf_measurement(self, transaction, file_path, shared):
        r"""
        Creates a value referencing a BSDF measurement identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the BSDF measurement. The
                                 MDL search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB element for that BSDF
                                 measurement if it has already been loaded, or if you want to create a
                                 new DB element in all cases. Note that sharing is based on the location
                                 where the BSDF measurement is finally located and includes sharing with
                                 instances that have not explicitly been loaded via this method, e.g.,
                                 BSDF measurements in defaults.
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path.
        :rtype: :py:class:`IValue_bsdf_measurement`
        :return: The value referencing the BSDF measurement, or ``NULL`` in case of
                                 failure.

        See also: #mi::neuraylib::IBsdf_measurement::reset_file() if you are given a plain filename
             instead of an MDL file path.
        """
        return _pymdlsdk.IMdl_factory_create_bsdf_measurement(self, transaction, file_path, shared)

    def create_module_builder(self, transaction, module_name, min_module_version, max_module_version, context):
        r"""
        Creates a module builder for a given module.

        :type transaction: :py:class:`ITransaction`
        :param transaction:          The transaction to be used.
        :type module_name: string
        :param module_name:          The DB name of the MDL module to build. If there is no such
                                        module, then an empty module with this name and
           ``min_module_version`` is created. Otherwise, the existing module
                                        is edited. Builtin modules or MDLE modules cannot be built or
                                        edited.
        :type min_module_version: int
        :param min_module_version:   The initial MDL version of the new module. Ignored if the
                                        module exists already.
        :type max_module_version: int
        :param max_module_version:   The maximal desired MDL version of the module. If higher than
                                        the current MDL version of the module, then the module builder
                                        will upgrade the MDL version as necessary to handle requests
                                        requiring newer features.
        :type context: :py:class:`IMdl_execution_context`
        :param context:              An execution context which can be queried for detailed error
                                        messages after the operation has finished. Can be ``NULL``.
        :rtype: :py:class:`IMdl_module_builder`
        :return: The module builder for the given module, or ``NULL`` in
                                        case of errors.
        """
        return _pymdlsdk.IMdl_factory_create_module_builder(self, transaction, module_name, min_module_version, max_module_version, context)

    def create_module_transformer(self, transaction, module_name, context):
        r"""
        Creates a module transformer for a given module.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type module_name: string
        :param module_name:   The DB name of the MDL module to transform. Builtin modules cannot be
                                 transformed.
        :type context: :py:class:`IMdl_execution_context`
        :param context:       An execution context which can be queried for detailed error messages
                                 after the operation has finished. Can be ``NULL``.
        :rtype: mi::neuraylib::IMdl_module_transformer
        :return: The module transformer for the given module, or ``NULL`` in case of
                                 errors.
        """
        return _pymdlsdk.IMdl_factory_create_module_transformer(self, transaction, module_name, context)

    def get_db_module_name(self, mdl_name):
        r"""
        Returns the DB name for the MDL name of a module (or file path for MDLE modules).

        For example, given ``"::state"``, the method returns ``"mdl::state"``.

        Notes: This method does not check for existence of the corresponding DB element, nor does it
              check that the input is a valid module name.

        Usage of this method is strongly recommended instead of manually prepending ``"mdl"``,
              since (a) the mapping is more complicated than that, e.g., for MDLE modules, and (b)
              the mapping might change in the future.

        :type mdl_name: string
        :param mdl_name:      The MDL name of the module (non-MDLE and MDLE module), or the file path
                                 of an MDLE module.
        :rtype: :py:class:`IString`
        :return: The DB name of that module, or ``NULL`` if ``mdl_name`` is invalid.
        """
        return _pymdlsdk.IMdl_factory_get_db_module_name(self, mdl_name)

    def get_db_definition_name(self, mdl_name):
        r"""
        Returns the DB name for the MDL name of an material or function definition.

        For example, given ``"::state::normal()"``, the method returns ``"mdl::state::normal()"``.

        Notes: This method does not check for existence of the corresponding DB element, nor does it
              check that the input is a valid material or definition name.

        Usage of this method is strongly recommended instead of manually prepending ``"mdl"``,
              since (a) the mapping is more complicated than that, e.g., for MDLE modules, and (b)
              the mapping might change in the future.

        :type mdl_name: string
        :param mdl_name:      The MDL name of the material or function definition.
        :rtype: :py:class:`IString`
        :return: The DB name of that material or function definition, or ``NULL`` if
                                 ``mdl_name`` is invalid.
        """
        return _pymdlsdk.IMdl_factory_get_db_definition_name(self, mdl_name)

    def analyze_uniform(self, transaction, root_name, root_uniform, query_expr, query_result, error_path, context):
        r"""
         Analyzes whether an expression graph violates the uniform constraints.

         Notes: This method can be used to check already created graphs, but it can also be used to
               check whether a hypothetical connection would observe the uniform constraints: First,
               invoke the method with the root of the existing graph, ``root_uniform`` set to
        ``false`` (at least for materials), and ``query_expr`` set to the graph node to be
               replaced. If the call returns with ``query_result`` set to ``false`` (and no errors in
               the context), then any (valid) subgraph can be connected. Otherwise, invoke the
               method again with the root of the to-be-connected subgraph, ``root_uniform`` set to
        ``true``, and ``query_expr`` set to ``NULL``. If there are no errors, then the subgraph
               can be connected.

         Make sure that ``query_expr`` (if not ``NULL)`` can be reached from ``root_name``,
               otherwise ``query_result`` is always ``false``. In particular, arguments passed during
               call creation (or later for argument changes) are cloned, and the expression that is
               part of the graph is different from the one that was used to construct the graph
               (equal, but not identical).

         :type transaction: :py:class:`ITransaction`
         :param transaction:             The transaction to be used.
         :type root_name: string
         :param root_name:               DB name of the root node of the graph (material instance or
                                            function call).
         :type root_uniform: boolean
         :param root_uniform:            Indicates whether the root node should be uniform.
         :type query_expr: :py:class:`IExpression`
         :param query_expr:              A node of the call graph for which the uniform property is
                                            to be queried. This expression is *only* used to identify
                                            the corresponding node in the graph, i.e., it even makes
                                            sense to pass constant expressions (which by themselves are
                                            always uniform) to determine whether a to-be-connected call
                                            expression has to be uniform. Can be ``NULL``.
         :type query_result: boolean, out
         :param query_result:       Indicates whether ``query_expr`` needs to be uniform (or
                                            ``false`` if ``query_expr`` is ``NULL``, or in case of errors).
         :type error_path: :py:class:`IString`, out
         :param error_path:         A path to a node of the graph that violates the uniform
                                            constraints, or the empty string if there is no such node
                                            (or in case of errors). Such violations are also reported
                                            via ``context``. Can be ``NULL``.
         :type context: :py:class:`IMdl_execution_context`
         :param context:                 The execution context can be used to pass options and to
                                            retrieve error and/or warning messages. Can be ``NULL``.
        """
        return _pymdlsdk.IMdl_factory_analyze_uniform(self, transaction, root_name, root_uniform, query_expr, query_result, error_path, context)

    def decode_name(self, name):
        r"""
        Decodes a DB or MDL name.

        :type name: string
        :param name:   The encoded DB or MDL name to be decoded.
        :rtype: :py:class:`IString`
        :return: The decoded DB or MDL name, or ``NULL`` if ``name`` is ``NULL``. Returns the
                          input string if encoded names are disabled.

        Notes: This method should only be used for display purposes. Do *not* use the returned
              name to identify functions or materials since this representation is ambiguous. For
              modules, it is possible to re-encode their name without loss of information, see
              #encode_module_name(). This is *not* possible for names of function or material
              definitions.

        This method does not require the corresponding module to be loaded. The method does
              not check whether the given name is valid, nor whether it is defined in the
              corresponding module.
        """
        return _pymdlsdk.IMdl_factory_decode_name(self, name)

    def encode_module_name(self, name):
        r"""
        Encodes a DB or MDL module name.

        :type name: string
        :param name:    The decoded DB or MDL module name to be encoded.
        :rtype: :py:class:`IString`
        :return: The encoded DB or MDL module name, or ``NULL`` if ``name`` is ``NULL``. Returns
                           the input string if encoded names are disabled.

        Notes: This method does not require the corresponding module to be loaded. The method does
              not check whether the given name is valid.

        See also: #mi::neuraylib::IMdl_factory::encode_function_definition_name(),
             #mi::neuraylib::IMdl_factory::encode_type_name()
        """
        return _pymdlsdk.IMdl_factory_encode_module_name(self, name)

    def encode_function_definition_name(self, name, parameter_types):
        r"""
        Encodes a DB or MDL function or material definition name.

        :type name: string
        :param name:             The decoded DB or MDL name of a function or material definition
                                    *without* signature.
        :type parameter_types: :py:class:`IArray`
        :param parameter_types:  A static or dynamic array with elements of type #mi::IString
                                    representing decoded positional parameter type names. The value
                                    ``NULL`` can be used for functions or materials without parameters
                                    (treated like an empty array).
        :rtype: :py:class:`IString`
        :return: The encoded function or material definition name, or ``NULL`` if
                                    ``name`` or one of the array elements is ``NULL``. If encoded names
                                    are disabled, then the individual components of the name are joined
                                    by parentheses and commas without further encoding.

        Notes: This method does not require the corresponding module to be loaded. The method does
              not check whether the given name is valid, nor whether it is defined in the
              corresponding module.

        See also: #mi::neuraylib::IMdl_factory::encode_module_name(),
             #mi::neuraylib::IMdl_factory::encode_type_name()
        """
        return _pymdlsdk.IMdl_factory_encode_function_definition_name(self, name, parameter_types)

    def encode_type_name(self, name):
        r"""
        Encodes an MDL type name.

        :type name: string
        :param name:             The decoded MDL name of a type.
        :rtype: :py:class:`IString`
        :return: The encoded MDL name of the type, or ``NULL`` if ``name`` is ``NULL``.
                                    Returns the input string if encoded names are disabled

        Notes: This method does not require the corresponding module to be loaded. The method does
              not check whether the given name is valid, nor whether it is defined in the
              corresponding module.

        See also: #mi::neuraylib::IMdl_factory::encode_function_definition_name(),
             #mi::neuraylib::IMdl_factory::encode_module_name()
        """
        return _pymdlsdk.IMdl_factory_encode_type_name(self, name)

    def deprecated_create_variants(self, transaction, module_name, variant_data):
        return _pymdlsdk.IMdl_factory_deprecated_create_variants(self, transaction, module_name, variant_data)

    def deprecated_create_materials(self, *args):
        return _pymdlsdk.IMdl_factory_deprecated_create_materials(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IMdl_factory_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IMdl_factory__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IMdl_factory__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IMdl_factory_get_iid(self)

# Register IMdl_factory in _pymdlsdk:
_pymdlsdk.IMdl_factory_swigregister(IMdl_factory)

def IMdl_factory_IID():
    return _pymdlsdk.IMdl_factory_IID()

def IMdl_factory__get_interface(iface):
    return _pymdlsdk.IMdl_factory__get_interface(iface)

class IMdl_impexp_api(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IMdl_impexp_api_swiginit(self, _pymdlsdk.new_IMdl_impexp_api(*args))
    __swig_destroy__ = _pymdlsdk.delete_IMdl_impexp_api

    def __deref__(self):
        return _pymdlsdk.IMdl_impexp_api___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IMdl_impexp_api___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IMdl_impexp_api_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IMdl_impexp_api___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IMdl_impexp_api___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IMdl_impexp_api_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IMdl_impexp_api_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IMdl_impexp_api__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def load_module(self, transaction, argument, context=None):
        r"""
        Loads an MDL module from disk (or a builtin module) into the database.

        The module is located on disk according to the module search paths
        (see #mi::neuraylib::IMdl_configuration::add_mdl_path()), loaded, and compiled.
        If successful, the method creates DB elements for the module and all
        its imported modules, as well as for all material and function definitions contained in
        these modules.

        The method can also be used for builtin modules for which the first step, locating the
        module on disk, is skipped.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type argument: string
        :param argument:      The MDL name of the module (for non-MDLE modules), or an MDLE file
                                 path (absolute or relative to the current working directory).
        :type context: :py:class:`IMdl_execution_context`, optional
        :param context:       The execution context can be used to pass options to control the
                                 behavior of the MDL compiler. The following options are supported
                                 by this operation:
                                 - string "internal_space" = "coordinate_object"|"coordinate_world"
                                   (default = "coordinate_world")
                                 .
                                 During module loading, compiler messages
                                 like errors or warnings are stored in the context. Can be ``NULL``.
        :rtype: int
        :return: 
                                 -  1: Success (module exists already, loading from file was skipped).
                                 -  0: Success (module was actually loaded from file or is a builtin
                                       module).
                                 - -1: The MDL module name/MDLE file path ``argument`` is
                                       invalid or a ``NULL`` pointer.
                                 - -2: Failed to find or to compile the module ``argument``.
                                 - -3: The DB name for an imported module is already in use but is not
                                       an MDL module, or the DB name for a definition in this module is
                                       already in use.
                                 - -4: Initialization of an imported module failed.

        See also: #mi::neuraylib::IMdl_impexp_api::get_mdl_module_name()
        """
        return _pymdlsdk.IMdl_impexp_api_load_module(self, transaction, argument, context)

    def load_module_from_string(self, transaction, module_name, module_source, context=None):
        r"""
        Loads an MDL module from memory into the database.

        The provided module source is compiled. If successful, the method creates DB elements for
        the module and all its imported modules, as well as for all material and function
        definitions contained in these modules.

        Notes: String-based module have limitations compared to regular modules loaded from disk:
        - no support for resources, and
        - string-based modules referenced in an import statement need to be loaded explicitly
          upfront (no automatic recursive loading as for file-based modules).

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type module_name: string
        :param module_name:   The MDL name of the module.
        :type module_source: string
        :param module_source: The MDL source code of the module.
        :type context: :py:class:`IMdl_execution_context`, optional
        :param context:       The execution context can be used to pass options to control the
                                 behavior of the MDL compiler. The following options are supported
                                 by this operation:
                                 - string "internal_space" = "coordinate_object"|"coordinate_world"
                                   (default = "coordinate_world")
                                 .
                                 During module loading, compiler messages
                                 like errors or warnings are stored in the context. Can be ``NULL``.
        :rtype: int
        :return: 
                                 -  1: Success (module exists already, creating from ``module_source``
                                       was skipped).
                                 -  0: Success (module was actually created from ``module_source)``.
                                 - -1: The module name ``module_name`` is invalid, or ``module_name`` or
                                       ``module_source`` is a ``NULL`` pointer.
                                 - -2: Shadows a file-based module or failed to compile the module
           ``module_name``.
                                 - -3: The DB name for an imported module is already in use but is not
                                       an MDL module, or the DB name for a definition in this module is
                                       already in use.
                                 - -4: Initialization of an imported module failed.

        See also: #mi::neuraylib::IMdl_impexp_api::get_mdl_module_name()
        """
        return _pymdlsdk.IMdl_impexp_api_load_module_from_string(self, transaction, module_name, module_source, context)

    def export_module(self, transaction, module_name, filename, context=None):
        r"""
        Exports an MDL module from the database to disk.

        The following options are supported:
        - ``"bundle_resources"`` of type bool: If ``true``, referenced resources are exported
          into the same directory as the module, even if they can be found via the module search
          path. Default: ``false``.

        :type transaction: :py:class:`ITransaction`
        :param transaction:       The transaction to be used.
        :type module_name: string
        :param module_name:       The DB name of the MDL module to export.
        :type filename: string
        :param filename:          The name of the file to be used for the export.
        :type context: :py:class:`IMdl_execution_context`, optional
        :param context:           The execution context can be used to pass options to control the
                                     behavior of the MDL compiler. During module loading, compiler
                                     messages like errors or warnings are stored in the context.
                                     Can be ``NULL``.
        :rtype: int
        :return: 
                                     -     0: Success.
                                     -    -1: Invalid parameters (``NULL`` pointer).
                                     -    -2: Failed to open ``filename`` for write operations.
                                     - -6002: There is no MDL module in the database of the given name.
                                     - -6003: The export failed for unknown reasons.
                                     - -6004: The MDL module can not be exported since it is a builtin
                                              module.
                                     - -6005: The MDL module can not be exported since ``filename`` does
                                              not result in a valid MDL identifier.
                                     - -6010: Incorrect type for a referenced resource.
                                     - -6013: The export of a file-based resource failed.
                                     - -6014: The export of a memory-based resource failed.
                                     - -6016: The export of an archive-based resource failed.
        """
        return _pymdlsdk.IMdl_impexp_api_export_module(self, transaction, module_name, filename, context)

    def export_module_to_string(self, transaction, module_name, exported_module, context=None):
        r"""
        Exports an MDL module from the database to string.

        Notes: See #load_module_from_string() for limitations of string-based modules.

        :type transaction: :py:class:`ITransaction`
        :param transaction:       The transaction to be used.
        :type module_name: string
        :param module_name:       The DB name of the MDL module to export.
        :type exported_module: :py:class:`IString`
        :param exported_module:   The exported module source code is written to this string.
        :type context: :py:class:`IMdl_execution_context`, optional
        :param context:           The execution context can be used to pass options to control the
                                     behavior of the MDL compiler. During module loading, compiler
                                     messages like errors or warnings are stored in the context.
                                     Can be ``NULL``.
        :rtype: int
        :return: 
                                     -     0: Success.
                                     -    -1: Invalid parameters (``NULL`` pointer).
                                     - -6002: There is no MDL module in the database of the given name.
                                     - -6003: The export failed for unknown reasons.
                                     - -6004: The MDL module can not be exported since it is a builtin
                                              module.
                                     - -6006: The option ``bundle_resources`` is not supported for
                                              string-based exports.
                                     - -6010: Incorrect type for a referenced resource.
                                     - -6011: The export of file-based resources is not supported for
                                              string-based exports.
                                     - -6012: The export of memory-based resources is not supported for
                                              string-based exports.
                                     - -6013: The export of a file-based resource failed.
                                     - -6014: The export of a memory-based resource failed.
                                     - -6015: The export of archive-based resources is not supported for
                                              string-based exports.
                                     - -6016: The export of an archive-based resource failed.
        """
        return _pymdlsdk.IMdl_impexp_api_export_module_to_string(self, transaction, module_name, exported_module, context)

    def export_canvas(self, filename, canvas, quality=100, force_default_gamma=False):
        r"""
        Exports a canvas to a file on disk.

        If the image plugin that is selected for the export based on the ``filename`` parameter is
        not capable of handling the pixel type of ``canvas``, the canvas is internally converted into
        one of the pixel types supported by that image plugin for export. If the image plugin
        supports multiple pixel types for export, the "best" of them (w.r.t. the pixel type of the
        canvas) is chosen.

        The "best" pixel type is determined by attempting to apply the following conversions in the
        given order to the pixel type of the canvas:
        - use an equivalent pixel type (``"Color"`` instead of ``"Float32<4>"`` and vice versa,
          similar for ``"Rgb_fp"`` / ``"Float32<3>"`` and ``"Rgba"`` / ``"Sint32"``),
        - add an alpha channel (if not already present),
        - increase bits per channel (smaller increase preferred),
        - add additional channels (if possible),
        - decrease bits per channel (smaller decrease preferred), and
        - drop one or more channels.

        :type filename: string
        :param filename:              The file name of the resource to export the canvas to. The
                                         ending of the file name determines the image format, e.g.,
                                         ``".jpg"``. Note that support for a given image format requires
                                         an image plugin capable of handling that format.
        :type canvas: :py:class:`ICanvas`
        :param canvas:                The canvas to export.
        :type quality: int, optional
        :param quality:               The compression quality is an integer in the range from 0 to
                                         100, where 0 is the lowest quality, and 100 is the highest
                                         quality.
        :type force_default_gamma: boolean, optional
        :param force_default_gamma:   If enabled, adjusts the gamma value of the exported pixel data
                                         according to the pixel type chosen for export (1.0 for HDR
                                         pixel types, 2.2 for LDR pixel types).
        :rtype: int
        :return: 
                                        -  0: Success.
                                        - -1: Invalid file name.
                                        - -2: Invalid canvas.
                                        - -3: Invalid quality.
                                        - -4: Unspecified failure.
        """
        return _pymdlsdk.IMdl_impexp_api_export_canvas(self, filename, canvas, quality, force_default_gamma)

    def export_lightprofile(self, filename, lightprofile):
        r"""
        Exports a light profile to disk.

        :type filename: string
        :param filename:          The file name of the resource to export the light profile to.
        :type lightprofile: :py:class:`ILightprofile`
        :param lightprofile:      The light profile to export.
        :rtype: int
        :return: 
                                     -  0: Success.
                                     - -1: Invalid file name.
                                     - -2: Invalid light profile.
                                     - -4: Unspecified failure.
        """
        return _pymdlsdk.IMdl_impexp_api_export_lightprofile(self, filename, lightprofile)

    def export_bsdf_data(self, filename, reflection, transmission):
        r"""
        Exports BSDF data to a file on disk.

        :type filename: string
        :param filename:          The file name of the resource to export the BSDF measurement to.
        :type reflection: mi::neuraylib::IBsdf_isotropic_data
        :param reflection:        The BSDF data for reflection to export. Can be ``NULL``.
        :type transmission: mi::neuraylib::IBsdf_isotropic_data
        :param transmission:      The BSDF data for transmission to export. Can be ``NULL``.
        :rtype: int
        :return: 
                                     -  0: Success.
                                     - -1: Invalid file name.
                                     - -4: Unspecified failure.
        """
        return _pymdlsdk.IMdl_impexp_api_export_bsdf_data(self, filename, reflection, transmission)

    def get_mdl_module_name(self, *args):
        r"""
        Returns the MDL name for an MDL module identified by its filename.

        The return value can be passed to #mi::neuraylib::IMdl_impexp_api::load_module() or
        #mi::neuraylib::IMdl_factory::get_db_module_name().

        Notes: This method does not support MDLE modules. This is also not necessary, since in case
              of MDLEs the filename can be directly passed to
              #mi::neuraylib::IMdl_impexp_api::load_module() or
              #mi::neuraylib::IMdl_factory::get_db_module_name().

        :type filename: string
        :param filename:   The filename of an MDL module (excluding MDLE modules).
        :type option: int, optional
        :param option:     Controls the algorithm's behavior if several overlapping search paths
                              contain the given filename.
        :rtype: :py:class:`IString`
        :return: The MDL name of the given module, or ``NULL`` in case of failures.
        """
        return _pymdlsdk.IMdl_impexp_api_get_mdl_module_name(self, *args)

    def frame_uvtile_marker_to_string(self, marker, f, u, v):
        r"""
        Replaces a frame and/or uv-tile marker by coordinates of a given uv-tile.

        :type marker: string
        :param marker:   String containing a valid frame and/or uv-tile marker.
        :type f: int
        :param f:        The frame number of the uv-tile.
        :type u: int
        :param u:        The u coordinate of the uv-tile.
        :type v: int
        :param v:        The v coordinate of the uv-tile.
        :rtype: :py:class:`IString`
        :return: String with the frame and/or uv-tile marker replaced by the coordinates of
                            the uv-tile, or ``NULL`` in case of errors.
        """
        return _pymdlsdk.IMdl_impexp_api_frame_uvtile_marker_to_string(self, marker, f, u, v)

    def serialize_function_name(self, definition_name, argument_types, return_type, mdle_callback, context):
        r"""
        Serializes the name of a function or material definition.

        See also: 'mi_mdl_serialized_names'

        :type definition_name: string
        :param definition_name:   The DB name of the function or material definition.
        :type argument_types: :py:class:`IType_list`
        :param argument_types:    The arguments of the corresponding function call or material
                                     instance. Required for template-like functions, ignored (can be
                                     ``NULL)`` in all other cases.
        :type return_type: :py:class:`IType`
        :param return_type:       The arguments of the corresponding function call or material
                                     instance. Required for the cast operator, ignored (can be
                                     ``NULL)`` in all other cases.
        :type mdle_callback: :py:class:`IMdle_serialization_callback`
        :param mdle_callback:     Acallback to map the filename of MDLE modules. Ignored for
                                     non-MDLE modules. Can be ``NULL`` (which is treated like a callback
                                     implementing the identity transformation).
        :type context: :py:class:`IMdl_execution_context`
        :param context:           The execution context can be used to pass options and to retrieve
                                     error and/or warning messages. Can be ``NULL``.
        :rtype: :py:class:`ISerialized_function_name`
        :return: The serialized function name, or ``NULL`` in case of errors, or if
                                     encoded names are disabled.
        """
        return _pymdlsdk.IMdl_impexp_api_serialize_function_name(self, definition_name, argument_types, return_type, mdle_callback, context)

    def deserialize_function_name(self, *args):
        r"""
        *Overload 1:*
        Deserializes the serialized name of a function or material definition (first overload)

        See also: 'mi_mdl_serialized_names'

        :type transaction: :py:class:`ITransaction`
        :param transaction:       The transaction to be used.
        :type function_name: string
        :param function_name:     The serialized name of a function or material definition.
        :type mdle_callback: :py:class:`IMdle_deserialization_callback`
        :param mdle_callback:     Acallback to map the filename of MDLE modules. Ignored for
                                     non-MDLE modules. Can be ``NULL`` (which is treated like a callback
                                     implementing the identity transformation).
        :type context: :py:class:`IMdl_execution_context`
        :param context:           The execution context can be used to pass options and to retrieve
                                     error and/or warning messages. Can be ``NULL``.
        :rtype: :py:class:`IDeserialized_function_name`
        :return: The deserialized function name, or ``NULL`` in case of errors, or
                                     if encoded names are disabled.

        |

        *Overload 2:*
        Deserializes the serialized name of a function or material definition (second overload).

        If the corresponding module has not been loaded, it will be loaded as a side effect. The
        method also performs an overload resolution on the deserialized function or material
        definition (as in
        #mi::neuraylib::IModule::get_function_overloads(const char*,const IArray*)const).

        See also: 'mi_mdl_serialized_names'

        :type transaction: :py:class:`ITransaction`
        :param transaction:       The transaction to be used.
        :type module_name: string
        :param module_name:       The serialized name of a module.
        :type function_name_without_module_name: string
        :param function_name_without_module_name:    The serialized name of a function or material
                                                        definition without the module name and ``"::"``
                                                        (as returned by
                    #mi::neuraylib::ISerialized_function_name::get_function_name_without_module_name()).
        :type mdle_callback: :py:class:`IMdle_deserialization_callback`
        :param mdle_callback:     Acallback to map the filename of MDLE modules. Ignored for
                                     non-MDLE modules. Can be ``NULL`` (which is treated like a callback
                                     implementing the identity transformation).
        :type context: :py:class:`IMdl_execution_context`
        :param context:           The execution context can be used to pass options and to retrieve
                                     error and/or warning messages. Can be ``NULL``.
        :rtype: :py:class:`IDeserialized_function_name`
        :return: The deserialized function name, or ``NULL`` in case of errors, or
                                     if encoded names are disabled.
        """
        return _pymdlsdk.IMdl_impexp_api_deserialize_function_name(self, *args)

    def deserialize_module_name(self, module_name, mdle_callback, context):
        r"""
        Deserializes the serialized name of a module.

        If the corresponding module has not been loaded, it will be loaded as a side effect. The
        method also performs an overload resolution on the deserialized function or material
        definition (as in
        #mi::neuraylib::IModule::get_function_overloads(const char*,const IArray*)const).

        See also: 'mi_mdl_serialized_names'

        :type module_name: string
        :param module_name:       The serialized name of a module.
        :type mdle_callback: :py:class:`IMdle_deserialization_callback`
        :param mdle_callback:     Acallback to map the filename of MDLE modules. Ignored for
                                     non-MDLE modules. Can be ``NULL`` (which is treated like a callback
                                     implementing the identity transformation).
        :type context: :py:class:`IMdl_execution_context`
        :param context:           The execution context can be used to pass options and to retrieve
                                     error and/or warning messages. Can be ``NULL``.
        :rtype: :py:class:`IDeserialized_module_name`
        :return: The deserialized module name, or ``NULL`` in case of errors, or
                                     if encoded names are disabled.
        """
        return _pymdlsdk.IMdl_impexp_api_deserialize_module_name(self, module_name, mdle_callback, context)

    def create_reader(self, *args):
        r"""
        *Overload 1:*
        Creates a random-access reader for a given buffer.

        |

        *Overload 2:*
        Returns a random-access reader for a given file.

        :type filename: string
        :param filename:   The filename of the file to get the reader for.
        :rtype: mi::neuraylib::IReader
        :return: A reader that can be used to read the file, or ``NULL`` in case of
                              failures (e.g., there is no such file).
        """
        return _pymdlsdk.IMdl_impexp_api_create_reader(self, *args)

    def create_writer(self, filename):
        r"""
        Returns a random-access writer for a given file.

        :type filename: string
        :param filename:   The filename of the file to get the writer for.
        :rtype: mi::neuraylib::IWriter
        :return: A writer that can be used to write to that file, or ``NULL`` in case of
                              failures (e.g., insufficient permissions).
        """
        return _pymdlsdk.IMdl_impexp_api_create_writer(self, filename)

    def deprecated_uvtile_string_to_marker(self, str, marker):
        return _pymdlsdk.IMdl_impexp_api_deprecated_uvtile_string_to_marker(self, str, marker)

    def deprecated_frame_string_to_marker(self, str, digits):
        return _pymdlsdk.IMdl_impexp_api_deprecated_frame_string_to_marker(self, str, digits)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IMdl_impexp_api_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IMdl_impexp_api__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IMdl_impexp_api__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IMdl_impexp_api_get_iid(self)

# Register IMdl_impexp_api in _pymdlsdk:
_pymdlsdk.IMdl_impexp_api_swigregister(IMdl_impexp_api)

def IMdl_impexp_api_IID():
    return _pymdlsdk.IMdl_impexp_api_IID()

def IMdl_impexp_api__get_interface(iface):
    return _pymdlsdk.IMdl_impexp_api__get_interface(iface)

class IMdl_module_builder(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IMdl_module_builder_swiginit(self, _pymdlsdk.new_IMdl_module_builder(*args))
    __swig_destroy__ = _pymdlsdk.delete_IMdl_module_builder

    def __deref__(self):
        return _pymdlsdk.IMdl_module_builder___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IMdl_module_builder___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IMdl_module_builder_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IMdl_module_builder___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IMdl_module_builder___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IMdl_module_builder_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IMdl_module_builder_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IMdl_module_builder__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def add_variant(self, name, prototype_name, defaults, annotations, return_annotations, is_exported, context):
        r"""
        Adds a variant to the module.

        :type name: string
        :param name:                    The simple name of the material or function variant.
        :type prototype_name: string
        :param prototype_name:          The DB name of the prototype of the new variant.
        :type defaults: :py:class:`IExpression_list`
        :param defaults:                Default values to set. If ``NULL``, the defaults of the
                                           original material or function are used. Feasible
                                           sub-expression kinds: constants and calls.
        :type annotations: :py:class:`IAnnotation_block`
        :param annotations:             Annotations to set. If ``NULL``, the annotations of the
                                           original material or function are used. Pass an empty block
                                           to remove all annotations.
        :type return_annotations: :py:class:`IAnnotation_block`
        :param return_annotations:      Return annotations to set. If ``NULL``, the annotations of
                                           the original material or function are used. Pass an empty
                                           block to remove all annotations. Materials require ``NULL`` or
                                           an empty annotation block here.
        :type is_exported: boolean
        :param is_exported:             Indicates whether the variant will have the 'export' keyword.
        :type context: :py:class:`IMdl_execution_context`
        :param context:                 The execution context can be used to pass options and to
                                           retrieve error and/or warning messages. Can be ``NULL``.
        :rtype: int
        :return: 0 in case of success, or -1 in case of failure.
        """
        return _pymdlsdk.IMdl_module_builder_add_variant(self, name, prototype_name, defaults, annotations, return_annotations, is_exported, context)

    def add_function(self, name, body, parameters, defaults, parameter_annotations, annotations, return_annotations, is_exported, frequency_qualifier, context):
        r"""
        Adds a material or function to the module.

        :type name: string
        :param name:                    The simple name of the material or function.
        :type body: :py:class:`IExpression`
        :param body:                    The body of the new material or function (constants, direct
                                           calls, and parameter references). Feasible sub-expression
                                           kinds: constants, direct calls, and parameter references.
        :type parameters: :py:class:`IType_list`
        :param parameters:              Types and names of the parameters. Can be ``NULL`` (treated
                                           like an empty parameter list).
        :type defaults: :py:class:`IExpression_list`
        :param defaults:                Default values. Can be ``NULL`` or incomplete. Feasible
                                           sub-expression kinds: constants, calls, and direct calls.
        :type parameter_annotations: :py:class:`IAnnotation_list`
        :param parameter_annotations:   Parameter annotations. Can be ``NULL`` or incomplete.
        :type annotations: :py:class:`IAnnotation_block`
        :param annotations:             Annotations of the material or function. Can be ``NULL``.
        :type return_annotations: :py:class:`IAnnotation_block`
        :param return_annotations:      Return annotations of the function. Can be ``NULL`` for
                                           functions, must be ``NULL`` for materials.
        :type is_exported: boolean
        :param is_exported:             Indicates whether the material or function will have the
                                           'export' keyword.
        :type frequency_qualifier: int
        :param frequency_qualifier:     The frequency qualifier for functions, or
                                           #mi::neuraylib::IType::MK_NONE for materials.
        :type context: :py:class:`IMdl_execution_context`
        :param context:                 The execution context can be used to pass options and to
                                           retrieve error and/or warning messages. Can be ``NULL``.
        """
        return _pymdlsdk.IMdl_module_builder_add_function(self, name, body, parameters, defaults, parameter_annotations, annotations, return_annotations, is_exported, frequency_qualifier, context)

    def add_annotation(self, name, parameters, defaults, parameter_annotations, annotations, is_exported, context):
        r"""
        Adds an annotation to the module.

        :type name: string
        :param name:                    The simple name of the annotation.
        :type parameters: :py:class:`IType_list`
        :param parameters:              Types and names of the parameters. Can be ``NULL`` (treated
                                           like an empty parameter list).
        :type defaults: :py:class:`IExpression_list`
        :param defaults:                Default values. Can be ``NULL`` or incomplete. Feasible
                                           sub-expression kinds: constants, calls, and direct calls.
        :type parameter_annotations: :py:class:`IAnnotation_list`
        :param parameter_annotations:   Parameter annotations. Can be ``NULL`` or incomplete.
        :type annotations: :py:class:`IAnnotation_block`
        :param annotations:             Annotations of the annotation. Can be ``NULL``.
        :type is_exported: boolean
        :param is_exported:             Indicates whether the annotation will have the 'export'
                                           keyword.
        :type context: :py:class:`IMdl_execution_context`
        :param context:                 The execution context can be used to pass options and to
                                           retrieve error and/or warning messages. Can be ``NULL``.
        """
        return _pymdlsdk.IMdl_module_builder_add_annotation(self, name, parameters, defaults, parameter_annotations, annotations, is_exported, context)

    def add_enum_type(self, name, enumerators, enumerator_annotations, annotations, is_exported, context):
        r"""
        Adds an enum type to the module.

        Notes: Changing a particular enum type, i.e., removing it and re-adding it differently, is

        :type name: string
        :param name:                    The simple name of the enum type.
        :type enumerators: :py:class:`IExpression_list`
        :param enumerators:             Enumerators of the enum type. Must not be empty. Feasible
                                           sub-expression kinds: constants and direct calls.
        :type enumerator_annotations: :py:class:`IAnnotation_list`
        :param enumerator_annotations:  Enumerator annotations. Can be ``NULL`` or incomplete.
        :type annotations: :py:class:`IAnnotation_block`
        :param annotations:             Annotations of the enum type. Can be ``NULL``.
        :type is_exported: boolean
        :param is_exported:             Indicates whether the enum type will have the 'export'
                                           keyword.
        :type context: :py:class:`IMdl_execution_context`
        :param context:                 The execution context can be used to pass options and to
                                           retrieve error and/or warning messages. Can be ``NULL``.
        """
        return _pymdlsdk.IMdl_module_builder_add_enum_type(self, name, enumerators, enumerator_annotations, annotations, is_exported, context)

    def add_struct_type(self, name, fields, field_defaults, field_annotations, annotations, is_exported, context):
        r"""
        Adds a struct type to the module.

        Notes: Changing a particular struct type, i.e., removing it and re-adding it differently, is

        :type name: string
        :param name:                    The simple name of the enum type.
        :type fields: :py:class:`IType_list`
        :param fields:                  Fields of the struct type. Must not be empty.
        :type field_defaults: :py:class:`IExpression_list`
        :param field_defaults:          Defaults of the struct fields. Can be ``NULL`` or incomplete.
                                           Feasible sub-expression kinds: constants and direct calls.
        :type field_annotations: :py:class:`IAnnotation_list`
        :param field_annotations:       Field annotations of the struct type. Can be ``NULL`` or
                                           incomplete.
        :type annotations: :py:class:`IAnnotation_block`
        :param annotations:             Annotations of the struct type. Can be ``NULL``.
        :type is_exported: boolean
        :param is_exported:             Indicates whether the struct type will have the 'export'
                                           keyword.
        :type context: :py:class:`IMdl_execution_context`
        :param context:                 The execution context can be used to pass options and to
                                           retrieve error and/or warning messages. Can be ``NULL``.
        """
        return _pymdlsdk.IMdl_module_builder_add_struct_type(self, name, fields, field_defaults, field_annotations, annotations, is_exported, context)

    def add_constant(self, name, expr, annotations, is_exported, context):
        r"""
        Adds a constant to the module.

        :type name: string
        :param name:                    The simple name of the constant.
        :type expr: :py:class:`IExpression`
        :param expr:                    The value of the constant.
                                           Feasible sub-expression kinds: constants and direct calls.
        :type annotations: :py:class:`IAnnotation_block`
        :param annotations:             Annotations of the constant. Can be ``NULL``.
        :type is_exported: boolean
        :param is_exported:             Indicates whether the constant will have the 'export'
                                           keyword.
        :type context: :py:class:`IMdl_execution_context`
        :param context:                 The execution context can be used to pass options and to
                                           retrieve error and/or warning messages. Can be ``NULL``.
        """
        return _pymdlsdk.IMdl_module_builder_add_constant(self, name, expr, annotations, is_exported, context)

    def set_module_annotations(self, annotations, context):
        r"""
        Sets the annotations of the module itself.

        :type annotations: :py:class:`IAnnotation_block`
        :param annotations:             Annotations of the module. Pass ``NULL`` to remove existing
                                           annotations.
        :type context: :py:class:`IMdl_execution_context`
        :param context:                 The execution context can be used to pass options and to
                                           retrieve error and/or warning messages. Can be ``NULL``.
        """
        return _pymdlsdk.IMdl_module_builder_set_module_annotations(self, annotations, context)

    def remove_entity(self, name, index, context):
        r"""
        Removes a material, function, enum or struct type from the module.

        :type name: string
        :param name:                    The simple name of material, function, enum or struct type to
                                           be removed.
        :type index: int
        :param index:                   The index of the function with the given name to be removed.
                                           Used to distinguish overloads of functions. Zero 0 for
                                           materials, enum or struct types.
        :type context: :py:class:`IMdl_execution_context`
        :param context:                 The execution context can be used to pass options and to
                                           retrieve error and/or warning messages. Can be ``NULL``.
        """
        return _pymdlsdk.IMdl_module_builder_remove_entity(self, name, index, context)

    def clear_module(self, context):
        r""" Clears the module, i.e., removes all declarations from the module."""
        return _pymdlsdk.IMdl_module_builder_clear_module(self, context)

    def analyze_uniform(self, root_expr, root_expr_uniform, context):
        r"""
        Analyzes which parameters need to be uniform.

        :type root_expr: :py:class:`IExpression`
        :param root_expr:               Root expression of the graph, i.e., the body of the new
                                           material or function.
        :type root_expr_uniform: boolean
        :param root_expr_uniform:       Indicates whether the root expression should be uniform.
        :type context: :py:class:`IMdl_execution_context`
        :param context:                 The execution context can be used to pass options and to
                                           retrieve error and/or warning messages. Can be ``NULL``.
        :rtype: :py:class:`IArray`
        :return: Indicates which parameters need to be uniform. The array
                                           might be shorter than expected if trailing parameters are
                                           not referenced by ``root_expr`` (or in case of errors).
        """
        return _pymdlsdk.IMdl_module_builder_analyze_uniform(self, root_expr, root_expr_uniform, context)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IMdl_module_builder_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IMdl_module_builder__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IMdl_module_builder__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IMdl_module_builder_get_iid(self)

# Register IMdl_module_builder in _pymdlsdk:
_pymdlsdk.IMdl_module_builder_swigregister(IMdl_module_builder)

def IMdl_module_builder_IID():
    return _pymdlsdk.IMdl_module_builder_IID()

def IMdl_module_builder__get_interface(iface):
    return _pymdlsdk.IMdl_module_builder__get_interface(iface)

class IMessage(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IMessage_swiginit(self, _pymdlsdk.new_IMessage(*args))
    __swig_destroy__ = _pymdlsdk.delete_IMessage

    def __deref__(self):
        return _pymdlsdk.IMessage___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IMessage___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IMessage_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IMessage___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IMessage___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IMessage_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IMessage_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IMessage__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self):
        r""" Returns the kind of message."""
        return _pymdlsdk.IMessage_get_kind(self)

    def get_severity(self):
        r""" Returns the severity of the message."""
        return _pymdlsdk.IMessage_get_severity(self)

    def get_string(self):
        r""" Returns the message string."""
        return _pymdlsdk.IMessage_get_string(self)

    def get_code(self):
        r""" Returns a unique identifier for the message."""
        return _pymdlsdk.IMessage_get_code(self)

    def get_notes_count(self):
        r"""
        Returns the number of notes associated with the message

        Notes can be used to describe an error message further or add additional details.
        """
        return _pymdlsdk.IMessage_get_notes_count(self)

    def get_note(self, index):
        r""" Returns the note at index or ``NULL``, if no such index exists."""
        return _pymdlsdk.IMessage_get_note(self, index)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IMessage_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IMessage__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IMessage__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IMessage_get_iid(self)

# Register IMessage in _pymdlsdk:
_pymdlsdk.IMessage_swigregister(IMessage)

def IMessage_IID():
    return _pymdlsdk.IMessage_IID()

def IMessage__get_interface(iface):
    return _pymdlsdk.IMessage__get_interface(iface)

class IModule(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IModule_swiginit(self, _pymdlsdk.new_IModule(*args))
    __swig_destroy__ = _pymdlsdk.delete_IModule

    def __deref__(self):
        return _pymdlsdk.IModule___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IModule___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IModule_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IModule___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IModule___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IModule_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IModule_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IModule__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_filename(self):
        r"""
        Returns the name of the MDL source file from which this module was created.

        :rtype: string
        :return: The full pathname of the source file from which this MDL module was created,
                            or ``NULL`` if no such file exists.
        """
        return _pymdlsdk.IModule_get_filename(self)

    def get_mdl_name(self):
        r"""
        Returns the MDL name of the module.

        Notes: The MDL name of the module is different from the name of the DB element.
              Use #mi::neuraylib::ITransaction::name_of() to obtain the name of the DB element.

        :rtype: string
        :return: The MDL name of the module.
        """
        return _pymdlsdk.IModule_get_mdl_name(self)

    def get_mdl_package_component_count(self):
        r""" Returns the number of package components in the MDL name."""
        return _pymdlsdk.IModule_get_mdl_package_component_count(self)

    def get_mdl_package_component_name(self, index):
        r"""
        Returns the name of a package component in the MDL name.

        :rtype: string
        :return: The ``index`` -th package component name, or ``NULL`` if ``index`` is out of
                            bounds.
        """
        return _pymdlsdk.IModule_get_mdl_package_component_name(self, index)

    def get_mdl_simple_name(self):
        r"""
        Returns the simple MDL name of the module.

        The simple name is the last component of the MDL name, i.e., without any packages and scope
        qualifiers.

        :rtype: string
        :return: The simple MDL name of the module.
        """
        return _pymdlsdk.IModule_get_mdl_simple_name(self)

    def get_mdl_version(self):
        r""" Returns the MDL version of this module."""
        return _pymdlsdk.IModule_get_mdl_version(self)

    def get_import_count(self):
        r""" Returns the number of modules imported by the module."""
        return _pymdlsdk.IModule_get_import_count(self)

    def get_import(self, index):
        r"""
        Returns the DB name of the imported module at ``index``.

        :type index: int
        :param index:    The index of the imported module.
        :rtype: string
        :return: The DB name of the imported module.
        """
        return _pymdlsdk.IModule_get_import(self, index)

    def get_types(self):
        r""" Returns the types exported by this module."""
        return _pymdlsdk.IModule_get_types(self)

    def get_constants(self):
        r""" Returns the constants exported by this module."""
        return _pymdlsdk.IModule_get_constants(self)

    def get_function_count(self):
        r""" Returns the number of function definitions exported by the module."""
        return _pymdlsdk.IModule_get_function_count(self)

    def get_function(self, index):
        r"""
        Returns the DB name of the function definition at ``index``.

        :type index: int
        :param index:    The index of the function definition.
        :rtype: string
        :return: The DB name of the function definition. The method may return ``NULL`` for
                            valid indices if the corresponding function definition has already been
                            removed from the DB.
        """
        return _pymdlsdk.IModule_get_function(self, index)

    def get_material_count(self):
        r""" Returns the number of material definitions exported by the module."""
        return _pymdlsdk.IModule_get_material_count(self)

    def get_material(self, index):
        r"""
        Returns the DB name of the material definition at ``index``.

        :type index: int
        :param index:    The index of the material definition.
        :rtype: string
        :return: The DB name of the material definition. The method may return ``NULL`` for
                            valid indices if the corresponding material definition has already been
                            removed from the DB.
        """
        return _pymdlsdk.IModule_get_material(self, index)

    def get_resources_count(self):
        r"""
        Returns the number of resources defined in the module.

        Resources defined in a module that is imported by this module are not included.
        """
        return _pymdlsdk.IModule_get_resources_count(self)

    def get_resource(self, index):
        r"""
        Returns a resource defined in the module.

        Resources defined in a module that is imported by this module are not included.
        """
        return _pymdlsdk.IModule_get_resource(self, index)

    def get_annotation_definition_count(self):
        r""" Returns the number of annotations defined in the module."""
        return _pymdlsdk.IModule_get_annotation_definition_count(self)

    def get_annotation_definition(self, *args):
        r"""
        *Overload 1:*
        Returns the annotation definition at ``index``.

        :type index: int
        :param index:    The index of the annotation definition.
        :rtype: :py:class:`IAnnotation_definition`
        :return: The annotation definition or ``NULL`` if
                            ``index`` is out of range.

        |

        *Overload 2:*
        Returns the annotation definition of the given ``name``.

        :type name: string
        :param name:     The name of the annotation definition.
        :rtype: :py:class:`IAnnotation_definition`
        :return: The annotation definition or ``NULL`` if there is no such definition.
        """
        return _pymdlsdk.IModule_get_annotation_definition(self, *args)

    def get_annotations(self):
        r""" Returns the annotations of the module, or ``NULL`` if there are no such annotations."""
        return _pymdlsdk.IModule_get_annotations(self)

    def is_standard_module(self):
        r"""
        Indicates whether this module is a standard module.

        Examples for standard modules are ``"limits"``, ``"anno"``, ``"state"``, ``"math"``, ``"tex"``,
        ``"noise"``, and ``"df"``.
        """
        return _pymdlsdk.IModule_is_standard_module(self)

    def is_mdle_module(self):
        r""" Indicates whether this module results from an ``.mdle`` file."""
        return _pymdlsdk.IModule_is_mdle_module(self)

    def get_function_overloads(self, *args):
        r"""
        *Overload 1:*
        Returns overloads of a function or material definition.

        The method returns overloads of a function or material definition of this module, either
        all overloads or just the overloads matching a given set of arguments.

        :type name: string
        :param name:             The DB name of a function or material definition from this module
                                    *without* signature.
        :type arguments: :py:class:`IExpression_list`, optional
        :param arguments:        Optional arguments to select specific overload(s). If present, the
                                    method returns only the overloads of ``name`` whose signature
                                    matches the provided arguments, i.e., a call to
                                    #mi::neuraylib::IFunction_definition::create_function_call() with
                                    these arguments would succeed.
        :rtype: :py:class:`IArray`
        :return: The DB names of overloads of the given function or material
                                    definition, or ``NULL`` if ``name`` is invalid.

        |

        *Overload 2:*
        Returns overloads of a function or material definition.

        The method returns the best-matching overloads of a function or material definition of this
        module, given a list of positional parameter types.

        Notes: This overload should only be used if no actual arguments are available. If arguments
              are available, consider using
              #get_function_overloads(const char*,const IExpression_list*)const instead.

        This method does not work for the function definitions with the following semantics:
              - #mi::neuraylib::IFunction_definition::DS_CAST,
              - #mi::neuraylib::IFunction_definition::DS_TERNARY,
              - #mi::neuraylib::IFunction_definition::DS_ARRAY_INDEX,
              - #mi::neuraylib::IFunction_definition::DS_INTRINSIC_DAG_ARRAY_CONSTRUCTOR,
              - #mi::neuraylib::IFunction_definition::DS_INTRINSIC_DAG_ARRAY_LENGTH. and
              - #mi::neuraylib::IFunction_definition::DS_INTRINSIC_DAG_FIELD_ACCESS.
              These are the 'mi_neuray_mdl_template_like_function_definitions' plus the field
              access function definitions.

        :type name: string
        :param name:             The DB name of a function or material definition from this module
                                    *without* signature.
        :type parameter_types: :py:class:`IArray`
        :param parameter_types:  A static or dynamic array with elements of type #mi::IString
                                    representing positional parameter type names as returned by
                                    #mi::neuraylib::IFunction_definition::get_mdl_parameter_type_name().
        :rtype: :py:class:`IArray`
        :return: The DB names of overloads of the given function or material
                                    definition, or ``NULL`` if ``name`` is invalid.
        """
        return _pymdlsdk.IModule_get_function_overloads(self, *args)

    def is_valid(self, context):
        r"""
        Returns ``true`` if all imports of the module are valid.

        :type context: :py:class:`IMdl_execution_context`
        :param context:     In case of failure, the execution context can be checked for error
                               messages. Can be ``NULL``.
        """
        return _pymdlsdk.IModule_is_valid(self, context)

    def reload(self, recursive, context):
        r"""
        Reload the module from disk.

        Notes: This function works for file-based modules, only.

        :type context: :py:class:`IMdl_execution_context`
        :param context:     In case of failure, the execution context can be checked for error
                               messages. Can be ``NULL``.
        :type recursive: boolean
        :param recursive:   If ``true``, all imported file based modules are reloaded
                               prior to this one.
        :rtype: int
        :return: 
                          -     0: Success
                          -    -1: Reloading failed, check the context for details.
        """
        return _pymdlsdk.IModule_reload(self, recursive, context)

    def reload_from_string(self, module_source, recursive, context):
        r"""
        Reload the module from string.

        Notes: This function works for string/memory-based modules, only. Standard modules and
        the built-in If: MDL_SOURCE_RELEASE { module mdl::base }Else: modules  {``mdl::base`` and
        ``mdl::nvidia::distilling_support`` } cannot be reloaded.

        :type module_source: string
        :param module_source: The module source code.
        :type recursive: boolean
        :param recursive:     If ``true``, all imported file based modules are reloaded
                                 prior to this one.
        :type context: :py:class:`IMdl_execution_context`
        :param context:       In case of failure, the execution context can be checked for error
                                 messages. Can be ``NULL``.
        :rtype: int
        :return: 
                          -     0: Success
                          -    -1: Reloading failed, check the context for details.
        """
        return _pymdlsdk.IModule_reload_from_string(self, module_source, recursive, context)

    def deprecated_get_function_overloads(self, name, param_sig):
        return _pymdlsdk.IModule_deprecated_get_function_overloads(self, name, param_sig)

    def deprecated_get_resource_type(self, index):
        return _pymdlsdk.IModule_deprecated_get_resource_type(self, index)

    def deprecated_get_resource_mdl_file_path(self, index):
        return _pymdlsdk.IModule_deprecated_get_resource_mdl_file_path(self, index)

    def deprecated_get_resource_name(self, index):
        return _pymdlsdk.IModule_deprecated_get_resource_name(self, index)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IModule_compare_iid(self, iid)

    def get_element_type(self):
        r""" Indicates the actual scene element represented by interfaces derived from this interface."""
        return _pymdlsdk.IModule_get_element_type(self)

    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk.IModule_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk.IModule_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IModule_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IModule_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk.IModule_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk.IModule_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk.IModule_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk.IModule_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk.IModule_enumerate_attributes(self, index)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IModule__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IModule__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IModule_get_iid(self)

# Register IModule in _pymdlsdk:
_pymdlsdk.IModule_swigregister(IModule)

def IModule_IID():
    return _pymdlsdk.IModule_IID()

def IModule__get_interface(iface):
    return _pymdlsdk.IModule__get_interface(iface)

class INeuray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.INeuray_swiginit(self, _pymdlsdk.new_INeuray(*args))
    __swig_destroy__ = _pymdlsdk.delete_INeuray

    def __deref__(self):
        return _pymdlsdk.INeuray___deref__(self)

    def __ref__(self):
        return _pymdlsdk.INeuray___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.INeuray_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.INeuray___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.INeuray___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.INeuray_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.INeuray_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.INeuray__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    class Status(Enum):
        PRE_STARTING = _pymdlsdk._INeuray_PRE_STARTING
        STARTING = _pymdlsdk._INeuray_STARTING
        STARTED = _pymdlsdk._INeuray_STARTED
        SHUTTINGDOWN = _pymdlsdk._INeuray_SHUTTINGDOWN
        SHUTDOWN = _pymdlsdk._INeuray_SHUTDOWN
        FAILURE = _pymdlsdk._INeuray_FAILURE

    def get_api_component(self, type):
        iinterface = self._get_api_component(type.IID())
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_status(self, *args):
        return INeuray.Status(self._get_status(*args))


    def get_interface_version(self):
        r"""
        Returns the interface version of the MDL SDK library.

        This number changes whenever the abstract interfaces of the MDL SDK APIchanges.
        """
        return _pymdlsdk.INeuray_get_interface_version(self)

    def get_version(self):
        r"""
        Returns the version of the MDL SDK library.

        This string contains the product version, build number, build date, and platform of the
        current library.
        """
        return _pymdlsdk.INeuray_get_version(self)

    def start(self, blocking=True):
        r"""
        Starts the operation of the MDL SDK library.

        All configuration which is marked to be done before the start of the library must be done
        before calling this function. When calling this function the MDL SDKwill start
        threads and start network operations etc. The MDL SDK librarymay not be ready for
        operation after the call returned if blocking mode is not used.

        If: IRAY_API {
        Notes: Starting the MDL SDK librarymultiple times, i.e., calling #shutdown() then calling
              #start() again, is not yet supported. This is true even if the first call to
              #start() fails.
        }

        :type blocking: boolean, optional
        :param blocking:If: MDL_SDK_API { Unused. The startup is always done in blocking mode.
                           }Else: Indicates whether the startup should be done in blocking mode. If {
                           ``true`` the method will not return before all initialization was done. If
                           ``false`` the method will return immediately and the startup is done in a
                           separate thread. The status of the startup sequence can be checked via
                           #get_status(). }
        :rtype: int
        :return: 
                               -  0: Success
                               - -1: Unspecified failure.
                               - -2: Authentication failure (challenge-response).
                               - -4: Provided license expired.
                               - -5: No professional GPU as required by the license in use was found.
                               - -6: Authentication failure (FLEXlm).
                               - -7: No NVIDIA VCA as required by the license in use was found.
        """
        return _pymdlsdk.INeuray_start(self, blocking)

    def shutdown(self, blocking=True):
        r"""
        Shuts down the library.

        For proper shutdown this may only be called after all transactions have been committed and
        all rendering is finished.

        You also need to release all interface pointers related to functionality obtained after
        startup before calling this method. In case you use the #mi::base::Handle class (or another
        handle class), you need to make sure that all such handles have been reset or destroyed.

        If: IRAY_API {
        Notes: Starting the MDL SDK librarymultiple times, i.e., calling #shutdown() then calling
              #start() again, is not yet supported. This is true even if the first call to
              #start() fails.
        }

        :type blocking: boolean, optional
        :param blocking:If: MDL_SDK_API { Unused. The shutdown is always done in blocking mode.
                           }Else: Indicates whether the shutdown should be done in blocking mode. If {
                           ``true`` the method will not return before shutdown has completed.
                           If ``false`` the method will return immediately and the shutdown is done
                           in a separate thread. The status of the shutdown sequence can be checked
                           via #get_status(). }
        :rtype: int
        :return: 0, in case of success, -1 in case of failure
        """
        return _pymdlsdk.INeuray_shutdown(self, blocking)

    def _get_status(self):
        r"""
        Returns the status of the library.

        :rtype: int
        :return: The status
        """
        return _pymdlsdk.INeuray__get_status(self)

    def _get_api_component(self, uuid):
        r"""
        Returns an API component from the MDL SDK API.

        See also: 'mi_neuray_api_components' for a list of built-in API components.

        See also: #register_api_component(), #unregister_api_component()

        :type uuid: :py:class:`Uuid`
        :param uuid:        The UUID under which the API components was registered. For built-in
                               API components this is the interface ID of the corresponding interface.
        :rtype: mi::base::IInterface
        :return: A pointer to the API component or ``NULL`` if the API component is not
                               supported or currently not available.
        """
        return _pymdlsdk.INeuray__get_api_component(self, uuid)

    def register_api_component(self, uuid, api_component):
        r"""
        Registers an API component with the MDL SDK API

        API components are a way for plugins to provide access to their functionality. The
        registration makes the API component available for subsequent calls of #get_api_component().

        :type uuid: :py:class:`Uuid`
        :param uuid:            The ID of the API component to register, e.g., the interface ID of
                                   the corresponding interface.
        :type api_component: mi::base::IInterface
        :param api_component:   The API component to register.
        :rtype: int
        :return: 
                                   -  0: Success.
                                   - -1: Invalid parameters (``NULL`` pointer).
                                   - -2: There is already an API component registered under the
                                         ID ``uuid``.
        """
        return _pymdlsdk.INeuray_register_api_component(self, uuid, api_component)

    def unregister_api_component(self, uuid):
        r"""
        Unregisters an API component with the MDL SDK API

        The API component will no longer be accessible via #get_api_component().

        :type uuid: :py:class:`Uuid`
        :param uuid:        The ID of the API component to unregister.
        :rtype: int
        :return: 
                               -  0: Success.
                               - -1: There is no API component registered under the ID ``uuid``.
        """
        return _pymdlsdk.INeuray_unregister_api_component(self, uuid)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.INeuray_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.INeuray__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.INeuray__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.INeuray_get_iid(self)

# Register INeuray in _pymdlsdk:
_pymdlsdk.INeuray_swigregister(INeuray)

def INeuray_IID():
    return _pymdlsdk.INeuray_IID()

def INeuray__get_interface(iface):
    return _pymdlsdk.INeuray__get_interface(iface)

class IPlugin_configuration(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IPlugin_configuration_swiginit(self, _pymdlsdk.new_IPlugin_configuration(*args))
    __swig_destroy__ = _pymdlsdk.delete_IPlugin_configuration

    def __deref__(self):
        return _pymdlsdk.IPlugin_configuration___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IPlugin_configuration___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IPlugin_configuration_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IPlugin_configuration___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IPlugin_configuration___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IPlugin_configuration_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IPlugin_configuration_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IPlugin_configuration__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def load_plugin_library(self, path):
        r"""
        Loads a plugin library.

        This function loads the specified shared library, enumerates all plugin classes in the
        specified shared library, and adds them to the system.

        This function can only be called before the MDL SDKhas been started.

        :type path: string
        :param path:     The path of the shared library to be loaded. This shared library needs to be
                            a valid plugin for the MDL SDK.
        :rtype: int
        :return: 0, in case of success, -1 in case of failure.
        """
        return _pymdlsdk.IPlugin_configuration_load_plugin_library(self, path)

    def load_plugins_from_directory(self, path):
        r"""
        Loads all plugins from a given directory.

        Enumerates all plugins in the given directory in alphabetic order and calls
        #load_plugin_library() for each of them in turn. On Windows, all files with the extension
        ``.dll`` are considered, while on Linux and MacOS X all files with the extension ``.so`` are
        considered. Additionally, on MacOS X all files with extension ``.dylib`` are considered.

        :type path: string
        :param path:     The path of the directory.
        :rtype: int
        :return: 0, in case of success, -1 in case of failure.
        """
        return _pymdlsdk.IPlugin_configuration_load_plugins_from_directory(self, path)

    def get_plugin_length(self):
        r"""
        Returns the number of loaded plugins.

        :rtype: int
        :return: The number of loaded plugins.
        """
        return _pymdlsdk.IPlugin_configuration_get_plugin_length(self)

    def get_plugin_descriptor(self, index):
        r"""
        Returns a descriptor for the ``index`` -th loaded plugin.

        :rtype: mi::base::IPlugin_descriptor
        :return: A descriptor for the ``index`` -th loaded plugin, or ``NULL`` in
                            case of failure.
        """
        return _pymdlsdk.IPlugin_configuration_get_plugin_descriptor(self, index)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IPlugin_configuration_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IPlugin_configuration__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IPlugin_configuration__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IPlugin_configuration_get_iid(self)

# Register IPlugin_configuration in _pymdlsdk:
_pymdlsdk.IPlugin_configuration_swigregister(IPlugin_configuration)

def IPlugin_configuration_IID():
    return _pymdlsdk.IPlugin_configuration_IID()

def IPlugin_configuration__get_interface(iface):
    return _pymdlsdk.IPlugin_configuration__get_interface(iface)

class IScene_element(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IScene_element_swiginit(self, _pymdlsdk.new_IScene_element(*args))
    __swig_destroy__ = _pymdlsdk.delete_IScene_element

    def __deref__(self):
        return _pymdlsdk.IScene_element___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IScene_element___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IScene_element_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IScene_element___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IScene_element___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IScene_element_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IScene_element_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IScene_element__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_element_type(self):
        r""" Indicates the actual scene element represented by interfaces derived from this interface."""
        return _pymdlsdk.IScene_element_get_element_type(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IScene_element_compare_iid(self, iid)

    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk.IScene_element_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk.IScene_element_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IScene_element_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IScene_element_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk.IScene_element_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk.IScene_element_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk.IScene_element_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk.IScene_element_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk.IScene_element_enumerate_attributes(self, index)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IScene_element__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IScene_element__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IScene_element_get_iid(self)

# Register IScene_element in _pymdlsdk:
_pymdlsdk.IScene_element_swigregister(IScene_element)

def IScene_element_IID():
    return _pymdlsdk.IScene_element_IID()

def IScene_element__get_interface(iface):
    return _pymdlsdk.IScene_element__get_interface(iface)

class IScope(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IScope_swiginit(self, _pymdlsdk.new_IScope(*args))
    __swig_destroy__ = _pymdlsdk.delete_IScope

    def __deref__(self):
        return _pymdlsdk.IScope___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IScope___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IScope_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IScope___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IScope___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IScope_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IScope_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IScope__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def create_transaction(self):
        r"""
        Creates a new transaction associated with this scope.

        If: DICE_API { DiCE users should treat ``ITransaction`` as an opaque type. Instead, you should
        use #mi::neuraylib::IDice_transaction which is better suited for the needs of DiCE. To
        create such a DiCE transaction call the templated variant
        #mi::neuraylib::IScope::create_transaction<mi::neuraylib::IDice_transaction>(). }

        If: MDL_SDK_API { Notes: The MDL SDK currently supports only one transaction at a time. }

        :rtype: :py:class:`ITransaction`
        :return: A transaction associated with this scope.
        """
        return _pymdlsdk.IScope_create_transaction(self)

    def get_id(self):
        r"""
        Returns the ID of the scope.

        Can be used to retrieve the scope from the database later.

        :rtype: string
        :return: The ID of the scope.
        """
        return _pymdlsdk.IScope_get_id(self)

    def get_privacy_level(self):
        r"""
        Returns the privacy level of the scope.

        The global scope has privacy level 0, all other scopes have higher privacy levels. On each
        path from the global scope to any other scope in the scope tree the privacy levels are
        strictly increasing.

        :rtype: mi::Uint8
        :return: The privacy level of the scope.
        """
        return _pymdlsdk.IScope_get_privacy_level(self)

    def get_name(self):
        r"""
        Returns the name of the scope.

        :rtype: string
        :return: The name of the scope, or ``NULL`` if the scope has no name.
        """
        return _pymdlsdk.IScope_get_name(self)

    def get_parent(self):
        r"""
        Returns the parent scope.

        :rtype: :py:class:`IScope`
        :return: The parent scope or ``NULL`` if the scope is the global scope.
        """
        return _pymdlsdk.IScope_get_parent(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IScope_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IScope__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IScope__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IScope_get_iid(self)

# Register IScope in _pymdlsdk:
_pymdlsdk.IScope_swigregister(IScope)

def IScope_IID():
    return _pymdlsdk.IScope_IID()

def IScope__get_interface(iface):
    return _pymdlsdk.IScope__get_interface(iface)

class ISerialized_function_name(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.ISerialized_function_name_swiginit(self, _pymdlsdk.new_ISerialized_function_name(*args))
    __swig_destroy__ = _pymdlsdk.delete_ISerialized_function_name

    def __deref__(self):
        return _pymdlsdk.ISerialized_function_name___deref__(self)

    def __ref__(self):
        return _pymdlsdk.ISerialized_function_name___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.ISerialized_function_name_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.ISerialized_function_name___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.ISerialized_function_name___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.ISerialized_function_name_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.ISerialized_function_name_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.ISerialized_function_name__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_function_name(self):
        r"""
        Returns the serialized function name.

        Useful for serialization schemes that support only a single string entity.

        Pass to the first overload of
        #mi::neuraylib::IMdl_impexp_api::deserialize_function_name() during deserialization.
        """
        return _pymdlsdk.ISerialized_function_name_get_function_name(self)

    def get_module_name(self):
        r"""
        Returns the serialized module name.

        Useful for serialization schemes that support two string entities.

        Pass to #mi::neuraylib::IMdl_impexp_api::deserialize_module_name() or the second overload
        of #mi::neuraylib::IMdl_impexp_api::deserialize_function_name() during deserialization.
        """
        return _pymdlsdk.ISerialized_function_name_get_module_name(self)

    def get_function_name_without_module_name(self):
        r"""
        Returns the serialized function name (without the module name).

        Useful for serialization schemes that support two string entities.

        Pass to the second overload
        of #mi::neuraylib::IMdl_impexp_api::deserialize_function_name() during deserialization.
        """
        return _pymdlsdk.ISerialized_function_name_get_function_name_without_module_name(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.ISerialized_function_name_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.ISerialized_function_name__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.ISerialized_function_name__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.ISerialized_function_name_get_iid(self)

# Register ISerialized_function_name in _pymdlsdk:
_pymdlsdk.ISerialized_function_name_swigregister(ISerialized_function_name)

def ISerialized_function_name_IID():
    return _pymdlsdk.ISerialized_function_name_IID()

def ISerialized_function_name__get_interface(iface):
    return _pymdlsdk.ISerialized_function_name__get_interface(iface)

class ITransaction(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.ITransaction_swiginit(self, _pymdlsdk.new_ITransaction(*args))
    __swig_destroy__ = _pymdlsdk.delete_ITransaction

    def __deref__(self):
        return _pymdlsdk.ITransaction___deref__(self)

    def __ref__(self):
        return _pymdlsdk.ITransaction___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.ITransaction_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.ITransaction___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.ITransaction___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.ITransaction_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.ITransaction_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.ITransaction__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def access(self, *args):
        return  self._access(*args)

    def access_as(self, type, *args):
        iinterface = self._access(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def edit(self, *args):
        return  self._edit(*args)

    def edit_as(self, type, *args):
        iinterface = self._edit(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def commit(self):
        r"""
        Commits the transaction.

        Note that a commit() implicitly closes the transaction.
        A closed transaction does not allow any future operations and needs to be released.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Unspecified failure.
                                - -3: The transaction is not open.
        """
        return _pymdlsdk.ITransaction_commit(self)

    def abort(self):
        r"""
        If not: MDL_SDK_API {
        Aborts the transaction.

        Note that an abort() implicitly closes the transaction.
        A closed transaction does not allow any future operations and needs to be released.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk.ITransaction_abort(self)

    def is_open(self):
        r"""
        Indicates whether the transaction is open.

        :rtype: boolean
        :return: ``true`` if the transaction is still open, or ``false`` if the transaction is
                      closed, i.e., it has been committed or aborted.
        """
        return _pymdlsdk.ITransaction_is_open(self)

    def create(self, type_name, argc=0, argv=0):
        r"""
        Creates an object of the type ``type_name``.

        Objects created with this method are typically If: IRAY_API { 'mi_neuray_types',
        'mi_neuray_scene_element' and 'mi_neuray_functors'. It is also possible to create
        instances of user-defined classes. }Else:  { and
        'mi_neuray_scene_element'. } Note that most types can also be created via the API
        component #mi::neuraylib::IFactory which does not require the context of a transaction.

        This method can not be used to create MDL modules, definitions, or function calls. To
        create instances of #mi::neuraylib::IFunction_call, use the method
        #mi::neuraylib::IFunction_definition::create_function_call().

        The created object will be initialized in a manner dependent upon the passed type
        name. Each class has its own policy on initialization. So, one should not make any
        assumptions on the values of the various class members.

        :type type_name: string
        :param type_name:    The type name of the object to create. See 'mi_neuray_types' for
                                possible type names. In addition, 'mi_neuray_scene_element'
                            If: IRAY_API { and 'mi_neuray_functors' } can be created by
                            passing the name of the requested interfaces without namespace
                            qualifiers and the leading ``"I"``, e.g., ``"Image"`` for
                            #mi::neuraylib::IImage. If: IRAY_API { Names of user-defined classes are
                            also valid arguments. } Note that you can not create instances of
                            #mi::neuraylib::IAttribute_set or #mi::neuraylib::IScene_element, only
                            instances of the derived interfaces If: IRAY_API { (see also
                            #mi::neuraylib::IAttribute_container) } .
        :type argc: int, optional
        :param argc:         The number of elements in ``argv``. Passed to the constructor of factory
                                of the object to create.
        :type argv: mi::base::IInterface, optional
        :param argv:         The array of arguments passed to the constructor. Passed to the
                                constructor of factory of the object to create.
        :rtype: mi::base::IInterface
        :return: A pointer to the created object, or ``NULL`` if ``type_name`` is invalid
                                (``NULL`` pointer) or not a valid type name.
        """
        return _pymdlsdk.ITransaction_create(self, type_name, argc, argv)
    LOCAL_SCOPE = property(_pymdlsdk.ITransaction_LOCAL_SCOPE_get, doc=r"""
    Symbolic privacy level for the privacy level of the scope of this transaction.

    This symbolic constant can be passed to #store() and #copy() to indicate the privacy level
    of the scope of this transaction. It has the same affect as passing the result of
    #mi::neuraylib::IScope::get_privacy_level(), but is more convenient.
    """)

    def store(self, *args):
        r"""
        Stores the element ``db_element`` in the database under the name ``name`` and with the privacy
        level ``privacy``.

        After a successful store operation the passed interface pointer must no longer be used,
        except for releasing it. This is due to the fact that after a #store() the database
        retains ownership of the stored data. You can obtain the stored version from the database
        using the #access() or #edit() methods.

        Notes: **Overwriting vs editing of existing DB elements**

              While it is possible to overwrite existing DB elements, for performance reasons it is
              often better to edit the already existing DB element instead. Editing a DB element
              allows the DB to keep track of the type of changes which might help render modes to
              update their data structures more efficiently. When overwriting an existing DB element
              such information is not available and pessimistic assumptions have to be made which
              may result in lower performance.

        :type db_element: mi::base::IInterface
        :param db_element: The #mi::base::IInterface to store.
        :type name: string
        :param name:       The name under which to store ``db_element``. If there exists already a DB
                              element with that name then it will be overwritten If: IRAY_API { (but see
                          also return code -9 below) } .
        :type privacy: mi::Uint8, optional
        :param privacy:    The privacy level under which to store ``db_element`` (in the range from 0
                              to the privacy level of the scope of this transaction). In addition, the
                              constant #LOCAL_SCOPE can be used as a shortcut to indicate the privacy
                              level of the scope of this transaction without supplying the actual value
                              itself.
        :rtype: int
        :return: 
                   -  0: Success.
                   - -1: Unspecified failure.
                   - -2: Invalid parameters (``NULL`` pointer).
                   - -3: The transaction is not open.
                   - -4: ``db_element`` is not a DB element.
                   - -5: Invalid privacy level.
                   - -6: ``db_element`` has already been stored previously.
                   - -7: The element is to be stored in a transaction different from the one that was
                         used to create it.
                   - -8: The element is a user-defined class that has not been If: IRAY_API {
                     registered (see #mi::neuraylib::IExtension_api::register_class()). }Else:  {              registered. }

               - -9: There is already an element of name ``name`` and overwriting elements of that
                     type is not supported. This applies to elements of type
                     #mi::neuraylib::IModule, #mi::neuraylib::IMaterial_definition, and
                     #mi::neuraylib::IFunction_definition.
                     It also applies to elements of type #mi::neuraylib::IFunction_call
                     and #mi::neuraylib::IMaterial_instance that are used as defaults
                     in an #mi::neuraylib::IMaterial_definition or
                     #mi::neuraylib::IFunction_definition.
        """
        return _pymdlsdk.ITransaction_store(self, *args)

    def _access(self, name):
        r"""
        Retrieves an element from the database.

        The database searches for the most recent version of the named DB element visible for the
        current transaction. That version will be returned.

        :type name: string
        :param name:   The name of the element to retrieve.
        :rtype: mi::base::IInterface
        :return: The requested element from the database, or ``NULL`` if ``name`` is invalid, no
                          DB element with that name exists, or the transaction is already closed.
        """
        return _pymdlsdk.ITransaction__access(self, name)

    def _edit(self, name):
        r"""
        Retrieves an element from the database and returns it ready for editing.

        The database searches for the most recent version of the named DB element visible for the
        current transaction. It will then make a copy of that version and return the copy. The
        edited DB element will be committed to the database automatically, when the obtained
        interface is released. It is neither necessary nor possible to store the edited element
        manually in the database using the #store() method.

        :type name: string
        :param name:   The name of the element to retrieve.
        :rtype: mi::base::IInterface
        :return: The requested element from the database, or ``NULL`` if ``name`` is invalid, no
                          DB element with that name exists, or the transaction is already closed.
        """
        return _pymdlsdk.ITransaction__edit(self, name)

    def copy(self, source, target, privacy=0):
        r"""
        Creates a copy of a database element.

        Note that DB elements of type #mi::neuraylib::IModule, #mi::neuraylib::IMaterial_definition,
        and #mi::neuraylib::IFunction_definition can not be copied.

        :type source: string
        :param source:    The name of the element to be copied.
        :type target: string
        :param target:    The desired name of the copy.
        :type privacy: mi::Uint8, optional
        :param privacy:   The desired privacy level of the copy (in the range from
                             0 to the privacy level of the scope of this transaction). In addition, the
                             constant #LOCAL_SCOPE can be used as a shortcut to indicate the privacy
                             level of the scope of this transaction without supplying the actual value
                             itself.
        :rtype: int
        :return: 
                             -  0: Success.
                             - -2: Invalid parameters (``NULL`` pointer).
                             - -3: The transaction is not open.
                             - -4: There is no DB element named ``source`` visible in this transaction.
                             - -5: Invalid privacy level.
                             - -6: DB elements of this type cannot be copied.
                             - -9: There is already an element of name ``name`` and overwriting elements
                                   of that type is not supported. This applies to elements of type
                                   #mi::neuraylib::IModule, #mi::neuraylib::IMaterial_definition, and
                                   #mi::neuraylib::IFunction_definition.
                                   It also applies to elements of type #mi::neuraylib::IFunction_call
                                   and #mi::neuraylib::IMaterial_instance that are used as defaults
                                   in an #mi::neuraylib::IMaterial_definition or
                                   #mi::neuraylib::IFunction_definition.
        """
        return _pymdlsdk.ITransaction_copy(self, source, target, privacy)

    def remove(self, name, only_localized=False):
        r"""
        Removes the element with the name ``name`` from the database.

        Note that the element continues to be stored in the database as long as it is referenced by
        other elements. If it is no longer referenced, and the last transaction were it was
        referenced has been committed, it will be lazily removed by the garbage collection of the
        DB. There is no guarantee when this will happen.

        This implies that a #remove() call might actually remove an element that was stored later
        under the same name. This can potentially lead to invalid tag accesses. Those cases can be
        avoided by using #mi::neuraylib::IDatabase::garbage_collection() after a transaction was
        committed and before starting the next one to force garbage collection of all possible
        elements.

        If: IRAY_API {
        See also 'mi_neuray_database_reuse_of_names' for more details and correct usage patterns.
        }

        :type name: string
        :param name:           The name of the element in the database to remove.
        :type only_localized: boolean, optional
        :param only_localized: If: MDL_SDK_API { Unused. }Else: If  {``true``, the element is only removed
                              if it exists in the scope of the transaction; parent scopes are not
                              considered. }
        :rtype: int
        :return: 
                                  -  0: Success.
                                  - -1: There is no DB element named ``name`` visible in this
                                        transaction (``only_localize`` is ``false)`` or there is no
                                        DB element named ``name`` in the scope of this transaction
                                        (``only_localized`` is ``true)``.
                                  - -2: Invalid parameters (``NULL`` pointer).
                                  - -3: The transaction is not open.
        """
        return _pymdlsdk.ITransaction_remove(self, name, only_localized)

    def name_of(self, db_element):
        r"""
        Returns the name of a database element.

        :type db_element: mi::base::IInterface
        :param db_element:   The DB element.
        :rtype: string
        :return: The name of the DB element, or ``NULL`` if ``db_element`` is invalid
                                (``NULL`` pointer), the object is not in the database, or the
                                transaction is already closed.
        """
        return _pymdlsdk.ITransaction_name_of(self, db_element)

    def get_time_stamp(self, *args):
        r"""
        *Overload 1:*
        Returns the time stamp describing the current "time".

        Notes: The time stamp is not related to time in the classical meaning. It rather relates to
              the current transaction and the number of database changes since the start of the
              transaction.

        The time stamp is only meaningful for the current MDL SDKinstance. It
              should not be put into external storage and re-used for different or later
              MDL SDKinstances.

        The return value of this method is only valid until the next call of this method
              (or one of its overloads) on this instance.

        See also: has_changed_since_time_stamp(), #get_time_stamp(const char*)const

        |

        *Overload 2:*
        Returns the time stamp of the last change of a database element.

        Notes: The time stamp is not related to time in the classical meaning. It rather relates to
              the transaction and the number of database changes since the start of the transaction
              when the database element was changed last.

        The time stamp is only meaningful for the current MDL SDKinstance. It
              should not be put into external storage and re-used for different or later
              MDL SDKinstances.

        The return value of this method is only valid until the next call of this method
              (or one of its overloads) on this instance.

        See also: has_changed_since_time_stamp(), #get_time_stamp()
        """
        return _pymdlsdk.ITransaction_get_time_stamp(self, *args)

    def has_changed_since_time_stamp(self, element, time_stamp):
        r"""
        Checks whether an element has been stored or changed in the database since a given time
        stamp.

        Notes: ``time_stamp`` should not stem from another concurrent transaction. Such changes will
              never be visible in this transaction, but the method might still return ``true``
              depending on the start order of the two transactions.

        In case of multiple overlapping transactions the returned answer may not list
              all changes due to the isolation of the transactions. If accurate results are
              required, transactions changing elements should be committed before transactions
              querying the journal for such changes are started.

        See also: #get_time_stamp(), #get_time_stamp(const char*)const

        :type element: string
        :param element:     The name of the element.
        :type time_stamp: string
        :param time_stamp:  The time stamp obtained from #get_time_stamp() or
                               #get_time_stamp(const char*)const.
        :rtype: boolean
        :return: ``true`` if the element has been stored or changed since the time stamp
                               (or if ``element`` or ``time_stamp`` is invalid, or there is no element
                               with that name), ``false`` otherwise.
        """
        return _pymdlsdk.ITransaction_has_changed_since_time_stamp(self, element, time_stamp)

    def get_id(self):
        r"""
        Returns the ID of this transaction.

        The transaction ID is of most use when debugging an application as the value returned allows
        one to correlate log messages and admin HTTP server output with the API actions.

        :rtype: string
        :return: The ID of the transaction.
        """
        return _pymdlsdk.ITransaction_get_id(self)

    def get_scope(self):
        r""" Returns the scope of this transaction."""
        return _pymdlsdk.ITransaction_get_scope(self)

    def list_elements(self, root_element, name_pattern=None, type_names=None):
        r"""
        Returns scene elements of a subgraph originating at a given scene element.

        The method iterates over all elements of a subgraph originating at the given scene element
        and returns their names. Optionally, the results can be filtered by a regular expression
        for the element names and a list for type names.

        Note that the runtime of the method depends on the number of elements in the subgraph. It
        might be expensive to call this method for large subgraphs.

        The returned scene elements are in such an order that all elements referenced by a given
        element are listed before that element ("before" in the sense of "using smaller array
        indices").

        :type root_element: string
        :param root_element:   The root of the subgraph to traverse.
        :type name_pattern: string, optional
        :param name_pattern:   An extended regular expression that acts as filter on the names of
                                  returned scene elements (see ['OGBS7])'. The regular expression
                                  is matched to *any* *part* of the scene element name, not just to
                                  the *entire* scene element name. The value ``NULL`` is handled as
                                  ``".*"``.
        :type type_names: :py:class:`IArray`, optional
        :param type_names:     A list of type names that acts as filter on the names of returned
                                  scene elements. Only scene elements with a matching type name pass
                                  the filter. The value ``NULL`` lets all scene elements pass the filter
                                  irrespective of their type name.
        :rtype: :py:class:`IArray`
        :return: A list of name of scene elements in the subgraph matching the given
                                  regular expression and type name filter, or ``NULL`` in case of
                                  an invalid root element name or an invalid regular expression.
        """
        return _pymdlsdk.ITransaction_list_elements(self, root_element, name_pattern, type_names)

    def get_privacy_level(self, name):
        r"""
        Returns the privacy level of the element with the name ``name``.

        :type name: string
        :param name:          The name of the element.
        :rtype: int
        :return: 
                                 - >= 0: Success. The privacy level of the element (in the range 0-255).
                                 -   -2: Invalid parameters (``NULL`` pointer).
                                 -   -3: The transaction is not open.
                                 -   -4: There is no DB element named ``name`` visible in this
                                         transaction.
        """
        return _pymdlsdk.ITransaction_get_privacy_level(self, name)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.ITransaction_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.ITransaction__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.ITransaction__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.ITransaction_get_iid(self)

# Register ITransaction in _pymdlsdk:
_pymdlsdk.ITransaction_swigregister(ITransaction)

def ITransaction_IID():
    return _pymdlsdk.ITransaction_IID()

def ITransaction__get_interface(iface):
    return _pymdlsdk.ITransaction__get_interface(iface)

class IAnnotation(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IAnnotation_swiginit(self, _pymdlsdk.new_IAnnotation(*args))
    __swig_destroy__ = _pymdlsdk.delete_IAnnotation

    def __deref__(self):
        return _pymdlsdk.IAnnotation___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IAnnotation___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IAnnotation_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IAnnotation___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IAnnotation___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IAnnotation_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IAnnotation_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IAnnotation__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_name(self):
        r""" Returns the name of the annotation."""
        return _pymdlsdk.IAnnotation_get_name(self)

    def set_name(self, name):
        r""" Sets the name of the annotation."""
        return _pymdlsdk.IAnnotation_set_name(self, name)

    def get_arguments(self):
        r"""
        Returns the arguments of the annotation.

        The arguments of annotations are always constant expressions.
        """
        return _pymdlsdk.IAnnotation_get_arguments(self)

    def get_definition(self):
        r""" Returns the definition of this annotation."""
        return _pymdlsdk.IAnnotation_get_definition(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IAnnotation_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IAnnotation__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IAnnotation__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IAnnotation_get_iid(self)

# Register IAnnotation in _pymdlsdk:
_pymdlsdk.IAnnotation_swigregister(IAnnotation)

def IAnnotation_IID():
    return _pymdlsdk.IAnnotation_IID()

def IAnnotation__get_interface(iface):
    return _pymdlsdk.IAnnotation__get_interface(iface)

class IAnnotation_block(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IAnnotation_block_swiginit(self, _pymdlsdk.new_IAnnotation_block(*args))
    __swig_destroy__ = _pymdlsdk.delete_IAnnotation_block

    def __deref__(self):
        return _pymdlsdk.IAnnotation_block___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IAnnotation_block___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IAnnotation_block_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IAnnotation_block___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IAnnotation_block___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IAnnotation_block_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IAnnotation_block_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IAnnotation_block__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_size(self):
        r""" Returns the number of annotations in this block."""
        return _pymdlsdk.IAnnotation_block_get_size(self)

    def get_annotation(self, index):
        r""" Returns the annotation for ``index``, or ``NULL`` if index is out of bounds."""
        return _pymdlsdk.IAnnotation_block_get_annotation(self, index)

    def set_annotation(self, index, annotation):
        r"""
        Sets an annotation block at a given index.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: ``index`` is out of bounds.
        """
        return _pymdlsdk.IAnnotation_block_set_annotation(self, index, annotation)

    def add_annotation(self, annotation):
        r"""
        Adds an annotation at the end of the annotation block.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
        """
        return _pymdlsdk.IAnnotation_block_add_annotation(self, annotation)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IAnnotation_block_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IAnnotation_block__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IAnnotation_block__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IAnnotation_block_get_iid(self)

# Register IAnnotation_block in _pymdlsdk:
_pymdlsdk.IAnnotation_block_swigregister(IAnnotation_block)

def IAnnotation_block_IID():
    return _pymdlsdk.IAnnotation_block_IID()

def IAnnotation_block__get_interface(iface):
    return _pymdlsdk.IAnnotation_block__get_interface(iface)

class IAnnotation_definition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IAnnotation_definition_swiginit(self, _pymdlsdk.new_IAnnotation_definition(*args))
    __swig_destroy__ = _pymdlsdk.delete_IAnnotation_definition

    def __deref__(self):
        return _pymdlsdk.IAnnotation_definition___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IAnnotation_definition___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IAnnotation_definition_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IAnnotation_definition___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IAnnotation_definition___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IAnnotation_definition_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IAnnotation_definition_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IAnnotation_definition__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_module(self):
        r"""
        Returns the DB name of the module containing this annotation definition.

        The type of the module is #mi::neuraylib::IModule.
        """
        return _pymdlsdk.IAnnotation_definition_get_module(self)

    def get_name(self):
        r""" Returns the MDL name of the annotation definition."""
        return _pymdlsdk.IAnnotation_definition_get_name(self)

    def get_mdl_module_name(self):
        r""" Returns the MDL name of the module containing this annotation definition."""
        return _pymdlsdk.IAnnotation_definition_get_mdl_module_name(self)

    def get_mdl_simple_name(self):
        r"""
        Returns the simple MDL name of the annotation definition.

        The simple name is the last component of the MDL name, i.e., without any packages and
        scope qualifiers, and without the parameter type names.

        :rtype: string
        :return: The simple MDL name of the annotation definition.
        """
        return _pymdlsdk.IAnnotation_definition_get_mdl_simple_name(self)

    def get_mdl_parameter_type_name(self, index):
        r"""
        Returns the type name of the parameter at ``index``.

        Notes: The type names provided here are substrings of the MDL name returned by #get_name().
              They are provided here such that parsing of the MDL name is not necessary. However,
              for most use cases it is strongly recommended to use #get_parameter_types() instead.

        :type index: int
        :param index:    The index of the parameter.
        :rtype: string
        :return: The type name of the parameter, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk.IAnnotation_definition_get_mdl_parameter_type_name(self, index)

    def get_semantic(self):
        r""" Returns the semantic of this annotation definition."""
        return _pymdlsdk.IAnnotation_definition_get_semantic(self)

    def is_exported(self):
        r""" Indicates whether the annotation definition is exported by its module."""
        return _pymdlsdk.IAnnotation_definition_is_exported(self)

    def get_mdl_version(self, since, removed):
        r"""
        Returns the MDL version when this annotation definition was added and removed.

        :type since: int, out
        :param since:     The MDL version in which this annotation definition was added. If the
                                  annotation definition does not belong to the standard library, the
                                  MDL version of the corresponding module is returned.
        :type removed: int, out
        :param removed:   The MDL version in which this annotation definition was removed, or
                                  mi::neuraylib::MDL_VERSION_INVALID if the annotation has not been
                                  removed so far or does not belong to the standard library.
        """
        return _pymdlsdk.IAnnotation_definition_get_mdl_version(self, since, removed)

    def get_parameter_count(self):
        r""" Returns the parameter count of the annotation definition."""
        return _pymdlsdk.IAnnotation_definition_get_parameter_count(self)

    def get_parameter_name(self, index):
        r"""
        Returns the parameter name of the given index.

        :type index: int
        :param index:    The parameter index.
        :rtype: string
        :return: The name of the parameter or ``NULL`` if index
                            is out of range.
        """
        return _pymdlsdk.IAnnotation_definition_get_parameter_name(self, index)

    def get_parameter_index(self, name):
        r"""
        Returns the parameter index of the given name.

        :type name: string
        :param name:     The parameter name.
        :rtype: int
        :return: The index of the parameter or ``-1`` if there is no
                            parameter of that ``name``.
        """
        return _pymdlsdk.IAnnotation_definition_get_parameter_index(self, name)

    def get_parameter_types(self):
        r""" Returns the parameter types of the annotation definition."""
        return _pymdlsdk.IAnnotation_definition_get_parameter_types(self)

    def get_defaults(self):
        r""" Returns the parameter defaults of the annotation definition."""
        return _pymdlsdk.IAnnotation_definition_get_defaults(self)

    def get_annotations(self):
        r"""
        Returns the annotations of this definition or ``NULL`` if no
        annotations exist.
        """
        return _pymdlsdk.IAnnotation_definition_get_annotations(self)

    def create_annotation(self, arguments):
        r"""
        Creates an annotation.

        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments for new annotation.
        :rtype: :py:class:`IAnnotation`
        :return: The created annotation or ``NULL`` if one of the arguments
                                does not correspond to an actual parameter of the annotation or
                                is not a constant expression.
        """
        return _pymdlsdk.IAnnotation_definition_create_annotation(self, arguments)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IAnnotation_definition_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IAnnotation_definition__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IAnnotation_definition__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IAnnotation_definition_get_iid(self)

# Register IAnnotation_definition in _pymdlsdk:
_pymdlsdk.IAnnotation_definition_swigregister(IAnnotation_definition)

def IAnnotation_definition_IID():
    return _pymdlsdk.IAnnotation_definition_IID()

def IAnnotation_definition__get_interface(iface):
    return _pymdlsdk.IAnnotation_definition__get_interface(iface)

class IAnnotation_list(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IAnnotation_list_swiginit(self, _pymdlsdk.new_IAnnotation_list(*args))
    __swig_destroy__ = _pymdlsdk.delete_IAnnotation_list

    def __deref__(self):
        return _pymdlsdk.IAnnotation_list___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IAnnotation_list___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IAnnotation_list_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IAnnotation_list___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IAnnotation_list___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IAnnotation_list_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IAnnotation_list_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IAnnotation_list__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_size(self):
        r""" Returns the number of elements."""
        return _pymdlsdk.IAnnotation_list_get_size(self)

    def get_index(self, name):
        r""" Returns the index for the given name, or -1 if there is no such block."""
        return _pymdlsdk.IAnnotation_list_get_index(self, name)

    def get_name(self, index):
        r""" Returns the name for the given index, or ``NULL`` if there is no such block."""
        return _pymdlsdk.IAnnotation_list_get_name(self, index)

    def get_annotation_block(self, *args):
        r"""
        *Overload 1:*
        Returns the annotation block for ``index``, or ``NULL`` if there is no such block.

        |

        *Overload 2:*
        Returns the annotation block for ``name``, or ``NULL`` if there is no such block.
        """
        return _pymdlsdk.IAnnotation_list_get_annotation_block(self, *args)

    def set_annotation_block(self, *args):
        r"""
        *Overload 1:*
        Sets an annotation block at a given index.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: ``index`` is out of bounds.

        |

        *Overload 2:*
        Sets an annotation block identified by name.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is no annotation block mapped to ``name`` in the list.
        """
        return _pymdlsdk.IAnnotation_list_set_annotation_block(self, *args)

    def add_annotation_block(self, name, block):
        r"""
        Adds an annotation block at the end of the list.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is already an annotation block mapped to ``name`` in the list.
        """
        return _pymdlsdk.IAnnotation_list_add_annotation_block(self, name, block)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IAnnotation_list_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IAnnotation_list__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IAnnotation_list__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IAnnotation_list_get_iid(self)

# Register IAnnotation_list in _pymdlsdk:
_pymdlsdk.IAnnotation_list_swigregister(IAnnotation_list)

def IAnnotation_list_IID():
    return _pymdlsdk.IAnnotation_list_IID()

def IAnnotation_list__get_interface(iface):
    return _pymdlsdk.IAnnotation_list__get_interface(iface)

class IExpression(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IExpression_swiginit(self, _pymdlsdk.new_IExpression(*args))
    __swig_destroy__ = _pymdlsdk.delete_IExpression

    def __deref__(self):
        return _pymdlsdk.IExpression___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IExpression___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IExpression_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IExpression___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IExpression___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IExpression_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IExpression_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IExpression__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    class Kind(Enum) :
        EK_CONSTANT = _pymdlsdk._IExpression_EK_CONSTANT
        EK_CALL = _pymdlsdk._IExpression_EK_CALL
        EK_PARAMETER = _pymdlsdk._IExpression_EK_PARAMETER
        EK_DIRECT_CALL = _pymdlsdk._IExpression_EK_DIRECT_CALL
        EK_TEMPORARY = _pymdlsdk._IExpression_EK_TEMPORARY


    def get_kind(self, *args):
        return IExpression.Kind(self._get_kind(*args))


    def get_type(self, *args):
        return  self._get_type(*args)

    def get_type_as(self, type, *args):
        iinterface = self._get_type(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def _get_kind(self):
        r""" Returns the kind of this expression."""
        return _pymdlsdk.IExpression__get_kind(self)

    def _get_type(self):
        r""" Returns the type of this expression."""
        return _pymdlsdk.IExpression__get_type(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IExpression_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IExpression__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IExpression__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IExpression_get_iid(self)

# Register IExpression in _pymdlsdk:
_pymdlsdk.IExpression_swigregister(IExpression)

def IExpression_IID():
    return _pymdlsdk.IExpression_IID()

def IExpression__get_interface(iface):
    return _pymdlsdk.IExpression__get_interface(iface)

class IExpression_call(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IExpression_call_swiginit(self, _pymdlsdk.new_IExpression_call(*args))
    __swig_destroy__ = _pymdlsdk.delete_IExpression_call

    def __deref__(self):
        return _pymdlsdk.IExpression_call___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IExpression_call___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IExpression_call_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IExpression_call___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IExpression_call___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IExpression_call_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IExpression_call_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IExpression_call__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IExpression.Kind(self._get_kind(*args))


    def get_type(self, *args):
        return  self._get_type(*args)

    def get_type_as(self, type, *args):
        iinterface = self._get_type(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_call(self):
        r""" Returns the DB name of the referenced function call or material instance."""
        return _pymdlsdk.IExpression_call_get_call(self)

    def set_call(self, name):
        r"""
        Sets the name of the referenced function call or material instance.

        :type name: string
        :param name:    The DB name of the function call or material instance.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: There is no DB element with that name.
                           - -3: The DB element has not the correct type.
                           - -4: The return type of the DB element does not match the type of this
                                 expression.
                           - -5: The material instance or function call referenced by "name" is
                                 a parameter default and therefore cannot be used in a call.
                           - -6: The material instance or function call referenced by "name" is
                                 invalid and therefore cannot be used in a call.
        """
        return _pymdlsdk.IExpression_call_set_call(self, name)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IExpression_call_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of this expression."""
        return _pymdlsdk.IExpression_call__get_kind(self)

    def _get_type(self):
        r""" Returns the type of this expression."""
        return _pymdlsdk.IExpression_call__get_type(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IExpression_call__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IExpression_call__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IExpression_call_get_iid(self)

# Register IExpression_call in _pymdlsdk:
_pymdlsdk.IExpression_call_swigregister(IExpression_call)

def IExpression_call_IID():
    return _pymdlsdk.IExpression_call_IID()

def IExpression_call__get_interface(iface):
    return _pymdlsdk.IExpression_call__get_interface(iface)

class IExpression_constant(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IExpression_constant_swiginit(self, _pymdlsdk.new_IExpression_constant(*args))
    __swig_destroy__ = _pymdlsdk.delete_IExpression_constant

    def __deref__(self):
        return _pymdlsdk.IExpression_constant___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IExpression_constant___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IExpression_constant_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IExpression_constant___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IExpression_constant___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IExpression_constant_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IExpression_constant_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IExpression_constant__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IExpression.Kind(self._get_kind(*args))


    def get_type(self, *args):
        return  self._get_type(*args)

    def get_type_as(self, type, *args):
        iinterface = self._get_type(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_value(self, *args):
        return  self._get_value(*args)

    def get_value_as(self, type, *args):
        iinterface = self._get_value(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value of the constant.

        |

        *Overload 2:*
        Returns the value of the constant.
        """
        return _pymdlsdk.IExpression_constant__get_value(self, *args)

    def set_value(self, value):
        r"""
        Sets the value of the constant.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: The type of ``value`` does not match the type of the constant.
        """
        return _pymdlsdk.IExpression_constant_set_value(self, value)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IExpression_constant_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of this expression."""
        return _pymdlsdk.IExpression_constant__get_kind(self)

    def _get_type(self):
        r""" Returns the type of this expression."""
        return _pymdlsdk.IExpression_constant__get_type(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IExpression_constant__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IExpression_constant__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IExpression_constant_get_iid(self)

# Register IExpression_constant in _pymdlsdk:
_pymdlsdk.IExpression_constant_swigregister(IExpression_constant)

def IExpression_constant_IID():
    return _pymdlsdk.IExpression_constant_IID()

def IExpression_constant__get_interface(iface):
    return _pymdlsdk.IExpression_constant__get_interface(iface)

class IExpression_direct_call(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IExpression_direct_call_swiginit(self, _pymdlsdk.new_IExpression_direct_call(*args))
    __swig_destroy__ = _pymdlsdk.delete_IExpression_direct_call

    def __deref__(self):
        return _pymdlsdk.IExpression_direct_call___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IExpression_direct_call___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IExpression_direct_call_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IExpression_direct_call___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IExpression_direct_call___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IExpression_direct_call_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IExpression_direct_call_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IExpression_direct_call__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IExpression.Kind(self._get_kind(*args))


    def get_type(self, *args):
        return  self._get_type(*args)

    def get_type_as(self, type, *args):
        iinterface = self._get_type(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_definition(self):
        r""" Returns the DB name of the corresponding function or material definition."""
        return _pymdlsdk.IExpression_direct_call_get_definition(self)

    def get_arguments(self):
        r""" Returns the arguments of the direct call."""
        return _pymdlsdk.IExpression_direct_call_get_arguments(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IExpression_direct_call_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of this expression."""
        return _pymdlsdk.IExpression_direct_call__get_kind(self)

    def _get_type(self):
        r""" Returns the type of this expression."""
        return _pymdlsdk.IExpression_direct_call__get_type(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IExpression_direct_call__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IExpression_direct_call__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IExpression_direct_call_get_iid(self)

# Register IExpression_direct_call in _pymdlsdk:
_pymdlsdk.IExpression_direct_call_swigregister(IExpression_direct_call)

def IExpression_direct_call_IID():
    return _pymdlsdk.IExpression_direct_call_IID()

def IExpression_direct_call__get_interface(iface):
    return _pymdlsdk.IExpression_direct_call__get_interface(iface)

class IExpression_factory(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IExpression_factory_swiginit(self, _pymdlsdk.new_IExpression_factory(*args))
    __swig_destroy__ = _pymdlsdk.delete_IExpression_factory

    def __deref__(self):
        return _pymdlsdk.IExpression_factory___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IExpression_factory___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IExpression_factory_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IExpression_factory___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IExpression_factory___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IExpression_factory_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IExpression_factory_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IExpression_factory__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_value_factory(self):
        r""" Returns the value factory associated with this expression factory."""
        return _pymdlsdk.IExpression_factory_get_value_factory(self)

    def create_constant(self, value):
        r"""
        Creates a constant (const).

        :type value: :py:class:`IValue`
        :param value:        The value of the constant.
        :rtype: :py:class:`IExpression_constant`
        :return: The created constant.
        """
        return _pymdlsdk.IExpression_factory_create_constant(self, value)

    def create_call(self, name):
        r"""
        Creates a call.

        :type name: string
        :param name:         The DB name of the referenced function call or material instance.
        :rtype: :py:class:`IExpression_call`
        :return: The created call, or ``NULL`` in case of errors.
        """
        return _pymdlsdk.IExpression_factory_create_call(self, name)

    def create_parameter(self, type, index):
        r"""
        Creates a parameter reference.

        :type type: :py:class:`IType`
        :param type:         The type of the parameter.
        :type index: int
        :param index:        The index of the parameter.
        :rtype: :py:class:`IExpression_parameter`
        :return: The created parameter reference, or ``NULL`` in case of errors.
        """
        return _pymdlsdk.IExpression_factory_create_parameter(self, type, index)

    def create_direct_call_with_ret(self, name, arguments):
        r"""
        Creates a direct call.

        :type name: string
        :param name:         The DB name of the referenced function or material definition.
        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments of the created direct call.

                                Arguments for parameters without default are mandatory, otherwise
                                optional. The type of an argument must match the corresponding parameter
                                type. Any argument missing in ``arguments`` will be set to the default of
                                the corresponding parameter.

                                Note that the expressions in ``arguments`` are copied. Valid
                                subexpressions are constants, direct calls, and parameter references.
                                operation is a deep copy, e.g., DB elements referenced in call
                                expressions are also copied.

                                ``NULL`` is a valid argument which is handled like an empty expression
                                list.
        :type errors: int, out, optional
        :param errors:  An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                -  0: Success.
                                - -1: An argument for a non-existing parameter was provided in
                                      ``arguments``.
                                - -2: The type of an argument in ``arguments`` does not have the correct
                                      type.
                                - -3: A parameter that has no default was not provided with an argument
                                      value.
                                - -4: The function or material definition can not be instantiated
                                      because it is not exported.
                                - -5: A parameter type is uniform, but the corresponding argument has a
                                      varying return type.
                                - -6: An argument expression is not a constant, a direct call, nor a
                                      parameter.
                                - -7: Invalid parameters (``NULL`` pointer) or ``name`` is not a valid
                                      DB name of a function or material definition.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument or default is a call expression and the return type of
                                      the called function or material definition is effectively varying
                                      since the function or material definition itself is varying.
                                - -9: The function or material definition is invalid due to a module
                                      reload.
        :rtype: :py:class:`IExpression_direct_call`
        :return: The created call, or ``NULL`` in case of errors.
        """
        return _pymdlsdk.IExpression_factory_create_direct_call_with_ret(self, name, arguments)

    def create_direct_call(self, name, arguments):
        r"""
        Creates a direct call.

        :type name: string
        :param name:         The DB name of the referenced function or material definition.
        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments of the created direct call.

                                Arguments for parameters without default are mandatory, otherwise
                                optional. The type of an argument must match the corresponding parameter
                                type. Any argument missing in ``arguments`` will be set to the default of
                                the corresponding parameter.

                                Note that the expressions in ``arguments`` are copied. Valid
                                subexpressions are constants, direct calls, and parameter references.
                                operation is a deep copy, e.g., DB elements referenced in call
                                expressions are also copied.

                                ``NULL`` is a valid argument which is handled like an empty expression
                                list.
        :param errors:  An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                -  0: Success.
                                - -1: An argument for a non-existing parameter was provided in
                                      ``arguments``.
                                - -2: The type of an argument in ``arguments`` does not have the correct
                                      type.
                                - -3: A parameter that has no default was not provided with an argument
                                      value.
                                - -4: The function or material definition can not be instantiated
                                      because it is not exported.
                                - -5: A parameter type is uniform, but the corresponding argument has a
                                      varying return type.
                                - -6: An argument expression is not a constant, a direct call, nor a
                                      parameter.
                                - -7: Invalid parameters (``NULL`` pointer) or ``name`` is not a valid
                                      DB name of a function or material definition.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument or default is a call expression and the return type of
                                      the called function or material definition is effectively varying
                                      since the function or material definition itself is varying.
                                - -9: The function or material definition is invalid due to a module
                                      reload.
        :rtype: :py:class:`IExpression_direct_call`
        :return: The created call, or ``NULL`` in case of errors.
        """
        return _pymdlsdk.IExpression_factory_create_direct_call(self, name, arguments)

    def create_expression_list(self):
        r""" Creates a new expression list."""
        return _pymdlsdk.IExpression_factory_create_expression_list(self)

    def create_annotation(self, name, arguments):
        r"""
        Creates a new annotation.

        Returns ``NULL`` if one of the arguments is not a constant expression.
        """
        return _pymdlsdk.IExpression_factory_create_annotation(self, name, arguments)

    def create_annotation_block(self):
        r""" Creates a new annotation block."""
        return _pymdlsdk.IExpression_factory_create_annotation_block(self)

    def create_annotation_list(self):
        r""" Creates a new annotation list."""
        return _pymdlsdk.IExpression_factory_create_annotation_list(self)

    def clone(self, *args):
        r"""
        *Overload 1:*
        Clones the given expression.

        Note that referenced DB elements, e.g., resources in constant expressions, or function calls
        and material instances in call expressions, are not copied, but shared. Function calls and
        material instances that serve as default arguments, are copied, though.

        |

        *Overload 2:*
        Clones the given expression list.

        Note that referenced DB elements, e.g., resources in constant expressions, or function calls
        and material instances in call expressions, are not copied, but shared.
        """
        return _pymdlsdk.IExpression_factory_clone(self, *args)

    def compare(self, *args):
        r"""
        *Overload 1:*
        Compares two instances of #mi::neuraylib::IExpression.

        The comparison operator for instances of #mi::neuraylib::IExpression is defined as follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Otherwise, the types of ``lhs`` and ``rhs`` are compared. If they are different, the result
          is determined by that comparison.
        - Next, the kind of the expressions are compared. If they are different, the result is
          determined by ``operator``< on the #mi::neuraylib::IExpression::Kind values. Note that
          setting #SKIP_TYPE_ALIASES in ``flags`` modifies this behavior.
        - Finally, the expressions are compared as follows:
          - For constants the results is defined by comparing their values.
          - For calls, the result is defined by comparison of the call reference (unless
            #DEEP_CALL_COMPARISONS is set in ``flags)``. Note that the representation of this call
            reference is an internal implementation detail, and the comparison result might have
            the opposite sign as ``strcmp()`` on the strings returned by
            #mi::neuraylib::IExpression_call::get_call().
          - For parameter and temporary references, the results is defined by ``operator``<() on the
            indices.
          - For indirect calls, first the definition reference is compared. Note that the
            representation of this definition reference is an internal implementation detail, and
            the comparison result might have the opposite sign as ``strcmp()`` on the strings
            returned by #mi::neuraylib::IExpression_direct_call::get_definition(). If both indirect
            call reference the same definition, then the result is defined by comparison of the
            arguments.

        :type lhs: :py:class:`IExpression`
        :param lhs:          The left-hand side operand for the comparison.
        :type rhs: :py:class:`IExpression`
        :param rhs:          The right-hand side operand for the comparison.
        :type flags: int, optional
        :param flags:        A bitmask of flags of type #Comparison_options.
        :type epsilon: float, optional
        :param epsilon:      Maximum difference for floating point values to consider them as equal.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.

        |

        *Overload 2:*
        Compares two instances of #mi::neuraylib::IExpression_list.

        The comparison operator for instances of #mi::neuraylib::IExpression_list is defined as
        follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Next, the list sizes are compared using ``operator``<().
        - Next, the lists are traversed by increasing index and the names are compared using
          ``strcmp()``.
        - Finally, the list elements are enumerated by increasing index and the expressions are
          compared.

        :type lhs: :py:class:`IExpression_list`
        :param lhs:          The left-hand side operand for the comparison.
        :type rhs: :py:class:`IExpression_list`
        :param rhs:          The right-hand side operand for the comparison.
        :type flags: int, optional
        :param flags:        A bitmask of flags of type #Comparison_options.
        :type epsilon: float, optional
        :param epsilon:      Maximum difference for floating point values to consider them as equal.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.

        |

        *Overload 3:*
        Compares two instances of #mi::neuraylib::IExpression_list.

        The comparison operator for instances of #mi::neuraylib::IExpression_list is defined as
        follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Next, the list sizes are compared using ``operator``<().
        - Next, the lists are traversed by increasing index and the names are compared using
          ``strcmp()``.
        - Finally, the list elements are enumerated by increasing index and the expressions are
          compared.

        :type lhs: :py:class:`IExpression_list`
        :param lhs:          The left-hand side operand for the comparison.
        :type rhs: :py:class:`IExpression_list`
        :param rhs:          The right-hand side operand for the comparison.
        :type flags: int, optional
        :param flags:        A bitmask of flags of type #Comparison_options.
        :param epsilon:      Maximum difference for floating point values to consider them as equal.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.

        |

        *Overload 4:*
        Compares two instances of #mi::neuraylib::IExpression_list.

        The comparison operator for instances of #mi::neuraylib::IExpression_list is defined as
        follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Next, the list sizes are compared using ``operator``<().
        - Next, the lists are traversed by increasing index and the names are compared using
          ``strcmp()``.
        - Finally, the list elements are enumerated by increasing index and the expressions are
          compared.

        :type lhs: :py:class:`IExpression_list`
        :param lhs:          The left-hand side operand for the comparison.
        :type rhs: :py:class:`IExpression_list`
        :param rhs:          The right-hand side operand for the comparison.
        :param flags:        A bitmask of flags of type #Comparison_options.
        :param epsilon:      Maximum difference for floating point values to consider them as equal.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.
        """
        return _pymdlsdk.IExpression_factory_compare(self, *args)

    def dump(self, *args):
        r"""
        *Overload 1:*
         Returns a textual representation of an expression.

         The parameter ``depth`` is only relevant for constants, where the argument is passed to
         #mi::neuraylib::IValue_factory::dump().

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 2:*
         Returns a textual representation of an expression list.

         The representation of the expression list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 3:*
         Returns a textual representation of an expression list.

         The representation of the expression list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 4:*
         Returns a textual representation of an annotation.

         The representation of the annotation will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 5:*
         Returns a textual representation of an annotation.

         The representation of the annotation will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 6:*
         Returns a textual representation of an annotation block.

         The representation of the annotation block will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 7:*
         Returns a textual representation of an annotation block.

         The representation of the annotation block will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 8:*
         Returns a textual representation of an annotation list.

         The representation of the annotation list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 9:*
         Returns a textual representation of an annotation list.

         The representation of the annotation list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.
        """
        return _pymdlsdk.IExpression_factory_dump(self, *args)

    def create_cast_with_ret(self, src_expr, target_type, cast_db_name, force_cast):
        r"""
        Returns an expression which casts the source expression to the ``target_type``.

        This is a convenience function that creates an instance of the cast operator with
        the necessary arguments, stores it in the database and creates and returns an
        #mi::neuraylib::IExpression_call using the just created function. If ``force_cast`` is
        set to ``true``, the cast will always be inserted, even if the types match. If ``force_cast``
        is set to ``false``, the original expression is returned for identical types.
        If the type of ``src_expr`` and ``target_type`` are not compatible, ``NULL`` is returned.

        :type src_expr: :py:class:`IExpression`
        :param src_expr:     The expression whose type is supposed to be casted.
        :type target_type: :py:class:`IType`
        :param target_type:  The result type of the cast. Note that the inserted cast operator acts on
                                types without qualifiers, i.e., modifiers on ``target_type`` are ignored.
        :type cast_db_name: string
        :param cast_db_name: This name is used when storing the instance
                                of the cast-operator function into the database. If the name is already
                                taken by another DB element, this string will be used as the base for
                                generating a unique name. If NULL, a unique name is generated.
        :type force_cast: boolean
        :param force_cast:   If ``true``, the cast will be created even if the types are
                                identical. Please note that a cast cannot be forced for
                                incompatible types.
        :type errors: int, optional
        :param errors:       An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                - 0: Success.
                                - 1: Invalid parameters (``NULL`` pointer).
                                - 2: The type of ``src_expr`` cannot be cast to ``target_type``.

        :rtype: :py:class:`IExpression`
        :return: The resulting expression or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IExpression_factory_create_cast_with_ret(self, src_expr, target_type, cast_db_name, force_cast)

    def create_cast(self, src_expr, target_type, cast_db_name, force_cast):
        r"""
        Returns an expression which casts the source expression to the ``target_type``.

        This is a convenience function that creates an instance of the cast operator with
        the necessary arguments, stores it in the database and creates and returns an
        #mi::neuraylib::IExpression_call using the just created function. If ``force_cast`` is
        set to ``true``, the cast will always be inserted, even if the types match. If ``force_cast``
        is set to ``false``, the original expression is returned for identical types.
        If the type of ``src_expr`` and ``target_type`` are not compatible, ``NULL`` is returned.

        :type src_expr: :py:class:`IExpression`
        :param src_expr:     The expression whose type is supposed to be casted.
        :type target_type: :py:class:`IType`
        :param target_type:  The result type of the cast. Note that the inserted cast operator acts on
                                types without qualifiers, i.e., modifiers on ``target_type`` are ignored.
        :type cast_db_name: string
        :param cast_db_name: This name is used when storing the instance
                                of the cast-operator function into the database. If the name is already
                                taken by another DB element, this string will be used as the base for
                                generating a unique name. If NULL, a unique name is generated.
        :type force_cast: boolean
        :param force_cast:   If ``true``, the cast will be created even if the types are
                                identical. Please note that a cast cannot be forced for
                                incompatible types.
        :param errors:       An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                - 0: Success.
                                - 1: Invalid parameters (``NULL`` pointer).
                                - 2: The type of ``src_expr`` cannot be cast to ``target_type``.

        :rtype: :py:class:`IExpression`
        :return: The resulting expression or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IExpression_factory_create_cast(self, src_expr, target_type, cast_db_name, force_cast)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IExpression_factory_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IExpression_factory__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IExpression_factory__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IExpression_factory_get_iid(self)

# Register IExpression_factory in _pymdlsdk:
_pymdlsdk.IExpression_factory_swigregister(IExpression_factory)

def IExpression_factory_IID():
    return _pymdlsdk.IExpression_factory_IID()

def IExpression_factory__get_interface(iface):
    return _pymdlsdk.IExpression_factory__get_interface(iface)

class IExpression_list(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IExpression_list_swiginit(self, _pymdlsdk.new_IExpression_list(*args))
    __swig_destroy__ = _pymdlsdk.delete_IExpression_list

    def __deref__(self):
        return _pymdlsdk.IExpression_list___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IExpression_list___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IExpression_list_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IExpression_list___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IExpression_list___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IExpression_list_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IExpression_list_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IExpression_list__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_expression(self, *args):
        return  self._get_expression(*args)

    def get_expression_as(self, type, *args):
        iinterface = self._get_expression(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_size(self):
        r""" Returns the number of elements."""
        return _pymdlsdk.IExpression_list_get_size(self)

    def get_index(self, name):
        r""" Returns the index for the given name, or -1 if there is no such expression."""
        return _pymdlsdk.IExpression_list_get_index(self, name)

    def get_name(self, index):
        r""" Returns the name for the given index, or ``NULL`` if there is no such expression."""
        return _pymdlsdk.IExpression_list_get_name(self, index)

    def _get_expression(self, *args):
        r"""
        *Overload 1:*
        Returns the expression for ``index``, or ``NULL`` if there is no such expression.

        |

        *Overload 2:*
        Returns the expression for ``name``, or ``NULL`` if there is no such expression.
        """
        return _pymdlsdk.IExpression_list__get_expression(self, *args)

    def set_expression(self, *args):
        r"""
        *Overload 1:*
        Sets an expression at a given index.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: ``index`` is out of bounds.

        |

        *Overload 2:*
        Sets an expression identified by name.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is no expression mapped to ``name`` in the list.
        """
        return _pymdlsdk.IExpression_list_set_expression(self, *args)

    def add_expression(self, name, expression):
        r"""
        Adds an expression at the end of the list.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is already an expression mapped to ``name`` in the list.
        """
        return _pymdlsdk.IExpression_list_add_expression(self, name, expression)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IExpression_list_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IExpression_list__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IExpression_list__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IExpression_list_get_iid(self)

# Register IExpression_list in _pymdlsdk:
_pymdlsdk.IExpression_list_swigregister(IExpression_list)

def IExpression_list_IID():
    return _pymdlsdk.IExpression_list_IID()

def IExpression_list__get_interface(iface):
    return _pymdlsdk.IExpression_list__get_interface(iface)

class IExpression_parameter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IExpression_parameter_swiginit(self, _pymdlsdk.new_IExpression_parameter(*args))
    __swig_destroy__ = _pymdlsdk.delete_IExpression_parameter

    def __deref__(self):
        return _pymdlsdk.IExpression_parameter___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IExpression_parameter___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IExpression_parameter_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IExpression_parameter___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IExpression_parameter___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IExpression_parameter_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IExpression_parameter_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IExpression_parameter__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IExpression.Kind(self._get_kind(*args))


    def get_type(self, *args):
        return  self._get_type(*args)

    def get_type_as(self, type, *args):
        iinterface = self._get_type(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_index(self):
        r""" Returns the index of the referenced parameter."""
        return _pymdlsdk.IExpression_parameter_get_index(self)

    def set_index(self, index):
        r""" Sets the index of the referenced parameter."""
        return _pymdlsdk.IExpression_parameter_set_index(self, index)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IExpression_parameter_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of this expression."""
        return _pymdlsdk.IExpression_parameter__get_kind(self)

    def _get_type(self):
        r""" Returns the type of this expression."""
        return _pymdlsdk.IExpression_parameter__get_type(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IExpression_parameter__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IExpression_parameter__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IExpression_parameter_get_iid(self)

# Register IExpression_parameter in _pymdlsdk:
_pymdlsdk.IExpression_parameter_swigregister(IExpression_parameter)

def IExpression_parameter_IID():
    return _pymdlsdk.IExpression_parameter_IID()

def IExpression_parameter__get_interface(iface):
    return _pymdlsdk.IExpression_parameter__get_interface(iface)

class IExpression_temporary(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IExpression_temporary_swiginit(self, _pymdlsdk.new_IExpression_temporary(*args))
    __swig_destroy__ = _pymdlsdk.delete_IExpression_temporary

    def __deref__(self):
        return _pymdlsdk.IExpression_temporary___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IExpression_temporary___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IExpression_temporary_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IExpression_temporary___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IExpression_temporary___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IExpression_temporary_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IExpression_temporary_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IExpression_temporary__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IExpression.Kind(self._get_kind(*args))


    def get_type(self, *args):
        return  self._get_type(*args)

    def get_type_as(self, type, *args):
        iinterface = self._get_type(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_index(self):
        r""" Returns the index of the referenced temporary."""
        return _pymdlsdk.IExpression_temporary_get_index(self)

    def set_index(self, index):
        r""" Sets the index of the referenced temporary."""
        return _pymdlsdk.IExpression_temporary_set_index(self, index)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IExpression_temporary_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of this expression."""
        return _pymdlsdk.IExpression_temporary__get_kind(self)

    def _get_type(self):
        r""" Returns the type of this expression."""
        return _pymdlsdk.IExpression_temporary__get_type(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IExpression_temporary__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IExpression_temporary__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IExpression_temporary_get_iid(self)

# Register IExpression_temporary in _pymdlsdk:
_pymdlsdk.IExpression_temporary_swigregister(IExpression_temporary)

def IExpression_temporary_IID():
    return _pymdlsdk.IExpression_temporary_IID()

def IExpression_temporary__get_interface(iface):
    return _pymdlsdk.IExpression_temporary__get_interface(iface)

class IFunction_call(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IFunction_call_swiginit(self, _pymdlsdk.new_IFunction_call(*args))
    __swig_destroy__ = _pymdlsdk.delete_IFunction_call

    def __deref__(self):
        return _pymdlsdk.IFunction_call___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IFunction_call___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IFunction_call_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IFunction_call___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IFunction_call___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IFunction_call_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IFunction_call_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IFunction_call__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_function_definition(self):
        r"""
        Returns the DB name of the corresponding function definition.

        The type of the function definition is #mi::neuraylib::IFunction_definition.

        Notes: The DB name of the function definition is different from its MDL name (see
              #get_mdl_function_definition()).
        """
        return _pymdlsdk.IFunction_call_get_function_definition(self)

    def get_mdl_function_definition(self):
        r"""
        Returns the MDL name of the corresponding function definition.

        Notes: The MDL name of the function definition is different from the name of the DB element
              (see #get_function_definition()).
        """
        return _pymdlsdk.IFunction_call_get_mdl_function_definition(self)

    def is_material(self):
        r"""
        Indicates whether the call represents a material instance.

        If 'mi_mdl_materials_are_functions' is disabled, then this method returns always
        ``false``.
        """
        return _pymdlsdk.IFunction_call_is_material(self)

    def is_array_constructor(self):
        r"""
        Indicates whether this call is an instance of the array constructor.

        See also: 'mi_neuray_mdl_arrays'
        """
        return _pymdlsdk.IFunction_call_is_array_constructor(self)

    def get_return_type(self):
        r""" Returns the return type of the corresponding function definition."""
        return _pymdlsdk.IFunction_call_get_return_type(self)

    def get_parameter_count(self):
        r""" Returns the number of parameters."""
        return _pymdlsdk.IFunction_call_get_parameter_count(self)

    def get_parameter_name(self, index):
        r"""
        Returns the name of the parameter at ``index``.

        :type index: int
        :param index:        The index of the parameter.
        :rtype: string
        :return: The name of the parameter, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk.IFunction_call_get_parameter_name(self, index)

    def get_parameter_index(self, name):
        r"""
        Returns the index position of a parameter.

        :type name: string
        :param name:         The name of the parameter.
        :rtype: int
        :return: The index of the parameter, or -1 if ``name`` is invalid.
        """
        return _pymdlsdk.IFunction_call_get_parameter_index(self, name)

    def get_parameter_types(self):
        r""" Returns the types of all parameters."""
        return _pymdlsdk.IFunction_call_get_parameter_types(self)

    def get_arguments(self):
        r""" Returns all arguments."""
        return _pymdlsdk.IFunction_call_get_arguments(self)

    def set_arguments(self, arguments):
        r"""
        Sets multiple arguments.

        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments. Note that the expressions are copied. This copy operation
                                is a shallow copy, e.g., DB elements referenced in call expressions are
                                *not* copied.
        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer).
                                - -2: One of the parameters in ``arguments`` does not exist.
                                - -3: One of the argument types does not match the corresponding
                                      parameter type.
                                - -4: The function call is immutable (because it appears in a default of
                                      a function or material definition).
                                - -5: One of the parameter types is uniform, but the corresponding
                                      argument type is varying.
                                - -6: One of the arguments is not a constant nor a call.
                                - -7: One of the arguments contains references to DB elements in a scope
                                      that is more private scope than the scope of this material
                                      instance.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument is a call expression and the return type of the
                                      called function definition is effectively varying since the
                                      function definition itself is varying.
        """
        return _pymdlsdk.IFunction_call_set_arguments(self, arguments)

    def set_argument(self, *args):
        r"""
        *Overload 1:*
        Sets the argument at ``index``.

        :type index: int
        :param index:        The index of the argument.
        :type argument: :py:class:`IExpression`
        :param argument:     The argument. Note that the expression is copied. This copy operation
                                is a shallow copy, e.g., DB elements referenced in call expressions are
                                *not* copied.
        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer).
                                - -2: Parameter ``index`` does not exist.
                                - -3: The argument type does not match the parameter type.
                                - -4: The function call is immutable (because it appears in a default of
                                      a function or material definition).
                                - -5: The parameter type is uniform, but the argument type is varying.
                                - -6: The argument expression is not a constant nor a call.
                                - -7: The argument contains references to DB elements in a scope that is
                                      more private scope than the scope of this material instance.
                                - -8: The parameter types is uniform, but the argument is a call
                                      expression and the return type of the called function definition
                                      is effectively varying since the function definition itself is
                                      varying.

        |

        *Overload 2:*
        Sets an argument identified by name.

        :type name: string
        :param name:         The name of the parameter.
        :type argument: :py:class:`IExpression`
        :param argument:     The argument. Note that the expression is copied. This copy operation
                                is a shallow copy, e.g., DB elements referenced in call expressions are
                                *not* copied.
        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer).
                                - -2: Parameter ``name`` does not exist.
                                - -3: The argument type does not match the parameter type.
                                - -4: The function call is immutable (because it appears in a default of
                                      a function or material definition).
                                - -5: The parameter type is uniform, but the argument type is varying.
                                - -6: The argument expression is not a constant nor a call.
                                - -7: The argument contains references to DB elements in a scope that is
                                      more private scope than the scope of this material instance.
                                - -8: The parameter types is uniform, but the argument is a call
                                      expression and the return type of the called function definition
                                      is effectively varying since the function definition itself is
                                      varying.
        """
        return _pymdlsdk.IFunction_call_set_argument(self, *args)

    def reset_argument(self, *args):
        r"""
        *Overload 1:*
        Resets the argument at ``index``.

        If the function definition has a default for this parameter (and it does not violate a
        potential uniform requirement), then a clone of it is used as new argument. Otherwise, a
        constant expression is created, observing range annotations if present (see the overload of
        #mi::neuraylib::IValue_factory::create() with two arguments).

        :type index: int
        :param index:        The index of the argument.
        :rtype: int
        :return: 
                                -   0: Success.
                                -  -2: Parameter ``index`` does not exist.
                                -  -4: The function call is immutable (because it appears in a default
                                       of a function or material definition).
                                -  -9: The function call is not valid (see #is_valid()).

        |

        *Overload 2:*
        Resets an argument identified by name

        If the function definition has a default for this parameter (and it does not violate a
        potential uniform requirement), then a clone of it is used as new argument. Otherwise, a
        constant expression is created, observing range annotations if present (see the overload of
        #mi::neuraylib::IValue_factory::create() with two arguments).

        :type name: string
        :param name:         The name of the parameter.
        :rtype: int
        :return: 
                                -   0: Success.
                                -  -1: Invalid parameters (``NULL`` pointer).
                                -  -2: Parameter ``name`` does not exist.
                                -  -4: The function call is immutable (because it appears in a default
                                       of a function or material definition).
                                -  -9: The function call is not valid (see #is_valid()).
        """
        return _pymdlsdk.IFunction_call_reset_argument(self, *args)

    def is_default(self):
        r"""
        Indicates, if this function call acts as a default argument of a material or function
        definition.

        Defaults are immutable, their arguments cannot be changed and they cannot be used
        in call expressions.

        :rtype: boolean
        :return: ``true``, if this function call is a default, ``false`` otherwise.
        """
        return _pymdlsdk.IFunction_call_is_default(self)

    def is_valid(self, context):
        r"""
        Returns ``true`` if this function call and all its arguments point to valid
        material and function definitions, ``false`` otherwise.

        Material and function definitions can become invalid due to a module reload.

        See also: #mi::neuraylib::IModule::reload(), #mi::neuraylib::IFunction_call::repair()

        :type context: :py:class:`IMdl_execution_context`
        :param context:  Execution context that can be queried for error messages
                            after the operation has finished. Can be ``NULL``.
        :rtype: boolean
        :return: 
                 - ``true``:  The instance is valid.
                 - ``false``: The instance is invalid.
        """
        return _pymdlsdk.IFunction_call_is_valid(self, context)

    def repair(self, flags, context):
        r"""
        Attempts to repair an invalid function call.

        :type flags: int
        :param flags:    Repair options, see #mi::neuraylib::Mdl_repair_options.
        :type context: :py:class:`IMdl_execution_context`
        :param context:  Execution context that can be queried for error messages
                            after the operation has finished. Can be ``NULL``.
        :rtype: int
        :return: 
                -   0:   Success.
                -  -1:   Repair failed. Check the ``context`` for details.
        """
        return _pymdlsdk.IFunction_call_repair(self, flags, context)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IFunction_call_compare_iid(self, iid)

    def get_element_type(self):
        r""" Indicates the actual scene element represented by interfaces derived from this interface."""
        return _pymdlsdk.IFunction_call_get_element_type(self)

    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk.IFunction_call_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk.IFunction_call_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IFunction_call_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IFunction_call_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk.IFunction_call_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk.IFunction_call_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk.IFunction_call_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk.IFunction_call_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk.IFunction_call_enumerate_attributes(self, index)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IFunction_call__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IFunction_call__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IFunction_call_get_iid(self)

# Register IFunction_call in _pymdlsdk:
_pymdlsdk.IFunction_call_swigregister(IFunction_call)

def IFunction_call_IID():
    return _pymdlsdk.IFunction_call_IID()

def IFunction_call__get_interface(iface):
    return _pymdlsdk.IFunction_call__get_interface(iface)

class IFunction_definition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IFunction_definition_swiginit(self, _pymdlsdk.new_IFunction_definition(*args))
    __swig_destroy__ = _pymdlsdk.delete_IFunction_definition

    def __deref__(self):
        return _pymdlsdk.IFunction_definition___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IFunction_definition___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IFunction_definition_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IFunction_definition___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IFunction_definition___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IFunction_definition_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IFunction_definition_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IFunction_definition__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_module(self):
        r"""
        Returns the DB name of the module containing this function definition.

        The type of the module is #mi::neuraylib::IModule.
        """
        return _pymdlsdk.IFunction_definition_get_module(self)

    def get_mdl_name(self):
        r"""
        Returns the MDL name of the function definition.

        Notes: The MDL name of the function definition is different from the name of the DB element.
              Use #mi::neuraylib::ITransaction::name_of() to obtain the name of the DB element.

        :rtype: string
        :return: The MDL name of the function definition.
        """
        return _pymdlsdk.IFunction_definition_get_mdl_name(self)

    def get_mdl_module_name(self):
        r""" Returns the MDL name of the module containing this function definition."""
        return _pymdlsdk.IFunction_definition_get_mdl_module_name(self)

    def get_mdl_simple_name(self):
        r"""
        Returns the simple MDL name of the function definition.

        The simple name is the last component of the MDL name, i.e., without any packages and
        scope qualifiers, and without the parameter type names.

        :rtype: string
        :return: The simple MDL name of the function definition.
        """
        return _pymdlsdk.IFunction_definition_get_mdl_simple_name(self)

    def get_mdl_parameter_type_name(self, index):
        r"""
        Returns the type name of the parameter at ``index``.

        Notes: The type names provided here are substrings of the MDL name returned by
              #get_mdl_name(). They are provided here such that parsing of the MDL name is not
              necessary. Their main use case is one variant of overload resolution if no actual
              arguments are given (see
              #mi::neuraylib::IModule::get_function_overloads(const char*,const IArray*)const. For
              almost all other use cases it is strongly recommended to use #get_parameter_types()
              instead.

        :type index: int
        :param index:    The index of the parameter.
        :rtype: string
        :return: The type name of the parameter, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk.IFunction_definition_get_mdl_parameter_type_name(self, index)

    def get_prototype(self):
        r"""
        Returns the DB name of the prototype, or ``NULL`` if this function definition is not a
        variant.
        """
        return _pymdlsdk.IFunction_definition_get_prototype(self)

    def get_mdl_version(self, since, removed):
        r"""
        Returns the MDL version when this function definition was added and removed.

        :type since: int, out
        :param since:     The MDL version in which this function definition was added. If the
                                  function definition does not belong to the standard library, the
                                  MDL version of the corresponding module is returned.
        :type removed: int, out
        :param removed:   The MDL version in which this function definition was removed, or
                                  mi::neuraylib::MDL_VERSION_INVALID if the function has not been
                                  removed so far or does not belong to the standard library.
        """
        return _pymdlsdk.IFunction_definition_get_mdl_version(self, since, removed)

    def get_semantic(self):
        r""" Returns the semantic of this function definition."""
        return _pymdlsdk.IFunction_definition_get_semantic(self)

    def is_array_constructor(self):
        r"""
        Indicates whether this definition represents the array constructor.

        See also: 'mi_neuray_mdl_arrays'
        """
        return _pymdlsdk.IFunction_definition_is_array_constructor(self)

    def is_exported(self):
        r""" Indicates whether the function definition is exported by its module."""
        return _pymdlsdk.IFunction_definition_is_exported(self)

    def is_uniform(self):
        r"""
        Indicates whether the function definition is uniform.

        Notes: This includes, in addition to functions definitions that are explicitly marked as
              uniform, also function definitions that are not explicitly marked either uniform or
              varying and that have been analyzed by the MDL compiler to be uniform.
        """
        return _pymdlsdk.IFunction_definition_is_uniform(self)

    def is_material(self):
        r"""
        Indicates whether the definition represents a material.

        If 'mi_mdl_materials_are_functions' is disabled, then this method returns always
        ``false``.
        """
        return _pymdlsdk.IFunction_definition_is_material(self)

    def get_return_type(self):
        r"""
        Returns the return type.

        :rtype: :py:class:`IType`
        :return: The return type.
        """
        return _pymdlsdk.IFunction_definition_get_return_type(self)

    def get_parameter_count(self):
        r""" Returns the number of parameters."""
        return _pymdlsdk.IFunction_definition_get_parameter_count(self)

    def get_parameter_name(self, index):
        r"""
        Returns the name of the parameter at ``index``.

        :type index: int
        :param index:    The index of the parameter.
        :rtype: string
        :return: The name of the parameter, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk.IFunction_definition_get_parameter_name(self, index)

    def get_parameter_index(self, name):
        r"""
        Returns the index position of a parameter.

        :type name: string
        :param name:     The name of the parameter.
        :rtype: int
        :return: The index of the parameter, or -1 if ``name`` is invalid.
        """
        return _pymdlsdk.IFunction_definition_get_parameter_index(self, name)

    def get_parameter_types(self):
        r""" Returns the types of all parameters."""
        return _pymdlsdk.IFunction_definition_get_parameter_types(self)

    def get_defaults(self):
        r"""
        Returns the defaults of all parameters.

        Notes: Not all parameters have defaults. Hence, the indices in the returned expression list
              do not necessarily coincide with the parameter indices of this definition. Therefore,
              defaults should be retrieved via the name of the parameter instead of its index.
        """
        return _pymdlsdk.IFunction_definition_get_defaults(self)

    def get_enable_if_conditions(self):
        r"""
        Returns the ``enable_if`` conditions of all parameters.

        Notes: Not all parameters have a condition. Hence, the indices in the returned expression
              list do not necessarily coincide with the parameter indices of this definition.
              Therefore, conditions should be retrieved via the name of the parameter instead of
              its index.
        """
        return _pymdlsdk.IFunction_definition_get_enable_if_conditions(self)

    def get_enable_if_users(self, index):
        r"""
        Returns the number of other parameters whose ``enable_if`` condition might depend on the
        argument of the given parameter.

        :type index: int
        :param index:    The index of the parameter.
        :rtype: int
        :return: The number of other parameters whose ``enable_if`` condition depends on this
                            parameter argument.
        """
        return _pymdlsdk.IFunction_definition_get_enable_if_users(self, index)

    def get_enable_if_user(self, index, u_index):
        r"""
        Returns the index of a parameter whose ``enable_if`` condition might depend on the
        argument of the given parameter.

        :type index: int
        :param index:    The index of the parameter.
        :type u_index: int
        :param u_index:  The index of the enable_if user.
        :rtype: int
        :return: The index of a parameter whose ``enable_if`` condition depends on this
                            parameter argument, or ~0 if indexes are out of range.
        """
        return _pymdlsdk.IFunction_definition_get_enable_if_user(self, index, u_index)

    def get_annotations(self):
        r"""
        Returns the annotations of the function definition itself, or ``NULL`` if there are no such
        annotations.
        """
        return _pymdlsdk.IFunction_definition_get_annotations(self)

    def get_return_annotations(self):
        r"""
        Returns the annotations of the return type of this function definition, or ``NULL`` if there
        are no such annotations.
        """
        return _pymdlsdk.IFunction_definition_get_return_annotations(self)

    def get_parameter_annotations(self):
        r"""
        Returns the annotations of all parameters.

        Notes: Not all parameters have annotations. Hence, the indices in the returned annotation
              list do not necessarily coincide with the parameter indices of this definition.
              Therefore, annotation blocks should be retrieved via the name of the parameter
              instead of its index.
        """
        return _pymdlsdk.IFunction_definition_get_parameter_annotations(self)

    def get_thumbnail(self):
        r"""
        Returns the resolved file name of the thumbnail image for this function definition.

        The function first checks for a thumbnail annotation. If the annotation is provided,
        it uses the 'name' argument of the annotation and resolves that in the MDL search path.
        If the annotation is not provided or file resolution fails, it checks for a file
        module_name.material_name.png next to the MDL module.
        In case this cannot be found either ``NULL`` is returned.
        """
        return _pymdlsdk.IFunction_definition_get_thumbnail(self)

    def is_valid(self, context):
        r"""
        Returns ``true`` if the definition is valid, ``false`` otherwise.

        A definition can become invalid if the module it has been defined in
        or another module imported by that module has been reloaded. In the first case,
        the definition can no longer be used. In the second case, the
        definition can be validated by reloading the module it has been
        defined in.
        :type context: :py:class:`IMdl_execution_context`
        :param context:  Execution context that can be queried for error messages
                            after the operation has finished. Can be ``NULL``.
        :rtype: boolean
        :return: - ``true``   The definition is valid.
                        - ``false``  The definition is invalid.
        """
        return _pymdlsdk.IFunction_definition_is_valid(self, context)

    def get_body(self):
        r"""
        Returns the direct call expression that represents the body of the function (if possible).

        Notes: Functions bodies with control flow can not be represented by an expression. For such
              functions, this method always returns ``NULL``. For all other functions, i.e., for
              functions, whose body is an expression or a plain return statement, the method never
              returns ``NULL`` (unless there is no body at all, see below).

        Functions with a known semantic, i.e., different from
              #mi::neuraylib::IFunction_definition::DS_UNKNOWN, do not have a body as such, and the
              method returns ``NULL`` for such functions.
        """
        return _pymdlsdk.IFunction_definition_get_body(self)

    def get_temporary_count(self):
        r""" Returns the number of temporaries used by this function."""
        return _pymdlsdk.IFunction_definition_get_temporary_count(self)

    def get_temporary(self, index):
        r"""
        Returns the expression of a temporary.

        :type index: int
        :param index:            The index of the temporary.
        :rtype: :py:class:`IExpression`
        :return: The expression of the temporary, or ``NULL`` if ``index`` is out of
                                    range.
        """
        return _pymdlsdk.IFunction_definition_get_temporary(self, index)

    def get_temporary_name(self, index):
        r"""
        Returns the name of a temporary.

        Notes: Names of temporaries are not necessarily unique, e.g., due to inlining. Names are for
              informational purposes and should not be used to identify a particular temporary.

        See also: #mi::neuraylib::IMdl_configuration::set_expose_names_of_let_expressions()

        :type index: int
        :param index:            The index of the temporary.
        :rtype: string
        :return: The name of the temporary, or ``NULL`` if the temporary has no name
                                    or ``index`` is out of range.
        """
        return _pymdlsdk.IFunction_definition_get_temporary_name(self, index)

    def create_function_call_with_ret(self, arguments):
        r"""
        Creates a new function call.

        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments of the created function call.

                                Arguments for parameters without default are mandatory, otherwise
                                optional. The type of an argument must match the corresponding parameter
                                type. Any argument missing in ``arguments`` will be set to the default of
                                the corresponding parameter.

                                Note that the expressions in ``arguments`` are copied. This copy
                                operation is a deep copy, e.g., DB elements referenced in call
                                expressions are also copied.

                                ``NULL`` is a valid argument which is handled like an empty expression
                                list.
        :type errors: int, out, optional
        :param errors:  An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                -  0: Success.
                                - -1: An argument for a non-existing parameter was provided in
                                      ``arguments``.
                                - -2: The type of an argument in ``arguments`` does not have the correct
                                      type, see #get_parameter_types().
                                - -3: A parameter that has no default was not provided with an argument
                                      value.
                                - -4: The definition can not be instantiated because it is not exported.
                                - -5: A parameter type is uniform, but the corresponding argument has a
                                      varying return type.
                                - -6: An argument expression is not a constant nor a call.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument or default is a call expression and the return type of
                                      the called function definition is effectively varying since the
                                      function definition itself is varying.
                                - -9: The function definition is invalid due to a module reload, see
                                      #is_valid() for diagnostics.
        :rtype: :py:class:`IFunction_call`
        :return: The created function call, or ``NULL`` in case of errors.
        """
        return _pymdlsdk.IFunction_definition_create_function_call_with_ret(self, arguments)

    def create_function_call(self, arguments):
        r"""
        Creates a new function call.

        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments of the created function call.

                                Arguments for parameters without default are mandatory, otherwise
                                optional. The type of an argument must match the corresponding parameter
                                type. Any argument missing in ``arguments`` will be set to the default of
                                the corresponding parameter.

                                Note that the expressions in ``arguments`` are copied. This copy
                                operation is a deep copy, e.g., DB elements referenced in call
                                expressions are also copied.

                                ``NULL`` is a valid argument which is handled like an empty expression
                                list.
        :param errors:  An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                -  0: Success.
                                - -1: An argument for a non-existing parameter was provided in
                                      ``arguments``.
                                - -2: The type of an argument in ``arguments`` does not have the correct
                                      type, see #get_parameter_types().
                                - -3: A parameter that has no default was not provided with an argument
                                      value.
                                - -4: The definition can not be instantiated because it is not exported.
                                - -5: A parameter type is uniform, but the corresponding argument has a
                                      varying return type.
                                - -6: An argument expression is not a constant nor a call.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument or default is a call expression and the return type of
                                      the called function definition is effectively varying since the
                                      function definition itself is varying.
                                - -9: The function definition is invalid due to a module reload, see
                                      #is_valid() for diagnostics.
        :rtype: :py:class:`IFunction_call`
        :return: The created function call, or ``NULL`` in case of errors.
        """
        return _pymdlsdk.IFunction_definition_create_function_call(self, arguments)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IFunction_definition_compare_iid(self, iid)

    def get_element_type(self):
        r""" Indicates the actual scene element represented by interfaces derived from this interface."""
        return _pymdlsdk.IFunction_definition_get_element_type(self)

    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk.IFunction_definition_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk.IFunction_definition_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IFunction_definition_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IFunction_definition_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk.IFunction_definition_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk.IFunction_definition_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk.IFunction_definition_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk.IFunction_definition_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk.IFunction_definition_enumerate_attributes(self, index)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IFunction_definition__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IFunction_definition__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IFunction_definition_get_iid(self)

# Register IFunction_definition in _pymdlsdk:
_pymdlsdk.IFunction_definition_swigregister(IFunction_definition)

def IFunction_definition_IID():
    return _pymdlsdk.IFunction_definition_IID()

def IFunction_definition__get_interface(iface):
    return _pymdlsdk.IFunction_definition__get_interface(iface)

class IImage(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IImage_swiginit(self, _pymdlsdk.new_IImage(*args))
    __swig_destroy__ = _pymdlsdk.delete_IImage

    def __deref__(self):
        return _pymdlsdk.IImage___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IImage___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IImage_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IImage___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IImage___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IImage_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IImage_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IImage__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def reset_file(self, filename, selector=None):
        r"""
        Sets the image to a file identified by ``filename``.

        Note that support for a given image format requires an image plugin capable of handling
        that format.

        The filename can include one of the following three uv-tileset markers in the filename:
        <UDIM>, <UVTILE0>, or <UVTILE1>. The image refers then to a
        whole uv-tileset, a set of images used together as a single large two-dimensional image.
        The different markers indicate the different filename conventions that encode where each
        image file is placed in the uv texture space.



          |Marker
          |Pattern
          |(0,0) index
          |Convention to format a (u, v)-index
        |
        -

          |<UDIM>
          |DDDD
          |1001
          |UDIM, expands to the four digit number 1000+(u+1+v10)
        |

          |<UVTILE0>
          |"_u"I"_v"I
          |_u0_v0
          |0-based uv-tileset, expands to "_u"u"_v"v"</td>
        </tr>
        <tr>
          <td>&lt;UVTILE1&gt;</td>
          <td>"_u"I"_v"I</td>
          <td>_u1_v1</td>
          <td>1-based uv-tileset, expands to "_u"(u+1)"_v"(v+1)"
        |


        The filename can also include a sequence marker for the frame number of animated textures:
        <#...> (with a non-zero count of ``'#'`` characters). The marker matches any
        non-negative integral number of at most as many digits as there are ``'#'`` characters in the
        sequence marker. The number may have leading zeros, which are ignored for its numerical
        interpretation. Multiple occurrences of the same number is undefined behavior (can happen
        in case of leading zeros).

        Images without sequences marker are treated as a single frame with frame number 0. Images
        without uv-tileset marker are treated as a single uv-tile (per frame) with u- and
        v-coordinates of 0.

        :type filename: string
        :param filename:       The filename of the image to load.
        :type selector: string, optional
        :param selector:       The selector, or ``NULL``. See section 2.3.1 in ['MDLLS]' for
                                  details.
        :rtype: int
        :return: 
                                  -  0: Success.
                                  - -1: Invalid parameters (``NULL`` pointer).
                                  - -2: Failure to resolve the given filename, e.g., the file does not
                                        exist.
                                  - -3: Failure to open the file.
                                  - -4: No image plugin found to handle the file.
                                  - -5: The image plugin failed to import the file.

        See also: #mi::neuraylib::IMdl_factory::create_texture() for a way to create a texture based
             on an MDL file path instead of a filename.
        """
        return _pymdlsdk.IImage_reset_file(self, filename, selector)

    def reset_reader(self, *args):
        r"""
        *Overload 1:*
        Sets the image to the data provided by a reader.

        :type reader: mi::neuraylib::IReader
        :param reader:         The reader that provides the data for the image. The reader needs to
                                  support absolute access.
        :type image_format: string
        :param image_format:   The image format of the data, e.g., ``"jpg"``. Note that support for a
                                  given image format requires an image plugin capable of handling that
                                  format.
        :type selector: string, optional
        :param selector:       The selector, or ``NULL``. See section 2.3.1 in ['MDLLS]' for
                                  details.
        :rtype: int
        :return: 
                                  -  0: Success.
                                  - -1: Invalid parameters (``NULL`` pointer).
                                  - -3: The reader does not support absolute access.
                                  - -4: No image plugin found to handle the data.
                                  - -5: The image plugin failed to import the data.

        |

        *Overload 2:*
        Sets the image to the frame/uv-tile data provided by an array of readers.

        :type reader: :py:class:`IArray`
        :param reader:         A static or dynamic array of structures of type ``Uvtile_reader``. Such
                                  a structure has the following members:
                                  - #mi::Sint32 **u**

                                    The u-coordinate of this uv-tile.
                                  - #mi::Sint32 **v**

                                    The v-coordinate of this uv-tile.
                                  - #mi::Size **frame**

                                    The frame number of this uv-tile.
                                  - #mi::neuraylib::IReader* **reader**

                                    The reader that provides the data for this uv-tile. The reader needs
                                    to support absolute access.
        :type image_format: string
        :param image_format:   The image format of the data, e.g., ``"jpg"``. Note that support for a
                                  given image format requires an image plugin capable of handling that
                                  format.
        :type selector: string, optional
        :param selector:       The selector, or ``NULL``. See section 2.3.1 in ['MDLLS]' for
                                  details.
        :rtype: int
        :return: 
                                  -  0: Success.
                                  - -1: Invalid parameters (``NULL`` pointer).
                                  - -3: Failure to obtain canvases from the readers (possible reasons
                                        are the reader does not support absolute access, no image plugin
                                        found to handle the data, the image plugin failed to import the
                                        data, and repeated u/v coordinates (per frame)).

        |

        *Overload 3:*
        Sets the image to the frame/uv-tile data provided by an array of readers.

        :type reader: :py:class:`IArray`
        :param reader:         A static or dynamic array of structures of type ``Uvtile_reader``. Such
                                  a structure has the following members:
                                  - #mi::Sint32 **u**

                                    The u-coordinate of this uv-tile.
                                  - #mi::Sint32 **v**

                                    The v-coordinate of this uv-tile.
                                  - #mi::Size **frame**

                                    The frame number of this uv-tile.
                                  - #mi::neuraylib::IReader* **reader**

                                    The reader that provides the data for this uv-tile. The reader needs
                                    to support absolute access.
        :type image_format: string
        :param image_format:   The image format of the data, e.g., ``"jpg"``. Note that support for a
                                  given image format requires an image plugin capable of handling that
                                  format.
        :param selector:       The selector, or ``NULL``. See section 2.3.1 in ['MDLLS]' for
                                  details.
        :rtype: int
        :return: 
                                  -  0: Success.
                                  - -1: Invalid parameters (``NULL`` pointer).
                                  - -3: Failure to obtain canvases from the readers (possible reasons
                                        are the reader does not support absolute access, no image plugin
                                        found to handle the data, the image plugin failed to import the
                                        data, and repeated u/v coordinates (per frame)).
        """
        return _pymdlsdk.IImage_reset_reader(self, *args)

    def set_from_canvas(self, *args):
        r"""
        *Overload 1:*
        Sets the image to the passed canvas (possibly sharing the pixel data).

        :type canvas: :py:class:`ICanvas`
        :param canvas:   The pixel data to be used by this image.
        :type shared: boolean, optional
        :param shared:   If ``false`` (the default), the pixel data is copied from ``canvas`` and the
                            method does the same as
                            #mi::neuraylib::IImage::set_from_canvas(const mi::neuraylib::ICanvas*).
                            If set to ``true``, the image uses the canvas directly (doing reference
                            counting on the canvas pointer). You must not modify the canvas content
                            after this call.
        :rtype: boolean
        :return: ``true`` if the pixel data of this image has been set correctly, and
                            ``false`` otherwise.

        |

        *Overload 2:*
        Sets the frames/uv-tiles of this image based to the passed canvases (possibly sharing the
        pixel data).

        :type uvtiles: :py:class:`IArray`
        :param uvtiles:  A static or dynamic array of structures of type ``Uvtile``. Such a structure
                            has the following members:
                            - #mi::Sint32 **u**

                              The u-coordinate of this uv-tile.
                            - #mi::Sint32 **v**

                              The v-coordinate of this uv-tile.
                            - #mi::Size **frame**

                              The frame number of this uv-tile.
                            - #mi::neuraylib::ICanvas* **canvas**

                              The pixel data to be used for this image.
        :type shared: boolean, optional
        :param shared:   If ``false`` (the default), the pixel data is copied from ``canvas`` and the
                            method does the same as
                            #mi::neuraylib::IImage::set_from_canvas(const mi::neuraylib::ICanvas*).
                            If set to ``true``, the image uses the canvases directly (doing reference
                            counting on the canvas pointers). You must not modify the canvas contents
                            after this call.
        :rtype: boolean
        :return: ``true`` if the pixel data of this image has been set correctly, and
                            ``false`` otherwise.
        """
        return _pymdlsdk.IImage_set_from_canvas(self, *args)

    def is_animated(self):
        r"""
        Indicates whether this image represents an animated texture.

        The return value ``false`` implies that there is a single frame with frame number 0.
        """
        return _pymdlsdk.IImage_is_animated(self)

    def get_length(self):
        r""" Returns the number of frames of this image. Never zero."""
        return _pymdlsdk.IImage_get_length(self)

    def get_frame_number(self, frame_id):
        r"""
        Returns the frame number for a give frame ID.

        This function is strictly monotonically increasing. Frame numbers are not necessarily
        consecutive, there can be missing frame numbers.

        :type frame_id: int
        :param frame_id:    The frame ID of the frame.
        :rtype: int
        :return: The frame number, or -1 if ``frame_id`` is out of bounds.
        """
        return _pymdlsdk.IImage_get_frame_number(self, frame_id)

    def get_frame_id(self, frame_number):
        r"""
        Returns the frame ID for a given frame number.

        :type frame_number: int
        :param frame_number:   The frame number of the frame.
        :rtype: int
        :return: The frame ID, or -1 if ``frame_number`` is not a valid frame number.
        """
        return _pymdlsdk.IImage_get_frame_id(self, frame_number)

    def is_uvtile(self):
        r"""
        Indicates whether this image represents a uvtile sequence.

        The return value ``false`` implies that there is a single uv-tile (per frame) with u- and v-
        coordinates of 0.
        """
        return _pymdlsdk.IImage_is_uvtile(self)

    def get_frame_length(self, frame_id):
        r""" Returns the number of uv-tiles for a given frame (or 0 if ``frame_id`` is out of bounds)."""
        return _pymdlsdk.IImage_get_frame_length(self, frame_id)

    def get_uvtile_uv(self, frame_id, uvtile_id, u, v):
        r"""
        Returns the u- and v- coordinates corresponding to a uv-tile ID.

        :type frame_id: int
        :param frame_id:    The frame ID of the frame.
        :type uvtile_id: int
        :param uvtile_id:   The uv-tile ID of the uv-tile.
        :type u: int
        :param u:           The u-coordinate of the uv-tile.
        :type v: int
        :param v:           The v-coordinate of the uv-tile.
        :rtype: int
        :return: 0 on success, -1 if ``uvtile_id`` is out of range.
        """
        return _pymdlsdk.IImage_get_uvtile_uv(self, frame_id, uvtile_id, u, v)

    def get_uvtile_id(self, frame_id, u, v):
        r"""
        Returns the uv-tile ID corresponding to u- and v-coordinates.

        :type frame_id: int
        :param frame_id:    The frame ID of the frame.
        :type u: int
        :param u:           The u-coordinate of the uv-tile.
        :type v: int
        :param v:           The v-coordinate of the uv-tile..
        :rtype: int
        :return: The uv-tile ID, or -1 of there is no uv-tile with the given coordinates.
        """
        return _pymdlsdk.IImage_get_uvtile_id(self, frame_id, u, v)

    def get_uvtile_uv_ranges(self, frame_id, min_u, min_v, max_u, max_v):
        r"""
        Returns the ranges of u- and v-coordinates.

        :type frame_id: int
        :param frame_id:    The frame ID of the frame.
        :type min_u: int, out
        :param min_u:  Smallest u-coordinate for that frame.
        :type min_v: int, out
        :param min_v:  Smallest v-coordinate for that frame.
        :type max_u: int, out
        :param max_u:  Largest u-coordinate for that frame.
        :type max_v: int, out
        :param max_v:  Largest v-coordinate for that frame.
        """
        return _pymdlsdk.IImage_get_uvtile_uv_ranges(self, frame_id, min_u, min_v, max_u, max_v)

    def get_filename(self, frame_id, uvtile_id):
        r"""
        Returns the resolved file name of a mipmap of the image.

        The method returns ``NULL`` if there is no file associated with the mipmap, e.g., after
        default construction, calls to #set_from_canvas(), or failures to resolve the file name
        passed to #reset_file().

        :type frame_id: int
        :param frame_id:    The frame ID of the mipmap.
        :type uvtile_id: int
        :param uvtile_id:   The uv-tile ID of the mipmap.

        See also: #get_original_filename()
        """
        return _pymdlsdk.IImage_get_filename(self, frame_id, uvtile_id)

    def get_original_filename(self):
        r"""
        Returns the unresolved file as passed to #reset_file().

        The method returns ``NULL`` after default construction or calls to #set_from_canvas().

        See also: #get_filename()
        """
        return _pymdlsdk.IImage_get_original_filename(self)

    def get_selector(self):
        r""" Returns the selector (or ``NULL)``."""
        return _pymdlsdk.IImage_get_selector(self)

    def get_canvas(self, frame_id, uvtile_id, level):
        r"""
        Returns a canvas with the pixel data of the image.

        Note that it is not possible to manipulate the pixel data.

        :type frame_id: int
        :param frame_id:    The frame ID of the canvas.
        :type uvtile_id: int
        :param uvtile_id:   The uv-tile ID of the canvas.
        :type level: int
        :param level:       The desired mipmap level. Level 0 is the highest resolution.
        :rtype: :py:class:`ICanvas`
        :return: A canvas pointing to the pixel data of the image, or ``NULL`` in case of
                               failure, e.g., because of an invalid uv-tile ID.
        """
        return _pymdlsdk.IImage_get_canvas(self, frame_id, uvtile_id, level)

    def get_type(self, frame_id, uvtile_id):
        r"""
        Returns the pixel type of a mipmap.

        :type frame_id: int
        :param frame_id:    The frame ID of the mipmap.
        :type uvtile_id: int
        :param uvtile_id:   The uv-tile ID of the mipmap to get the pixel type for.
        :rtype: string
        :return: The pixel type, or ``NULL`` in case of an invalid frame ID or uv-tile ID.

        See 'mi_neuray_types' for a list of supported pixel types.
        """
        return _pymdlsdk.IImage_get_type(self, frame_id, uvtile_id)

    def get_levels(self, frame_id, uvtile_id):
        r"""
        Returns the number of levels in the mipmap pyramid.

        :type frame_id: int
        :param frame_id:    The frame ID of the mipmap.
        :type uvtile_id: int
        :param uvtile_id:   The uv-tile ID of the mipmap to get the number of levels for.
        :rtype: int
        :return: The number of levels, or -1 in case of an invalid frame ID or uv-tile ID.
        """
        return _pymdlsdk.IImage_get_levels(self, frame_id, uvtile_id)

    def resolution_x(self, frame_id, uvtile_id, level):
        r"""
        Returns the horizontal resolution of a canvas.

        :type frame_id: int
        :param frame_id:    The frame ID of the canvas.
        :type uvtile_id: int
        :param uvtile_id:   The uv-tile ID of the canvas to get the resolution for.
        :type level: int
        :param level:       The desired mipmap level. Level 0 is the highest resolution.
        :rtype: int
        :return: The horizontal resolution, or -1 in case of an invalid frame ID,
                               uv-tile ID, or level.
        """
        return _pymdlsdk.IImage_resolution_x(self, frame_id, uvtile_id, level)

    def resolution_y(self, frame_id, uvtile_id, level):
        r"""
        Returns the vertical resolution of a canvas.

        :type frame_id: int
        :param frame_id:    The frame ID of the canvas.
        :type uvtile_id: int
        :param uvtile_id:   The uv-tile ID of the canvas to get the resolution for.
        :type level: int
        :param level:       The desired mipmap level. Level 0 is the highest resolution.
        :rtype: int
        :return: The vertical resolution, or -1 in case of an invalid frame ID,
                               uv-tile ID, or level.
        """
        return _pymdlsdk.IImage_resolution_y(self, frame_id, uvtile_id, level)

    def resolution_z(self, frame_id, uvtile_id, level):
        r"""
        Returns the number of layers of a canvas.

        :type frame_id: int
        :param frame_id:    The frame ID of the canvas.
        :type uvtile_id: int
        :param uvtile_id:   The uv-tile ID of the canvas to get the resolution for.
        :type level: int
        :param level:       The desired mipmap level. Level 0 is the highest resolution.
        :rtype: int
        :return: The number of layers, or -1 in case of an invalid frame ID,
                               uv-tile ID, or level.
        """
        return _pymdlsdk.IImage_resolution_z(self, frame_id, uvtile_id, level)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IImage_compare_iid(self, iid)

    def get_element_type(self):
        r""" Indicates the actual scene element represented by interfaces derived from this interface."""
        return _pymdlsdk.IImage_get_element_type(self)

    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk.IImage_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk.IImage_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IImage_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IImage_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk.IImage_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk.IImage_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk.IImage_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk.IImage_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk.IImage_enumerate_attributes(self, index)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IImage__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IImage__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IImage_get_iid(self)

# Register IImage in _pymdlsdk:
_pymdlsdk.IImage_swigregister(IImage)

def IImage_IID():
    return _pymdlsdk.IImage_IID()

def IImage__get_interface(iface):
    return _pymdlsdk.IImage__get_interface(iface)

class ILightprofile(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.ILightprofile_swiginit(self, _pymdlsdk.new_ILightprofile(*args))
    __swig_destroy__ = _pymdlsdk.delete_ILightprofile

    def __deref__(self):
        return _pymdlsdk.ILightprofile___deref__(self)

    def __ref__(self):
        return _pymdlsdk.ILightprofile___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.ILightprofile_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.ILightprofile___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.ILightprofile___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.ILightprofile_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.ILightprofile_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.ILightprofile__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def reset_file(self, *args):
        r"""
        Sets the light profile to a file identified by ``filename``.

        :type filename: string
        :param filename:           The new file containing the light profile data.
        :type resolution_phi: int, optional
        :param resolution_phi:     The desired resolution of the equidistant grid in phi-direction.


                                      The special value 0 leaves the choice of a suitable resolution to
                                      the implementation. Currently, the implementation behaves as
                                      follows: If the angles in phi-direction are already equidistant,
                                      the resolution in the file itself (after unfolding of symmetries)
                                      is kept unchanged. If the angles in phi-direction are not
                                      equidistant, a suitable resolution that maintains the angles given
                                      in the file is chosen. If that fails, a fixed resolution is
                                      chosen.
        :type resolution_theta: int, optional
        :param resolution_theta:   The desired resolution of the equidistant grid in theta-direction.


                                      The special value 0 leaves the choice of a suitable resolution to
                                      the implementation. Currently, the implementation behaves as
                                      follows: If the angles in theta-direction are already equidistant,
                                      the resolution in the file itself (after unfolding of symmetries)
                                      is kept unchanged. If the angles in theta-direction are not
                                      equidistant, a suitable resolution that maintains the angles given
                                      in the file is chosen. If that fails, a fixed resolution is
                                      chosen.
        :type degree: int, optional
        :param degree:             The interpolation method to use.
        :type flags: int, optional
        :param flags:              Flags to be used when interpreting the file data,
                                      see #mi::neuraylib::Lightprofile_flags for details.
        :rtype: int
        :return: 
                                      -  0: Success.
                                      - -1: Invalid parameters (``NULL`` pointer).
                                      - -2: Failure to resolve the given filename, e.g., the file does
                                            not exist.
                                      - -3: ``degree`` or ``flags`` is invalid (exactly one of
                                            #mi::neuraylib::LIGHTPROFILE_CLOCKWISE or
                                            #mi::neuraylib::LIGHTPROFILE_COUNTER_CLOCKWISE must be set).
                                      - -4: File format error.
                                      - -5: ``resolution_phi`` or ``resolution_theta`` is invalid (must
                                            not be 1).

        See also: #mi::neuraylib::IMdl_factory::create_light_profile() for a way to create a light
             profile based on an MDL file path instead of a filename.
        """
        return _pymdlsdk.ILightprofile_reset_file(self, *args)

    def reset_reader(self, *args):
        r"""
        Sets the light profile to the data provided by a reader.

        :type reader: mi::neuraylib::IReader
        :param reader:             The reader that provides the data for the BSDF measurement in
                                      ``.ies`` format.
        :type resolution_phi: int, optional
        :param resolution_phi:     The desired resolution of the equidistant grid in phi-direction.


                                      The special value 0 leaves the choice of a suitable resolution to
                                      the implementation. Currently, the implementation behaves as
                                      follows: If the angles in phi-direction are already equidistant,
                                      the resolution in the file itself (after unfolding of symmetries)
                                      is kept unchanged. If the angles in phi-direction are not
                                      equidistant, a suitable resolution that maintains the angles given
                                      in the file is chosen. If that fails, a fixed resolution is
                                      chosen.
        :type resolution_theta: int, optional
        :param resolution_theta:   The desired resolution of the equidistant grid in theta-direction.


                                      The special value 0 leaves the choice of a suitable resolution to
                                      the implementation. Currently, the implementation behaves as
                                      follows: If the angles in theta-direction are already equidistant,
                                      the resolution in the file itself (after unfolding of symmetries)
                                      is kept unchanged. If the angles in theta-direction are not
                                      equidistant, a suitable resolution that maintains the angles given
                                      in the file is chosen. If that fails, a fixed resolution is
                                      chosen.
        :type degree: int, optional
        :param degree:             The interpolation method to use.
        :type flags: int, optional
        :param flags:              Flags to be used when interpreting the data,
                                      see #mi::neuraylib::Lightprofile_flags for details.
        :rtype: int
        :return: 
                                      -  0: Success.
                                      - -1: Invalid parameters (``NULL`` pointer).
                                      - -3: ``degree`` or ``flags`` is invalid (exactly one of
                                            #mi::neuraylib::LIGHTPROFILE_CLOCKWISE or
                                            #mi::neuraylib::LIGHTPROFILE_COUNTER_CLOCKWISE must be set).
                                      - -4: File format error.
                                      - -5: ``resolution_phi`` or ``resolution_theta`` is invalid (must
                                            not be 1).
        """
        return _pymdlsdk.ILightprofile_reset_reader(self, *args)

    def get_filename(self):
        r"""
        Returns the resolved file name of the file containing the light profile.

        The method returns ``NULL`` if there is no file associated with the light profile, e.g.,
        after default construction or failures to resolve the file name passed to #reset_file().

        See also: #get_original_filename()
        """
        return _pymdlsdk.ILightprofile_get_filename(self)

    def get_original_filename(self):
        r"""
        Returns the unresolved file name as passed to #reset_file().

        The method returns ``NULL`` after default construction.

        See also: #get_filename()
        """
        return _pymdlsdk.ILightprofile_get_original_filename(self)

    def get_resolution_phi(self):
        r""" Returns the resolution of the grid in phi-direction, or 0 after default construction."""
        return _pymdlsdk.ILightprofile_get_resolution_phi(self)

    def get_resolution_theta(self):
        r""" Returns the resolution of the grid in theta-direction, or 0 after default construction."""
        return _pymdlsdk.ILightprofile_get_resolution_theta(self)

    def get_degree(self):
        r"""
        Returns the interpolation degree that was used to interpolate the grid data, or
        #mi::neuraylib::LIGHTPROFILE_HERMITE_BASE_1 after default construction.
        """
        return _pymdlsdk.ILightprofile_get_degree(self)

    def get_flags(self):
        r"""
        Returns flags that were used to interpret the light profile data in the file, or
        #mi::neuraylib::LIGHTPROFILE_COUNTER_CLOCKWISE after default construction.

        See also: #mi::neuraylib::Lightprofile_flags.
        """
        return _pymdlsdk.ILightprofile_get_flags(self)

    def get_phi(self, index):
        r"""
        Returns the ``index`` -th phi value.

        Note that the grid is an equidistant grid, i.e., the distance between subsequent phi values
        is always the same. If ``index`` is out of bounds or after default construction, 0 is
        returned.
        """
        return _pymdlsdk.ILightprofile_get_phi(self, index)

    def get_theta(self, index):
        r"""
        Returns the ``index`` -th theta value.

        Note that the grid is an equidistant grid, i.e., the distance between subsequent theta
        values is always the same. If ``index`` is out of bounds or after default construction, 0 is
        returned.
        """
        return _pymdlsdk.ILightprofile_get_theta(self, index)

    def get_data(self, *args):
        r"""
        *Overload 1:*
        Returns the normalized data of the entire grid.

        :rtype: float
        :return: A pointer to the normalized data for all vertices of the grid. The data values are
                      stored as array in column-major order (where all elements of a column have the
                      same phi value). Returns ``NULL`` after default construction.

        See also: #get_candela_multiplier()

        |

        *Overload 2:*
        Returns the normalized data for a grid vertex.

        :type index_phi: int
        :param index_phi:     Index in phi-direction of the vertex.
        :type index_theta: int
        :param index_theta:   Index in theta-direction of the vertex.
        :rtype: float
        :return: The normalized data for the grid point, or 0 in case of errors or after
                                 default construction.

        See also: #get_candela_multiplier(), #sample()
        """
        return _pymdlsdk.ILightprofile_get_data(self, *args)

    def get_candela_multiplier(self):
        r"""
        Returns the normalization factor.

        All data is normalized such that the maximum is 1.0. The values returned by methods like
        #get_data() need to be multiplied by this normalization factor to retrieve the true value.
        Returns 0 after default construction.
        """
        return _pymdlsdk.ILightprofile_get_candela_multiplier(self)

    def sample(self, phi, theta, candela):
        r"""
        Samples the light profile.

        The method computes a bi-linear interpolation of the light profile at (phi,theta) according
        to the resolution.

        :type phi: float
        :param phi:       First dimension of sample point.
        :type theta: float
        :param theta:     Second dimension of sample point.
        :type candela: boolean
        :param candela:   If ``false``, normalized values are returned, otherwise true values.
                             See #get_candela_multiplier().
        :rtype: float
        :return: The computed sample value, or 0 in case of errors or after default
                             construction.

        See also: #get_data()
        """
        return _pymdlsdk.ILightprofile_sample(self, phi, theta, candela)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.ILightprofile_compare_iid(self, iid)

    def get_element_type(self):
        r""" Indicates the actual scene element represented by interfaces derived from this interface."""
        return _pymdlsdk.ILightprofile_get_element_type(self)

    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk.ILightprofile_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk.ILightprofile_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.ILightprofile_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.ILightprofile_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk.ILightprofile_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk.ILightprofile_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk.ILightprofile_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk.ILightprofile_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk.ILightprofile_enumerate_attributes(self, index)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.ILightprofile__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.ILightprofile__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.ILightprofile_get_iid(self)

# Register ILightprofile in _pymdlsdk:
_pymdlsdk.ILightprofile_swigregister(ILightprofile)

def ILightprofile_IID():
    return _pymdlsdk.ILightprofile_IID()

def ILightprofile__get_interface(iface):
    return _pymdlsdk.ILightprofile__get_interface(iface)

class IMaterial_definition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IMaterial_definition_swiginit(self, _pymdlsdk.new_IMaterial_definition(*args))
    __swig_destroy__ = _pymdlsdk.delete_IMaterial_definition

    def __deref__(self):
        return _pymdlsdk.IMaterial_definition___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IMaterial_definition___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IMaterial_definition_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IMaterial_definition___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IMaterial_definition___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IMaterial_definition_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IMaterial_definition_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IMaterial_definition__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_module(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_module().
        """
        return _pymdlsdk.IMaterial_definition_get_module(self)

    def get_mdl_name(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_mdl_name().
        """
        return _pymdlsdk.IMaterial_definition_get_mdl_name(self)

    def get_mdl_module_name(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_mdl_module_name().
        """
        return _pymdlsdk.IMaterial_definition_get_mdl_module_name(self)

    def get_mdl_simple_name(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_mdl_simple_name().
        """
        return _pymdlsdk.IMaterial_definition_get_mdl_simple_name(self)

    def get_mdl_parameter_type_name(self, index):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_mdl_parameter_type_name().
        """
        return _pymdlsdk.IMaterial_definition_get_mdl_parameter_type_name(self, index)

    def get_prototype(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_prototype().
        """
        return _pymdlsdk.IMaterial_definition_get_prototype(self)

    def get_mdl_version(self, since, removed):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_mdl_version().
        """
        return _pymdlsdk.IMaterial_definition_get_mdl_version(self, since, removed)

    def get_semantic(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_semantic().
        """
        return _pymdlsdk.IMaterial_definition_get_semantic(self)

    def is_exported(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::is_exported().
        """
        return _pymdlsdk.IMaterial_definition_is_exported(self)

    def get_return_type(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_return_type().
        """
        return _pymdlsdk.IMaterial_definition_get_return_type(self)

    def get_parameter_count(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_parameter_count().
        """
        return _pymdlsdk.IMaterial_definition_get_parameter_count(self)

    def get_parameter_name(self, index):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_parameter_name().
        """
        return _pymdlsdk.IMaterial_definition_get_parameter_name(self, index)

    def get_parameter_index(self, name):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_parameter_index().
        """
        return _pymdlsdk.IMaterial_definition_get_parameter_index(self, name)

    def get_parameter_types(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_parameter_types().
        """
        return _pymdlsdk.IMaterial_definition_get_parameter_types(self)

    def get_defaults(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_defaults().
        """
        return _pymdlsdk.IMaterial_definition_get_defaults(self)

    def get_enable_if_conditions(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_enable_if_conditions().
        """
        return _pymdlsdk.IMaterial_definition_get_enable_if_conditions(self)

    def get_enable_if_users(self, index):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_enable_if_users().
        """
        return _pymdlsdk.IMaterial_definition_get_enable_if_users(self, index)

    def get_enable_if_user(self, index, u_index):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_enable_if_user().
        """
        return _pymdlsdk.IMaterial_definition_get_enable_if_user(self, index, u_index)

    def get_annotations(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_annotations().
        """
        return _pymdlsdk.IMaterial_definition_get_annotations(self)

    def get_return_annotations(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_return_annotations().
        """
        return _pymdlsdk.IMaterial_definition_get_return_annotations(self)

    def get_parameter_annotations(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_parameter_annotations().
        """
        return _pymdlsdk.IMaterial_definition_get_parameter_annotations(self)

    def get_thumbnail(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_thumbnail().
        """
        return _pymdlsdk.IMaterial_definition_get_thumbnail(self)

    def is_valid(self, context):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::is_valid().
        """
        return _pymdlsdk.IMaterial_definition_is_valid(self, context)

    def get_body(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_body().
        """
        return _pymdlsdk.IMaterial_definition_get_body(self)

    def get_temporary_count(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_temporary_count().
        """
        return _pymdlsdk.IMaterial_definition_get_temporary_count(self)

    def get_temporary(self, index):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_temporary().
        """
        return _pymdlsdk.IMaterial_definition_get_temporary(self, index)

    def get_temporary_name(self, index):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::get_temporary_name().
        """
        return _pymdlsdk.IMaterial_definition_get_temporary_name(self, index)

    def create_material_instance_with_ret(self, arguments):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::create_function_call().
        """
        return _pymdlsdk.IMaterial_definition_create_material_instance_with_ret(self, arguments)

    def create_material_instance(self, arguments):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_definition::create_function_call().
        """
        return _pymdlsdk.IMaterial_definition_create_material_instance(self, arguments)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IMaterial_definition_compare_iid(self, iid)

    def get_element_type(self):
        r""" Indicates the actual scene element represented by interfaces derived from this interface."""
        return _pymdlsdk.IMaterial_definition_get_element_type(self)

    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk.IMaterial_definition_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk.IMaterial_definition_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IMaterial_definition_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IMaterial_definition_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk.IMaterial_definition_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk.IMaterial_definition_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk.IMaterial_definition_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk.IMaterial_definition_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk.IMaterial_definition_enumerate_attributes(self, index)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IMaterial_definition__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IMaterial_definition__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IMaterial_definition_get_iid(self)

# Register IMaterial_definition in _pymdlsdk:
_pymdlsdk.IMaterial_definition_swigregister(IMaterial_definition)

def IMaterial_definition_IID():
    return _pymdlsdk.IMaterial_definition_IID()

def IMaterial_definition__get_interface(iface):
    return _pymdlsdk.IMaterial_definition__get_interface(iface)

class IMaterial_instance(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IMaterial_instance_swiginit(self, _pymdlsdk.new_IMaterial_instance(*args))
    __swig_destroy__ = _pymdlsdk.delete_IMaterial_instance

    def __deref__(self):
        return _pymdlsdk.IMaterial_instance___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IMaterial_instance___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IMaterial_instance_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IMaterial_instance___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IMaterial_instance___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IMaterial_instance_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IMaterial_instance_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IMaterial_instance__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def create_compiled_material(self, flags, context=None):
        r"""
        Creates a compiled material.

        :type flags: int
        :param flags:          A bitmask of flags of type #Compilation_options.
        :type context: :py:class:`IMdl_execution_context`, inout, optional
        :param context: An optional pointer to an execution context which can be used to pass
                                  compilation options to the MDL compiler. The following options are
                                  supported for this operation:
                                  - #mi::Float32 "meters_per_scene_unit": The conversion ratio between
                                    meters and scene units for this material. Default: 1.0f.
                                  - #mi::Float32 "wavelength_min": The smallest supported wavelength.
                                    Default: 380.0f.
                                  - #mi::Float32 "wavelength_max": The largest supported wavelength.
                                    Default: 780.0f.
                                  .
                                  The following options are supported in class compilation mode:
                                  - ``bool`` "fold_ternary_on_df": Fold all ternary operators of *df
                                    types. Default: ``false``.
                                  - ``bool`` "fold_all_bool_parameters": Fold all bool parameters.
                                    Default: ``false``.
                                  - ``bool`` "fold_all_enum_parameters": Fold all enum parameters.
                                    Default: ``false``.
                                  - #mi::base::IInterface *"fold_parameters": A static or dynamic array
                                    of strings of the parameters to fold. The names of the parameters
                                    are those that would otherwise be reported in
                                    #mi::neuraylib::ICompiled_material::get_parameter_name().
                                    Default: ``NULL``
                                  - ``bool`` "fold_trivial_cutout_opacity": Fold the expression for
                                    geometry.cutout_opacity if it evaluates to a constant with value
                                    0.0f or 1.0f. Default: ``false``.
                                  - ``bool`` "fold_transparent_layers": Calls to the functions
                                    ``df::weighted_layer()``, ``df::fresnel_layer()``,
                                    ``df::custom_curve_layer()``, ``df::measured_curve_layer()``, and
                                    their equivalents with color weights, are replaced by their
                                    ``base`` argument, if the ``weight`` argument evaluates to a constant
                                    with value 0.0f, and the ``layer`` argument is one of
                                    ``df::diffuse_transmission_bsdf()``, ``df::specular_bsdf()``,
                                    ``df::simple_glossy_bsdf()``, or ``df::microfacet_*_bsdf()``, and
                                    the ``scatter_mode`` argument (if present) is either
                                    ``df::scatter_transmit`` or ``df::scatter_reflect_transmit``.
                                    In addition, the ``layer`` argument might be a combination of such
                                    BSDFs using the ternary operator.
                                  .
                                  During material compilation, messages like errors and warnings will
                                  be passed to the context for later evaluation by the caller. Possible
                                  error conditions:
                                  - Type mismatch, call of an unsuitable DB element, or call cycle in
                                    the graph of this material instance.
                                  - The thin-walled material instance has different transmission for
                                    surface and backface.
                                  - An argument type of the graph of this material instance is varying
                                    but the corresponding parameter type is uniform.
                                  - An element in the array for the context option
                                    "fold_parameters" does not have the type #mi::IString.
        :rtype: :py:class:`ICompiled_material`
        :return: The corresponding compiled material, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IMaterial_instance_create_compiled_material(self, flags, context)

    def get_material_definition(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::get_function_definition().
        """
        return _pymdlsdk.IMaterial_instance_get_material_definition(self)

    def get_mdl_material_definition(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::get_mdl_function_definition().
        """
        return _pymdlsdk.IMaterial_instance_get_mdl_material_definition(self)

    def get_return_type(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::get_return_type().
        """
        return _pymdlsdk.IMaterial_instance_get_return_type(self)

    def get_parameter_count(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::get_parameter_count().
        """
        return _pymdlsdk.IMaterial_instance_get_parameter_count(self)

    def get_parameter_name(self, index):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::get_parameter_name().
        """
        return _pymdlsdk.IMaterial_instance_get_parameter_name(self, index)

    def get_parameter_index(self, name):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::get_parameter_index().
        """
        return _pymdlsdk.IMaterial_instance_get_parameter_index(self, name)

    def get_parameter_types(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::get_parameter_types().
        """
        return _pymdlsdk.IMaterial_instance_get_parameter_types(self)

    def get_arguments(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::get_arguments().
        """
        return _pymdlsdk.IMaterial_instance_get_arguments(self)

    def set_arguments(self, arguments):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::set_arguments().
        """
        return _pymdlsdk.IMaterial_instance_set_arguments(self, arguments)

    def set_argument(self, *args):
        r"""
        *Overload 1:*
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::set_argument(Size,const IExpression*).

        |

        *Overload 2:*
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::set_argument(const char*,const IExpression*).
        """
        return _pymdlsdk.IMaterial_instance_set_argument(self, *args)

    def reset_argument(self, *args):
        r"""
        *Overload 1:*
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::reset_argument(Size).

        |

        *Overload 2:*
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::reset_argument(const char*).
        """
        return _pymdlsdk.IMaterial_instance_reset_argument(self, *args)

    def is_default(self):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::is_default().
        """
        return _pymdlsdk.IMaterial_instance_is_default(self)

    def is_valid(self, context):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::is_valid().
        """
        return _pymdlsdk.IMaterial_instance_is_valid(self, context)

    def repair(self, flags, context):
        r"""
        See 'mi_mdl_materials_are_functions' and
        #mi::neuraylib::IFunction_call::repair().
        """
        return _pymdlsdk.IMaterial_instance_repair(self, flags, context)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IMaterial_instance_compare_iid(self, iid)

    def get_element_type(self):
        r""" Indicates the actual scene element represented by interfaces derived from this interface."""
        return _pymdlsdk.IMaterial_instance_get_element_type(self)

    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk.IMaterial_instance_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk.IMaterial_instance_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IMaterial_instance_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IMaterial_instance_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk.IMaterial_instance_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk.IMaterial_instance_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk.IMaterial_instance_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk.IMaterial_instance_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk.IMaterial_instance_enumerate_attributes(self, index)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IMaterial_instance__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IMaterial_instance__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IMaterial_instance_get_iid(self)

# Register IMaterial_instance in _pymdlsdk:
_pymdlsdk.IMaterial_instance_swigregister(IMaterial_instance)

def IMaterial_instance_IID():
    return _pymdlsdk.IMaterial_instance_IID()

def IMaterial_instance__get_interface(iface):
    return _pymdlsdk.IMaterial_instance__get_interface(iface)

class ITexture(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.ITexture_swiginit(self, _pymdlsdk.new_ITexture(*args))
    __swig_destroy__ = _pymdlsdk.delete_ITexture

    def __deref__(self):
        return _pymdlsdk.ITexture___deref__(self)

    def __ref__(self):
        return _pymdlsdk.ITexture___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.ITexture_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.ITexture___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.ITexture___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.ITexture_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.ITexture_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.ITexture__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def set_image(self, name):
        r"""
        Sets the referenced image.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: There is no element with that name.
                      - -3: The element can not be referenced because it is in a more private scope
                            than the texture.
                      - -4: The element is not an image.
        """
        return _pymdlsdk.ITexture_set_image(self, name)

    def get_image(self):
        r"""
        Returns the referenced image.

        :rtype: string
        :return: The referenced image, or ``NULL`` if no image is referenced.
        """
        return _pymdlsdk.ITexture_get_image(self)

    def set_volume(self, name):
        r"""
        Sets the referenced volume.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: There is no element with that name.
                      - -3: The element can not be referenced because it is in a more private scope
                            than the texture.
                      - -4: The element is not a volume.
        """
        return _pymdlsdk.ITexture_set_volume(self, name)

    def get_volume(self):
        r"""
        Returns the referenced volume data.

        :rtype: string
        :return: The referenced volume, or ``NULL`` if no volume is referenced.
        """
        return _pymdlsdk.ITexture_get_volume(self)

    def set_gamma(self, gamma):
        r"""
        Sets the gamma value of this texture.

        The gamma value of the texture is an override for the gamma value of the underlying
        image. The special value 0.0 means that the override is not set.

        This override value is also used when MDL source code is to be generated:
        - a value of 1.0 is converted to ``"::tex::gamma_linear"``,
        - a value of 2.2 is converted to ``"::tex::gamma_srgb"``, and
        - all other values are converted to ``"::tex::gamma_default"``.
        Therefore, if you want to avoid ``"::tex::gamma_default"`` in generated MDL source code, it
        makes sense to replicate the gamma value of the underlying image here (instead of not using
        the override).

        See also: #get_gamma(), #get_effective_gamma()
        """
        return _pymdlsdk.ITexture_set_gamma(self, gamma)

    def get_gamma(self):
        r"""
        Returns the gamma value of this texture.

        See also: #set_gamma(), #get_effective_gamma()
        """
        return _pymdlsdk.ITexture_get_gamma(self)

    def get_effective_gamma(self, frame_id, uvtile_id):
        r"""
        Returns the effective gamma value.

        Returns the gamma value of this texture, unless no override is set. In this case the gamma
        value of the underlying image at the given frame and uvtile index is returned. If no such
        image exists, 0.0 is returned.

        :type frame_id: int
        :param frame_id:    The frame ID of the mipmap the gamma value is requested for when no
                               override is set.
        :type uvtile_id: int
        :param uvtile_id:   The uv-tile id of the mipmap the gamma value is requested for when no
                               override is set.

        See also: #set_gamma(), #get_gamma()
        """
        return _pymdlsdk.ITexture_get_effective_gamma(self, frame_id, uvtile_id)

    def get_selector(self):
        r""" Returns the selector (or ``NULL)``."""
        return _pymdlsdk.ITexture_get_selector(self)

    def set_compression(self, compression):
        r"""
        Sets the texture compression method.

        Notes: This setting does not affect the referenced image itself, it only affects image data
              that has been processed by the render modes. For example, in order to save GPU memory
              processed image data can be compressed before being uploaded to the GPU.

        See also: #mi::neuraylib::Texture_compression
        """
        return _pymdlsdk.ITexture_set_compression(self, compression)

    def get_compression(self):
        r"""
        Returns the texture compression method.

        Notes: This setting does not affect the referenced image itself, it only affects image data
              that has been processed by the render modes. For example, in order to save GPU memory
              processed image data can be compressed before being uploaded to the GPU.

        See also: #mi::neuraylib::Texture_compression
        """
        return _pymdlsdk.ITexture_get_compression(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.ITexture_compare_iid(self, iid)

    def get_element_type(self):
        r""" Indicates the actual scene element represented by interfaces derived from this interface."""
        return _pymdlsdk.ITexture_get_element_type(self)

    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk.ITexture_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk.ITexture_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.ITexture_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.ITexture_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk.ITexture_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk.ITexture_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk.ITexture_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk.ITexture_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk.ITexture_enumerate_attributes(self, index)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.ITexture__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.ITexture__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.ITexture_get_iid(self)

# Register ITexture in _pymdlsdk:
_pymdlsdk.ITexture_swigregister(ITexture)

def ITexture_IID():
    return _pymdlsdk.ITexture_IID()

def ITexture__get_interface(iface):
    return _pymdlsdk.ITexture__get_interface(iface)

class ITile(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.ITile_swiginit(self, _pymdlsdk.new_ITile(*args))
    __swig_destroy__ = _pymdlsdk.delete_ITile

    def __deref__(self):
        return _pymdlsdk.ITile___deref__(self)

    def __ref__(self):
        return _pymdlsdk.ITile___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.ITile_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.ITile___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.ITile___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.ITile_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.ITile_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.ITile__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_pixel(self, *args):
        return _pymdlsdk.ITile_get_pixel(self, *args)

    def set_pixel(self, *args):
        return _pymdlsdk.ITile_set_pixel(self, *args)

    def get_type(self):
        r"""
        Returns the pixel type used by the tile.

        See also: 'mi_neuray_types' for a list of supported pixel types
        """
        return _pymdlsdk.ITile_get_type(self)

    def get_resolution_x(self):
        r""" Returns the tile size in x direction"""
        return _pymdlsdk.ITile_get_resolution_x(self)

    def get_resolution_y(self):
        r""" Returns the tile size in y direction"""
        return _pymdlsdk.ITile_get_resolution_y(self)

    def get_data(self, *args):
        r"""
        *Overload 1:*
        Returns a pointer to the raw tile data according to the pixel type of the tile.

        This methods is used for fast, direct read access to the raw tile data. It is expected that
        the data is stored in row-major layout without any padding. In case of #mi::Color, the
        components are expected to be stored in RGBA order.

        The total size of the buffer in bytes is.. code-block:: c++

           x * y * bpp where ``x`` is the result
        of #get_resolution_x(), ``y`` is the result of #get_resolution_y(), and ``bpp`` is the number
        of bytes per pixel. If not: MDL_SDK_API { The number of bytes per pixel is the product of
        #mi::neuraylib::IImage_api::get_components_per_pixel() and
        #mi::neuraylib::IImage_api::get_bytes_per_component() when passing the result of #get_type()
        as pixel type. }

        |

        *Overload 2:*
        Returns a pointer to the raw tile data according to the pixel type of the tile.

        This methods is used for fast, direct write access to the raw tile data. It is expected that
        the data is stored in row-major layout without any padding. In case of #mi::Color, the
        components are expected to be stored in RGBA order.

        The total size of the buffer in bytes is.. code-block:: c++

           x * y * bpp where ``x`` is the result
        of #get_resolution_x(), ``y`` is the result of #get_resolution_y(), and ``bpp`` is the number
        of bytes per pixel. If not: MDL_SDK_API { The number of bytes per pixel is the product of
        #mi::neuraylib::IImage_api::get_components_per_pixel() and
        #mi::neuraylib::IImage_api::get_bytes_per_component() when passing the result of #get_type()
        as pixel type. }
        """
        return _pymdlsdk.ITile_get_data(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.ITile_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.ITile__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.ITile__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.ITile_get_iid(self)

# Register ITile in _pymdlsdk:
_pymdlsdk.ITile_swigregister(ITile)

def ITile_IID():
    return _pymdlsdk.ITile_IID()

def ITile__get_interface(iface):
    return _pymdlsdk.ITile__get_interface(iface)

class IType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_swiginit(self, _pymdlsdk.new_IType(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType

    def __deref__(self):
        return _pymdlsdk.IType___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    class Kind(Enum) :
        TK_ALIAS = _pymdlsdk._IType_TK_ALIAS
        TK_BOOL = _pymdlsdk._IType_TK_BOOL
        TK_INT = _pymdlsdk._IType_TK_INT
        TK_ENUM = _pymdlsdk._IType_TK_ENUM
        TK_FLOAT = _pymdlsdk._IType_TK_FLOAT
        TK_DOUBLE = _pymdlsdk._IType_TK_DOUBLE
        TK_STRING = _pymdlsdk._IType_TK_STRING
        TK_VECTOR = _pymdlsdk._IType_TK_VECTOR
        TK_MATRIX = _pymdlsdk._IType_TK_MATRIX
        TK_COLOR = _pymdlsdk._IType_TK_COLOR
        TK_ARRAY = _pymdlsdk._IType_TK_ARRAY
        TK_STRUCT = _pymdlsdk._IType_TK_STRUCT
        TK_TEXTURE = _pymdlsdk._IType_TK_TEXTURE
        TK_LIGHT_PROFILE = _pymdlsdk._IType_TK_LIGHT_PROFILE
        TK_BSDF_MEASUREMENT = _pymdlsdk._IType_TK_BSDF_MEASUREMENT
        TK_BSDF = _pymdlsdk._IType_TK_BSDF
        TK_HAIR_BSDF = _pymdlsdk._IType_TK_HAIR_BSDF
        TK_EDF = _pymdlsdk._IType_TK_EDF
        TK_VDF = _pymdlsdk._IType_TK_VDF


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_skip_all_type_aliases(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_get_iid(self)

# Register IType in _pymdlsdk:
_pymdlsdk.IType_swigregister(IType)

def IType_IID():
    return _pymdlsdk.IType_IID()

def IType__get_interface(iface):
    return _pymdlsdk.IType__get_interface(iface)

class IType_alias(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_alias_swiginit(self, _pymdlsdk.new_IType_alias(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_alias

    def __deref__(self):
        return _pymdlsdk.IType_alias___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_alias___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_alias_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_alias___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_alias___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_alias_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_alias_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_alias__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def get_aliased_type(self):
        r""" Returns the type aliased by this type."""
        return _pymdlsdk.IType_alias_get_aliased_type(self)

    def get_type_modifiers(self):
        r""" Returns the modifiers of this type."""
        return _pymdlsdk.IType_alias_get_type_modifiers(self)

    def get_symbol(self):
        r""" Returns the qualified name of the type, or ``NULL`` if no such name exists."""
        return _pymdlsdk.IType_alias_get_symbol(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_alias_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_alias__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_alias_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_alias_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_alias__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_alias__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_alias_get_iid(self)

# Register IType_alias in _pymdlsdk:
_pymdlsdk.IType_alias_swigregister(IType_alias)

def IType_alias_IID():
    return _pymdlsdk.IType_alias_IID()

def IType_alias__get_interface(iface):
    return _pymdlsdk.IType_alias__get_interface(iface)

class IType_array(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_array_swiginit(self, _pymdlsdk.new_IType_array(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_array

    def __deref__(self):
        return _pymdlsdk.IType_array___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_array___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_array_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_array___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_array___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_array_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_array_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_array__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def get_element_type(self):
        r""" Returns the type of the array elements."""
        return _pymdlsdk.IType_array_get_element_type(self)

    def is_immediate_sized(self):
        r""" Indicates whether the array is immediate-sized or deferred-sized."""
        return _pymdlsdk.IType_array_is_immediate_sized(self)

    def get_size(self):
        r""" Returns the size of the array in case of immediate-sized arrays, and -1 otherwise."""
        return _pymdlsdk.IType_array_get_size(self)

    def get_deferred_size(self):
        r"""
        Returns the abstract size of the array in case of deferred-sized arrays, and ``NULL``
        otherwise.

        Note that the empty string is a valid return value for deferred-sized arrays.
        """
        return _pymdlsdk.IType_array_get_deferred_size(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_array_compare_iid(self, iid)

    def get_component_type(self, index):
        r""" Returns the component type at ``index``."""
        return _pymdlsdk.IType_array_get_component_type(self, index)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_array__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_array_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_array_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_array__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_array__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_array_get_iid(self)

# Register IType_array in _pymdlsdk:
_pymdlsdk.IType_array_swigregister(IType_array)

def IType_array_IID():
    return _pymdlsdk.IType_array_IID()

def IType_array__get_interface(iface):
    return _pymdlsdk.IType_array__get_interface(iface)

class IType_atomic(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_atomic_swiginit(self, _pymdlsdk.new_IType_atomic(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_atomic

    def __deref__(self):
        return _pymdlsdk.IType_atomic___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_atomic___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_atomic_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_atomic___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_atomic___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_atomic_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_atomic_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_atomic__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_atomic_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_atomic__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_atomic_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_atomic_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_atomic__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_atomic__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_atomic_get_iid(self)

# Register IType_atomic in _pymdlsdk:
_pymdlsdk.IType_atomic_swigregister(IType_atomic)

def IType_atomic_IID():
    return _pymdlsdk.IType_atomic_IID()

def IType_atomic__get_interface(iface):
    return _pymdlsdk.IType_atomic__get_interface(iface)

class IType_bool(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_bool_swiginit(self, _pymdlsdk.new_IType_bool(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_bool

    def __deref__(self):
        return _pymdlsdk.IType_bool___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_bool___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_bool_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_bool___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_bool___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_bool_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_bool_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_bool__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_bool_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_bool__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_bool_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_bool_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_bool__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_bool__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_bool_get_iid(self)

# Register IType_bool in _pymdlsdk:
_pymdlsdk.IType_bool_swigregister(IType_bool)

def IType_bool_IID():
    return _pymdlsdk.IType_bool_IID()

def IType_bool__get_interface(iface):
    return _pymdlsdk.IType_bool__get_interface(iface)

class IType_bsdf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_bsdf_swiginit(self, _pymdlsdk.new_IType_bsdf(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_bsdf

    def __deref__(self):
        return _pymdlsdk.IType_bsdf___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_bsdf___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_bsdf_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_bsdf___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_bsdf___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_bsdf_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_bsdf_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_bsdf__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_bsdf_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_bsdf__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_bsdf_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_bsdf_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_bsdf__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_bsdf__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_bsdf_get_iid(self)

# Register IType_bsdf in _pymdlsdk:
_pymdlsdk.IType_bsdf_swigregister(IType_bsdf)

def IType_bsdf_IID():
    return _pymdlsdk.IType_bsdf_IID()

def IType_bsdf__get_interface(iface):
    return _pymdlsdk.IType_bsdf__get_interface(iface)

class IType_bsdf_measurement(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_bsdf_measurement_swiginit(self, _pymdlsdk.new_IType_bsdf_measurement(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_bsdf_measurement

    def __deref__(self):
        return _pymdlsdk.IType_bsdf_measurement___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_bsdf_measurement___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_bsdf_measurement_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_bsdf_measurement___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_bsdf_measurement___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_bsdf_measurement_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_bsdf_measurement_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_bsdf_measurement__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_bsdf_measurement_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_bsdf_measurement__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_bsdf_measurement_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_bsdf_measurement_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_bsdf_measurement__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_bsdf_measurement__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_bsdf_measurement_get_iid(self)

# Register IType_bsdf_measurement in _pymdlsdk:
_pymdlsdk.IType_bsdf_measurement_swigregister(IType_bsdf_measurement)

def IType_bsdf_measurement_IID():
    return _pymdlsdk.IType_bsdf_measurement_IID()

def IType_bsdf_measurement__get_interface(iface):
    return _pymdlsdk.IType_bsdf_measurement__get_interface(iface)

class IType_color(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_color_swiginit(self, _pymdlsdk.new_IType_color(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_color

    def __deref__(self):
        return _pymdlsdk.IType_color___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_color___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_color_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_color___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_color___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_color_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_color_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_color__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_color_compare_iid(self, iid)

    def get_component_type(self, index):
        r""" Returns the component type at ``index``."""
        return _pymdlsdk.IType_color_get_component_type(self, index)

    def get_size(self):
        r""" Returns the number of components."""
        return _pymdlsdk.IType_color_get_size(self)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_color__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_color_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_color_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_color__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_color__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_color_get_iid(self)

# Register IType_color in _pymdlsdk:
_pymdlsdk.IType_color_swigregister(IType_color)

def IType_color_IID():
    return _pymdlsdk.IType_color_IID()

def IType_color__get_interface(iface):
    return _pymdlsdk.IType_color__get_interface(iface)

class IType_compound(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_compound_swiginit(self, _pymdlsdk.new_IType_compound(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_compound

    def __deref__(self):
        return _pymdlsdk.IType_compound___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_compound___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_compound_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_compound___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_compound___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_compound_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_compound_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_compound__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def get_component_type(self, index):
        r""" Returns the component type at ``index``."""
        return _pymdlsdk.IType_compound_get_component_type(self, index)

    def get_size(self):
        r""" Returns the number of components."""
        return _pymdlsdk.IType_compound_get_size(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_compound_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_compound__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_compound_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_compound_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_compound__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_compound__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_compound_get_iid(self)

# Register IType_compound in _pymdlsdk:
_pymdlsdk.IType_compound_swigregister(IType_compound)

def IType_compound_IID():
    return _pymdlsdk.IType_compound_IID()

def IType_compound__get_interface(iface):
    return _pymdlsdk.IType_compound__get_interface(iface)

class IType_df(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_df_swiginit(self, _pymdlsdk.new_IType_df(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_df

    def __deref__(self):
        return _pymdlsdk.IType_df___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_df___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_df_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_df___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_df___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_df_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_df_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_df__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_df_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_df__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_df_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_df_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_df__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_df__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_df_get_iid(self)

# Register IType_df in _pymdlsdk:
_pymdlsdk.IType_df_swigregister(IType_df)

def IType_df_IID():
    return _pymdlsdk.IType_df_IID()

def IType_df__get_interface(iface):
    return _pymdlsdk.IType_df__get_interface(iface)

class IType_double(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_double_swiginit(self, _pymdlsdk.new_IType_double(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_double

    def __deref__(self):
        return _pymdlsdk.IType_double___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_double___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_double_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_double___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_double___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_double_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_double_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_double__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_double_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_double__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_double_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_double_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_double__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_double__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_double_get_iid(self)

# Register IType_double in _pymdlsdk:
_pymdlsdk.IType_double_swigregister(IType_double)

def IType_double_IID():
    return _pymdlsdk.IType_double_IID()

def IType_double__get_interface(iface):
    return _pymdlsdk.IType_double__get_interface(iface)

class IType_edf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_edf_swiginit(self, _pymdlsdk.new_IType_edf(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_edf

    def __deref__(self):
        return _pymdlsdk.IType_edf___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_edf___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_edf_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_edf___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_edf___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_edf_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_edf_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_edf__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_edf_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_edf__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_edf_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_edf_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_edf__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_edf__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_edf_get_iid(self)

# Register IType_edf in _pymdlsdk:
_pymdlsdk.IType_edf_swigregister(IType_edf)

def IType_edf_IID():
    return _pymdlsdk.IType_edf_IID()

def IType_edf__get_interface(iface):
    return _pymdlsdk.IType_edf__get_interface(iface)

class IType_enumeration(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_enumeration_swiginit(self, _pymdlsdk.new_IType_enumeration(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_enumeration

    def __deref__(self):
        return _pymdlsdk.IType_enumeration___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_enumeration___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_enumeration_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_enumeration___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_enumeration___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_enumeration_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_enumeration_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_enumeration__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def get_symbol(self):
        r""" Returns the qualified name of this enum type."""
        return _pymdlsdk.IType_enumeration_get_symbol(self)

    def get_size(self):
        r""" Returns the number of values."""
        return _pymdlsdk.IType_enumeration_get_size(self)

    def get_value_name(self, index):
        r"""
        Returns the name of a value.

        :type index: int
        :param index:         The index of the value.
        :rtype: string
        :return: The unqualified name of the value, or ``NULL`` if ``index`` is invalid.
        """
        return _pymdlsdk.IType_enumeration_get_value_name(self, index)

    def get_value_code_with_ret(self, index):
        r"""
        Returns the code of a value.

        :type index: int
        :param index:         The index of the value.
        :type errors: int, out, optional
        :param errors:
                                 -  0: Success.
                                 - -1: ``index`` is invalid.
        :rtype: int
        :return: The code of the value, or 0 in case of errors.
        """
        return _pymdlsdk.IType_enumeration_get_value_code_with_ret(self, index)

    def get_value_code(self, index):
        r"""
        Returns the code of a value.

        :type index: int
        :param index:         The index of the value.
        :param errors:
                                 -  0: Success.
                                 - -1: ``index`` is invalid.
        :rtype: int
        :return: The code of the value, or 0 in case of errors.
        """
        return _pymdlsdk.IType_enumeration_get_value_code(self, index)

    def find_value(self, *args):
        r"""
        *Overload 1:*
        Returns the index of a value in linear time.

        :type name: string
        :param name:          The unqualified name of the value.
        :rtype: int
        :return: The index of the value, or -1 if there is no such value.

        |

        *Overload 2:*
        Returns the index of a value in linear time.

        :type code: int
        :param code:          The code of the value.
        :rtype: int
        :return: The index of the value, or -1 if there is no such value.
        """
        return _pymdlsdk.IType_enumeration_find_value(self, *args)

    def get_predefined_id(self):
        r""" If this enum is a predefined one, return its ID, else EID_USER."""
        return _pymdlsdk.IType_enumeration_get_predefined_id(self)

    def get_annotations(self):
        r"""
        Returns the annotations of the enum type.

        :rtype: :py:class:`IAnnotation_block`
        :return: The annotations of the enum type, or ``NULL`` if there are no
                                 annotations for the enum type.
        """
        return _pymdlsdk.IType_enumeration_get_annotations(self)

    def get_value_annotations(self, index):
        r"""
        Returns the annotations of a value.

        :type index: int
        :param index:         The index of the value.
        :rtype: :py:class:`IAnnotation_block`
        :return: The annotation of that value, or ``NULL`` if ``index`` is out of bounds,
                                 or there are no annotations for that value.
        """
        return _pymdlsdk.IType_enumeration_get_value_annotations(self, index)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_enumeration_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_enumeration__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_enumeration_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_enumeration_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_enumeration__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_enumeration__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_enumeration_get_iid(self)

# Register IType_enumeration in _pymdlsdk:
_pymdlsdk.IType_enumeration_swigregister(IType_enumeration)

def IType_enumeration_IID():
    return _pymdlsdk.IType_enumeration_IID()

def IType_enumeration__get_interface(iface):
    return _pymdlsdk.IType_enumeration__get_interface(iface)

class IType_factory(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_factory_swiginit(self, _pymdlsdk.new_IType_factory(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_factory

    def __deref__(self):
        return _pymdlsdk.IType_factory___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_factory___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_factory_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_factory___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_factory___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_factory_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_factory_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_factory__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def create_alias(self, type, modifiers, symbol):
        r""" Creates a new instance of the type alias."""
        return _pymdlsdk.IType_factory_create_alias(self, type, modifiers, symbol)

    def create_bool(self):
        r""" Creates a new instance of the type boolean."""
        return _pymdlsdk.IType_factory_create_bool(self)

    def create_int(self):
        r""" Creates a new instance of the type int."""
        return _pymdlsdk.IType_factory_create_int(self)

    def create_enum(self, symbol):
        r""" Returns a registered enum type, or ``NULL`` if ``symbol`` is invalid or unknown."""
        return _pymdlsdk.IType_factory_create_enum(self, symbol)

    def create_float(self):
        r""" Creates a new instance of the float type."""
        return _pymdlsdk.IType_factory_create_float(self)

    def create_double(self):
        r""" Creates a new instance of the double type."""
        return _pymdlsdk.IType_factory_create_double(self)

    def create_string(self):
        r""" Creates a new instance of the string type."""
        return _pymdlsdk.IType_factory_create_string(self)

    def create_vector(self, element_type, size):
        r"""
        Creates a new instance of a vector type.

        :type element_type: :py:class:`IType_atomic`
        :param element_type:   The element type needs to be either #mi::neuraylib::IType_bool,
                                  #mi::neuraylib::IType_int, #mi::neuraylib::IType_float, or
                                  #mi::neuraylib::IType_double.
        :type size: int
        :param size:           The number of elements, either 2, 3, or 4.
        :rtype: :py:class:`IType_vector`
        :return: The corresponding vector type, or ``NULL`` in case of errors.
        """
        return _pymdlsdk.IType_factory_create_vector(self, element_type, size)

    def create_matrix(self, column_type, columns):
        r"""
        Creates a new instance of a matrix type.

        :type column_type: :py:class:`IType_vector`
        :param column_type:    The column type needs to be a vector of either
                                  #mi::neuraylib::IType_float or #mi::neuraylib::IType_double.
        :type columns: int
        :param columns:        The number of columns, either 2, 3, or 4.
        :rtype: :py:class:`IType_matrix`
        :return: The corresponding matrix type, or ``NULL`` in case of errors.
        """
        return _pymdlsdk.IType_factory_create_matrix(self, column_type, columns)

    def create_color(self):
        r""" Creates a new instance of the type color."""
        return _pymdlsdk.IType_factory_create_color(self)

    def create_immediate_sized_array(self, element_type, size):
        r""" Creates a new instance of an immediate-sized array type."""
        return _pymdlsdk.IType_factory_create_immediate_sized_array(self, element_type, size)

    def create_deferred_sized_array(self, element_type, size):
        r""" Creates a new instance of a deferred-sized array type."""
        return _pymdlsdk.IType_factory_create_deferred_sized_array(self, element_type, size)

    def create_struct(self, symbol):
        r""" Returns a registered struct type, or ``NULL`` if ``symbol`` is invalid or unknown."""
        return _pymdlsdk.IType_factory_create_struct(self, symbol)

    def create_texture(self, shape):
        r""" Creates a new instance of the type texture."""
        return _pymdlsdk.IType_factory_create_texture(self, shape)

    def create_light_profile(self):
        r""" Creates a new instance of the type light_profile."""
        return _pymdlsdk.IType_factory_create_light_profile(self)

    def create_bsdf_measurement(self):
        r""" Creates a new instance of the type bsdf_measurement."""
        return _pymdlsdk.IType_factory_create_bsdf_measurement(self)

    def create_bsdf(self):
        r""" Creates a new instance of the type bsdf."""
        return _pymdlsdk.IType_factory_create_bsdf(self)

    def create_hair_bsdf(self):
        r""" Creates a new instance of the type hair_bsdf."""
        return _pymdlsdk.IType_factory_create_hair_bsdf(self)

    def create_edf(self):
        r""" Creates a new instance of the type edf."""
        return _pymdlsdk.IType_factory_create_edf(self)

    def create_vdf(self):
        r""" Creates a new instance of the type vdf."""
        return _pymdlsdk.IType_factory_create_vdf(self)

    def create_type_list(self):
        r""" Creates a new type map."""
        return _pymdlsdk.IType_factory_create_type_list(self)

    def get_predefined_enum(self, id):
        r""" Returns a registered enum type, or ``NULL`` if ``id`` is unknown."""
        return _pymdlsdk.IType_factory_get_predefined_enum(self, id)

    def get_predefined_struct(self, id):
        r""" Returns a registered struct type, or ``NULL`` if ``id`` is unknown."""
        return _pymdlsdk.IType_factory_get_predefined_struct(self, id)

    def clone(self, type_list):
        r""" Clones the given type list."""
        return _pymdlsdk.IType_factory_clone(self, type_list)

    def compare(self, *args):
        r"""
        *Overload 1:*
        Compares two instances of #mi::neuraylib::IType.

        The comparison operator for instances of #mi::neuraylib::IType is defined as follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Otherwise, the kind of the types are compared. If they are different, the result is
          determined by ``operator``< on the #mi::neuraylib::IType::Kind values.
        - Finally, specific types are compared as follows:
          - #mi::neuraylib::IType_enum and #mi::neuraylib::IType_struct: The result is determined by
            ``strcmp()`` on the corresponding symbol names.
          - #mi::neuraylib::IType_vector, #mi::neuraylib::IType_matrix, #mi::neuraylib::IType_array:
            If the element types are different, they determine the result of the comparison. If the
            element types are identical the number of compound elements determines the result.
          - #mi::neuraylib::IType_alias: If the modifiers are different, they determine the result
            of the comparison. If the modifiers are identical, the aliased types determine the
            result.
          - #mi::neuraylib::IType_texture: The result is determined by a comparison of the
            corresponding shapes.
          - All other pairs of (the same kind of) types are considered equal.

        :type lhs: :py:class:`IType`
        :param lhs:   The left-hand side operand for the comparison.
        :type rhs: :py:class:`IType`
        :param rhs:   The right-hand side operand for the comparison.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.

        |

        *Overload 2:*
        Compares two instances of #mi::neuraylib::IType_list.

        The comparison operator for instances of #mi::neuraylib::IType_list is defined as follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Next, the list sizes are compared using ``operator``<().
        - Next, the lists are traversed by increasing index and the names are compared using
          ``strcmp()``.
        - Finally, the list elements are enumerated by increasing index and the types are compared.

        :type lhs: :py:class:`IType_list`
        :param lhs:   The left-hand side operand for the comparison.
        :type rhs: :py:class:`IType_list`
        :param rhs:   The right-hand side operand for the comparison.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.
        """
        return _pymdlsdk.IType_factory_compare(self, *args)

    def is_compatible(self, src, dst):
        r"""
        Checks, if two instances of #mi::neuraylib::IType are compatible, meaning that ``src``
        can be casted to ``dst``.

        ``src`` is compatible with and therefore can be casted to ``dst``, if
        - ``src`` and ``dst`` are of identical type (see #mi::neuraylib::IType_factory::compare()).
        - ``src`` and ``dst`` are of type #mi::neuraylib::IType_struct, have the same number of
          fields and all fields are compatible.
        - ``src`` and ``dst`` are of type #mi::neuraylib::IType_enum and both enumeration types have
          the same set of numerical enumeration values. The name of the enumeration values, their
          order, or whether multiple enumeration value names share the same numerical value
          do not matter.
        - ``src`` and ``dst`` are of type #mi::neuraylib::IType_array, both arrays have the same size
          and their element types are compatible.

        :type src: :py:class:`IType`
        :param src: The source type.
        :type dst: :py:class:`IType`
        :param dst: the target type to which src is intended to be compatible.
        :rtype: int
        :return: 
                      -  0 if ``src`` can be casted to ``dst``, but ``src`` and ``dst`` are not of identical
                           type.
                      -  1 if ``src`` and ``dst`` are of identical type.
                      - -1 if ``src`` cannot be casted to ``dst``.
        """
        return _pymdlsdk.IType_factory_is_compatible(self, src, dst)

    def dump(self, *args):
        r"""
        *Overload 1:*
         Returns a textual representation of a type.

         The representation of the type might contain line breaks, for example for structures and
         enums. Subsequent lines have a suitable indentation. The assumed indentation level of the
         first line is specified by ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 2:*
         Returns a textual representation of a type list.

         The representation of the type list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 3:*
         Returns a textual representation of a type list.

         The representation of the type list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.
        """
        return _pymdlsdk.IType_factory_dump(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_factory_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_factory__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_factory__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_factory_get_iid(self)

# Register IType_factory in _pymdlsdk:
_pymdlsdk.IType_factory_swigregister(IType_factory)

def IType_factory_IID():
    return _pymdlsdk.IType_factory_IID()

def IType_factory__get_interface(iface):
    return _pymdlsdk.IType_factory__get_interface(iface)

class IType_float(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_float_swiginit(self, _pymdlsdk.new_IType_float(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_float

    def __deref__(self):
        return _pymdlsdk.IType_float___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_float___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_float_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_float___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_float___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_float_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_float_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_float__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_float_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_float__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_float_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_float_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_float__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_float__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_float_get_iid(self)

# Register IType_float in _pymdlsdk:
_pymdlsdk.IType_float_swigregister(IType_float)

def IType_float_IID():
    return _pymdlsdk.IType_float_IID()

def IType_float__get_interface(iface):
    return _pymdlsdk.IType_float__get_interface(iface)

class IType_hair_bsdf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_hair_bsdf_swiginit(self, _pymdlsdk.new_IType_hair_bsdf(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_hair_bsdf

    def __deref__(self):
        return _pymdlsdk.IType_hair_bsdf___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_hair_bsdf___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_hair_bsdf_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_hair_bsdf___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_hair_bsdf___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_hair_bsdf_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_hair_bsdf_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_hair_bsdf__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_hair_bsdf_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_hair_bsdf__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_hair_bsdf_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_hair_bsdf_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_hair_bsdf__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_hair_bsdf__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_hair_bsdf_get_iid(self)

# Register IType_hair_bsdf in _pymdlsdk:
_pymdlsdk.IType_hair_bsdf_swigregister(IType_hair_bsdf)

def IType_hair_bsdf_IID():
    return _pymdlsdk.IType_hair_bsdf_IID()

def IType_hair_bsdf__get_interface(iface):
    return _pymdlsdk.IType_hair_bsdf__get_interface(iface)

class IType_int(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_int_swiginit(self, _pymdlsdk.new_IType_int(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_int

    def __deref__(self):
        return _pymdlsdk.IType_int___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_int___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_int_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_int___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_int___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_int_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_int_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_int__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_int_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_int__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_int_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_int_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_int__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_int__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_int_get_iid(self)

# Register IType_int in _pymdlsdk:
_pymdlsdk.IType_int_swigregister(IType_int)

def IType_int_IID():
    return _pymdlsdk.IType_int_IID()

def IType_int__get_interface(iface):
    return _pymdlsdk.IType_int__get_interface(iface)

class IType_light_profile(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_light_profile_swiginit(self, _pymdlsdk.new_IType_light_profile(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_light_profile

    def __deref__(self):
        return _pymdlsdk.IType_light_profile___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_light_profile___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_light_profile_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_light_profile___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_light_profile___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_light_profile_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_light_profile_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_light_profile__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_light_profile_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_light_profile__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_light_profile_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_light_profile_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_light_profile__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_light_profile__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_light_profile_get_iid(self)

# Register IType_light_profile in _pymdlsdk:
_pymdlsdk.IType_light_profile_swigregister(IType_light_profile)

def IType_light_profile_IID():
    return _pymdlsdk.IType_light_profile_IID()

def IType_light_profile__get_interface(iface):
    return _pymdlsdk.IType_light_profile__get_interface(iface)

class IType_list(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_list_swiginit(self, _pymdlsdk.new_IType_list(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_list

    def __deref__(self):
        return _pymdlsdk.IType_list___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_list___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_list_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_list___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_list___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_list_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_list_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_list__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_size(self):
        r""" Returns the number of elements."""
        return _pymdlsdk.IType_list_get_size(self)

    def get_index(self, name):
        r""" Returns the index for the given name, or -1 if there is no such type."""
        return _pymdlsdk.IType_list_get_index(self, name)

    def get_name(self, index):
        r""" Returns the name for the given index, or ``NULL`` if there is no such type."""
        return _pymdlsdk.IType_list_get_name(self, index)

    def get_type(self, *args):
        r"""
        *Overload 1:*
        Returns the type for ``index``, or ``NULL`` if there is no such type.

        |

        *Overload 2:*
        Returns the type for ``name``, or ``NULL`` if there is no such type.
        """
        return _pymdlsdk.IType_list_get_type(self, *args)

    def set_type(self, *args):
        r"""
        *Overload 1:*
        Sets a type at a given index.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: ``index`` is out of bounds.

        |

        *Overload 2:*
        Sets a type identified by name.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: There is no type mapped to ``name`` in the list.
        """
        return _pymdlsdk.IType_list_set_type(self, *args)

    def add_type(self, name, type):
        r"""
        Adds a type at the end of the list.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: There is already a type mapped to ``name`` in the list.
        """
        return _pymdlsdk.IType_list_add_type(self, name, type)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_list_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_list__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_list__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_list_get_iid(self)

# Register IType_list in _pymdlsdk:
_pymdlsdk.IType_list_swigregister(IType_list)

def IType_list_IID():
    return _pymdlsdk.IType_list_IID()

def IType_list__get_interface(iface):
    return _pymdlsdk.IType_list__get_interface(iface)

class IType_matrix(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_matrix_swiginit(self, _pymdlsdk.new_IType_matrix(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_matrix

    def __deref__(self):
        return _pymdlsdk.IType_matrix___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_matrix___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_matrix_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_matrix___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_matrix___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_matrix_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_matrix_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_matrix__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def get_element_type(self):
        r""" Returns the type of the matrix elements, i.e., the type of a column vector."""
        return _pymdlsdk.IType_matrix_get_element_type(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_matrix_compare_iid(self, iid)

    def get_component_type(self, index):
        r""" Returns the component type at ``index``."""
        return _pymdlsdk.IType_matrix_get_component_type(self, index)

    def get_size(self):
        r""" Returns the number of components."""
        return _pymdlsdk.IType_matrix_get_size(self)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_matrix__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_matrix_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_matrix_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_matrix__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_matrix__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_matrix_get_iid(self)

# Register IType_matrix in _pymdlsdk:
_pymdlsdk.IType_matrix_swigregister(IType_matrix)

def IType_matrix_IID():
    return _pymdlsdk.IType_matrix_IID()

def IType_matrix__get_interface(iface):
    return _pymdlsdk.IType_matrix__get_interface(iface)

class IType_reference(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_reference_swiginit(self, _pymdlsdk.new_IType_reference(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_reference

    def __deref__(self):
        return _pymdlsdk.IType_reference___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_reference___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_reference_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_reference___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_reference___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_reference_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_reference_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_reference__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_reference_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_reference__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_reference_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_reference_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_reference__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_reference__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_reference_get_iid(self)

# Register IType_reference in _pymdlsdk:
_pymdlsdk.IType_reference_swigregister(IType_reference)

def IType_reference_IID():
    return _pymdlsdk.IType_reference_IID()

def IType_reference__get_interface(iface):
    return _pymdlsdk.IType_reference__get_interface(iface)

class IType_resource(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_resource_swiginit(self, _pymdlsdk.new_IType_resource(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_resource

    def __deref__(self):
        return _pymdlsdk.IType_resource___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_resource___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_resource_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_resource___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_resource___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_resource_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_resource_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_resource__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_resource_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_resource__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_resource_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_resource_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_resource__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_resource__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_resource_get_iid(self)

# Register IType_resource in _pymdlsdk:
_pymdlsdk.IType_resource_swigregister(IType_resource)

def IType_resource_IID():
    return _pymdlsdk.IType_resource_IID()

def IType_resource__get_interface(iface):
    return _pymdlsdk.IType_resource__get_interface(iface)

class IType_string(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_string_swiginit(self, _pymdlsdk.new_IType_string(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_string

    def __deref__(self):
        return _pymdlsdk.IType_string___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_string___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_string_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_string___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_string___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_string_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_string_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_string__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_string_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_string__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_string_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_string_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_string__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_string__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_string_get_iid(self)

# Register IType_string in _pymdlsdk:
_pymdlsdk.IType_string_swigregister(IType_string)

def IType_string_IID():
    return _pymdlsdk.IType_string_IID()

def IType_string__get_interface(iface):
    return _pymdlsdk.IType_string__get_interface(iface)

class IType_structure(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_structure_swiginit(self, _pymdlsdk.new_IType_structure(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_structure

    def __deref__(self):
        return _pymdlsdk.IType_structure___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_structure___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_structure_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_structure___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_structure___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_structure_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_structure_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_structure__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def get_symbol(self):
        r""" Returns the qualified name of the struct type."""
        return _pymdlsdk.IType_structure_get_symbol(self)

    def get_field_type(self, index):
        r"""
        Returns a field type.

        :type index: int
        :param index:    The index of the field.
        :rtype: :py:class:`IType`
        :return: The type of the field.
        """
        return _pymdlsdk.IType_structure_get_field_type(self, index)

    def get_field_name(self, index):
        r"""
        Returns a field name.

        :type index: int
        :param index:    The index of the field.
        :rtype: string
        :return: The unqualified name of the field.
        """
        return _pymdlsdk.IType_structure_get_field_name(self, index)

    def find_field(self, name):
        r"""
        Returns the index of a field in linear time.

        :type name: string
        :param name:     The unqualified name of the field.
        :rtype: int
        :return: The index of the field, or -1 if there is no such field.
        """
        return _pymdlsdk.IType_structure_find_field(self, name)

    def get_predefined_id(self):
        r""" If this struct is a predefined one, return its ID, else SID_USER."""
        return _pymdlsdk.IType_structure_get_predefined_id(self)

    def get_annotations(self):
        r"""
        Returns the annotations of the struct type.

        :rtype: :py:class:`IAnnotation_block`
        :return: The annotations of the struct type, or ``NULL`` if there are no
                                 annotations for the struct type.
        """
        return _pymdlsdk.IType_structure_get_annotations(self)

    def get_field_annotations(self, index):
        r"""
        Returns the annotations of a field.

        :type index: int
        :param index:         The index of the field.
        :rtype: :py:class:`IAnnotation_block`
        :return: The annotation of that field, or ``NULL`` if ``index`` is out of bounds,
                                 or there are no annotations for that field.
        """
        return _pymdlsdk.IType_structure_get_field_annotations(self, index)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_structure_compare_iid(self, iid)

    def get_component_type(self, index):
        r""" Returns the component type at ``index``."""
        return _pymdlsdk.IType_structure_get_component_type(self, index)

    def get_size(self):
        r""" Returns the number of components."""
        return _pymdlsdk.IType_structure_get_size(self)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_structure__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_structure_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_structure_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_structure__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_structure__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_structure_get_iid(self)

# Register IType_structure in _pymdlsdk:
_pymdlsdk.IType_structure_swigregister(IType_structure)

def IType_structure_IID():
    return _pymdlsdk.IType_structure_IID()

def IType_structure__get_interface(iface):
    return _pymdlsdk.IType_structure__get_interface(iface)

class IType_texture(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_texture_swiginit(self, _pymdlsdk.new_IType_texture(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_texture

    def __deref__(self):
        return _pymdlsdk.IType_texture___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_texture___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_texture_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_texture___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_texture___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_texture_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_texture_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_texture__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def get_shape(self):
        r""" Returns the texture type."""
        return _pymdlsdk.IType_texture_get_shape(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_texture_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_texture__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_texture_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_texture_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_texture__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_texture__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_texture_get_iid(self)

# Register IType_texture in _pymdlsdk:
_pymdlsdk.IType_texture_swigregister(IType_texture)

def IType_texture_IID():
    return _pymdlsdk.IType_texture_IID()

def IType_texture__get_interface(iface):
    return _pymdlsdk.IType_texture__get_interface(iface)

class IType_vdf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_vdf_swiginit(self, _pymdlsdk.new_IType_vdf(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_vdf

    def __deref__(self):
        return _pymdlsdk.IType_vdf___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_vdf___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_vdf_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_vdf___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_vdf___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_vdf_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_vdf_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_vdf__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_vdf_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_vdf__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_vdf_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_vdf_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_vdf__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_vdf__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_vdf_get_iid(self)

# Register IType_vdf in _pymdlsdk:
_pymdlsdk.IType_vdf_swigregister(IType_vdf)

def IType_vdf_IID():
    return _pymdlsdk.IType_vdf_IID()

def IType_vdf__get_interface(iface):
    return _pymdlsdk.IType_vdf__get_interface(iface)

class IType_vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_vector_swiginit(self, _pymdlsdk.new_IType_vector(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_vector

    def __deref__(self):
        return _pymdlsdk.IType_vector___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_vector___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_vector_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_vector___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_vector___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_vector_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_vector_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_vector__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def get_element_type(self):
        r"""
        Returns the type of the vector elements.

        The element type of vectors is either #mi::neuraylib::IType_bool, #mi::neuraylib::IType_int,
        #mi::neuraylib::IType_float, or #mi::neuraylib::IType_double. If the vector is a column
        vector of a matrix, then the element type is either #mi::neuraylib::IType_float or
        #mi::neuraylib::IType_double.
        """
        return _pymdlsdk.IType_vector_get_element_type(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_vector_compare_iid(self, iid)

    def get_component_type(self, index):
        r""" Returns the component type at ``index``."""
        return _pymdlsdk.IType_vector_get_component_type(self, index)

    def get_size(self):
        r""" Returns the number of components."""
        return _pymdlsdk.IType_vector_get_size(self)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_vector__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_vector_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_vector_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_vector__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_vector__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_vector_get_iid(self)

# Register IType_vector in _pymdlsdk:
_pymdlsdk.IType_vector_swigregister(IType_vector)

def IType_vector_IID():
    return _pymdlsdk.IType_vector_IID()

def IType_vector__get_interface(iface):
    return _pymdlsdk.IType_vector__get_interface(iface)

class IValue(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_swiginit(self, _pymdlsdk.new_IValue(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue

    def __deref__(self):
        return _pymdlsdk.IValue___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    class Kind(Enum) :
        VK_BOOL = _pymdlsdk._IValue_VK_BOOL
        VK_INT = _pymdlsdk._IValue_VK_INT
        VK_ENUM = _pymdlsdk._IValue_VK_ENUM
        VK_FLOAT = _pymdlsdk._IValue_VK_FLOAT
        VK_DOUBLE = _pymdlsdk._IValue_VK_DOUBLE
        VK_STRING = _pymdlsdk._IValue_VK_STRING
        VK_VECTOR = _pymdlsdk._IValue_VK_VECTOR
        VK_MATRIX = _pymdlsdk._IValue_VK_MATRIX
        VK_COLOR = _pymdlsdk._IValue_VK_COLOR
        VK_ARRAY = _pymdlsdk._IValue_VK_ARRAY
        VK_STRUCT = _pymdlsdk._IValue_VK_STRUCT
        VK_INVALID_DF = _pymdlsdk._IValue_VK_INVALID_DF
        VK_TEXTURE = _pymdlsdk._IValue_VK_TEXTURE
        VK_LIGHT_PROFILE = _pymdlsdk._IValue_VK_LIGHT_PROFILE
        VK_BSDF_MEASUREMENT = _pymdlsdk._IValue_VK_BSDF_MEASUREMENT


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue__get_kind(self)

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_get_type(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_get_iid(self)

# Register IValue in _pymdlsdk:
_pymdlsdk.IValue_swigregister(IValue)

def IValue_IID():
    return _pymdlsdk.IValue_IID()

def IValue__get_interface(iface):
    return _pymdlsdk.IValue__get_interface(iface)

class IValue_array(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_array_swiginit(self, _pymdlsdk.new_IValue_array(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_array

    def __deref__(self):
        return _pymdlsdk.IValue_array___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_array___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_array_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_array___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_array___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_array_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_array_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_array__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_value(self, *args):
        return  self._get_value(*args)

    def get_value_as(self, type, *args):
        iinterface = self._get_value(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_array_get_type(self)

    def set_size(self, size):
        r"""
        Sets the size for dynamic arrays.

        :type size: int
        :param size:   The desired array size.
        :rtype: int
        :return: 
                          -  0: Success.
                          - -1: The array is a static array.
        """
        return _pymdlsdk.IValue_array_set_size(self, size)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_array_compare_iid(self, iid)

    def get_size(self):
        r""" Returns the number of components in this compound value."""
        return _pymdlsdk.IValue_array_get_size(self)

    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.

        |

        *Overload 2:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk.IValue_array__get_value(self, *args)

    def set_value(self, index, value):
        r"""
        Sets the value at ``index``.

        :type index: int
        :param index:   The index of the field.
        :type value: :py:class:`IValue`
        :param value:   The new value of the field.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: ``index`` is out of bounds.
                           - -3: Incorrect type of ``value``.
        """
        return _pymdlsdk.IValue_array_set_value(self, index, value)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_array__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_array__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_array__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_array_get_iid(self)

# Register IValue_array in _pymdlsdk:
_pymdlsdk.IValue_array_swigregister(IValue_array)

def IValue_array_IID():
    return _pymdlsdk.IValue_array_IID()

def IValue_array__get_interface(iface):
    return _pymdlsdk.IValue_array__get_interface(iface)

class IValue_atomic(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_atomic_swiginit(self, _pymdlsdk.new_IValue_atomic(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_atomic

    def __deref__(self):
        return _pymdlsdk.IValue_atomic___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_atomic___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_atomic_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_atomic___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_atomic___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_atomic_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_atomic_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_atomic__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_atomic_get_type(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_atomic_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_atomic__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_atomic__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_atomic__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_atomic_get_iid(self)

# Register IValue_atomic in _pymdlsdk:
_pymdlsdk.IValue_atomic_swigregister(IValue_atomic)

def IValue_atomic_IID():
    return _pymdlsdk.IValue_atomic_IID()

def IValue_atomic__get_interface(iface):
    return _pymdlsdk.IValue_atomic__get_interface(iface)

class IValue_bool(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_bool_swiginit(self, _pymdlsdk.new_IValue_bool(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_bool

    def __deref__(self):
        return _pymdlsdk.IValue_bool___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_bool___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_bool_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_bool___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_bool___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_bool_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_bool_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_bool__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_bool_get_type(self)

    def get_value(self):
        r""" Returns the value."""
        return _pymdlsdk.IValue_bool_get_value(self)

    def set_value(self, value):
        r""" Sets the value."""
        return _pymdlsdk.IValue_bool_set_value(self, value)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_bool_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_bool__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_bool__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_bool__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_bool_get_iid(self)

# Register IValue_bool in _pymdlsdk:
_pymdlsdk.IValue_bool_swigregister(IValue_bool)

def IValue_bool_IID():
    return _pymdlsdk.IValue_bool_IID()

def IValue_bool__get_interface(iface):
    return _pymdlsdk.IValue_bool__get_interface(iface)

class IValue_bsdf_measurement(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_bsdf_measurement_swiginit(self, _pymdlsdk.new_IValue_bsdf_measurement(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_bsdf_measurement

    def __deref__(self):
        return _pymdlsdk.IValue_bsdf_measurement___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_bsdf_measurement___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_bsdf_measurement_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_bsdf_measurement___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_bsdf_measurement___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_bsdf_measurement_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_bsdf_measurement_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_bsdf_measurement__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_bsdf_measurement_get_type(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_bsdf_measurement_compare_iid(self, iid)

    def get_value(self):
        r"""
        Returns the name of the DB element representing this resource.

        :rtype: string
        :return: The name of the DB element, or ``NULL`` if no valid resource is set.
        """
        return _pymdlsdk.IValue_bsdf_measurement_get_value(self)

    def set_value(self, value):
        r"""
        Sets the name of the DB element representing this resource.

        Pointing this instance to a different DB element resets the MDL file path returned by
        #get_file_path().

        :type value: string
        :param value:   The name of the resource, or ``NULL`` to release the current resource.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: There is no DB element with that name.
                           - -2: The DB element has not the correct type for this resource.
        """
        return _pymdlsdk.IValue_bsdf_measurement_set_value(self, value)

    def get_file_path(self):
        r"""
        Returns the absolute MDL file path of the resource, or ``NULL`` if not known.

        Notes: The value returned here is not a property of this object, but a property of the
              referenced resource.
        """
        return _pymdlsdk.IValue_bsdf_measurement_get_file_path(self)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_bsdf_measurement__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_bsdf_measurement__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_bsdf_measurement__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_bsdf_measurement_get_iid(self)

# Register IValue_bsdf_measurement in _pymdlsdk:
_pymdlsdk.IValue_bsdf_measurement_swigregister(IValue_bsdf_measurement)

def IValue_bsdf_measurement_IID():
    return _pymdlsdk.IValue_bsdf_measurement_IID()

def IValue_bsdf_measurement__get_interface(iface):
    return _pymdlsdk.IValue_bsdf_measurement__get_interface(iface)

class IValue_color(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_color_swiginit(self, _pymdlsdk.new_IValue_color(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_color

    def __deref__(self):
        return _pymdlsdk.IValue_color___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_color___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_color_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_color___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_color___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_color_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_color_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_color__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_value(self, *args):
        return  self._get_value(*args)

    def get_value_as(self, type, *args):
        iinterface = self._get_value(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_color_get_type(self)

    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.

        |

        *Overload 2:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk.IValue_color__get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the value at ``index``.

        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: ``index`` is out of bounds.

        |

        *Overload 2:*
        Sets the value at ``index``.

        :type index: int
        :param index:   The index of the field.
        :type value: :py:class:`IValue`
        :param value:   The new value of the field.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: ``index`` is out of bounds.
                           - -3: Incorrect type of ``value``.
        """
        return _pymdlsdk.IValue_color_set_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_color_compare_iid(self, iid)

    def get_size(self):
        r""" Returns the number of components in this compound value."""
        return _pymdlsdk.IValue_color_get_size(self)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_color__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_color__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_color__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_color_get_iid(self)

# Register IValue_color in _pymdlsdk:
_pymdlsdk.IValue_color_swigregister(IValue_color)

def IValue_color_IID():
    return _pymdlsdk.IValue_color_IID()

def IValue_color__get_interface(iface):
    return _pymdlsdk.IValue_color__get_interface(iface)

class IValue_compound(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_compound_swiginit(self, _pymdlsdk.new_IValue_compound(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_compound

    def __deref__(self):
        return _pymdlsdk.IValue_compound___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_compound___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_compound_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_compound___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_compound___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_compound_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_compound_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_compound__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_value(self, *args):
        return  self._get_value(*args)

    def get_value_as(self, type, *args):
        iinterface = self._get_value(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_compound_get_type(self)

    def get_size(self):
        r""" Returns the number of components in this compound value."""
        return _pymdlsdk.IValue_compound_get_size(self)

    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.

        |

        *Overload 2:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk.IValue_compound__get_value(self, *args)

    def set_value(self, index, value):
        r"""
        Sets the value at ``index``.

        :type index: int
        :param index:   The index of the field.
        :type value: :py:class:`IValue`
        :param value:   The new value of the field.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: ``index`` is out of bounds.
                           - -3: Incorrect type of ``value``.
        """
        return _pymdlsdk.IValue_compound_set_value(self, index, value)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_compound_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_compound__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_compound__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_compound__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_compound_get_iid(self)

# Register IValue_compound in _pymdlsdk:
_pymdlsdk.IValue_compound_swigregister(IValue_compound)

def IValue_compound_IID():
    return _pymdlsdk.IValue_compound_IID()

def IValue_compound__get_interface(iface):
    return _pymdlsdk.IValue_compound__get_interface(iface)

class IValue_double(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_double_swiginit(self, _pymdlsdk.new_IValue_double(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_double

    def __deref__(self):
        return _pymdlsdk.IValue_double___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_double___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_double_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_double___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_double___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_double_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_double_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_double__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_double_get_type(self)

    def get_value(self):
        r""" Returns the value."""
        return _pymdlsdk.IValue_double_get_value(self)

    def set_value(self, value):
        r""" Sets the value."""
        return _pymdlsdk.IValue_double_set_value(self, value)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_double_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_double__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_double__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_double__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_double_get_iid(self)

# Register IValue_double in _pymdlsdk:
_pymdlsdk.IValue_double_swigregister(IValue_double)

def IValue_double_IID():
    return _pymdlsdk.IValue_double_IID()

def IValue_double__get_interface(iface):
    return _pymdlsdk.IValue_double__get_interface(iface)

class IValue_enumeration(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_enumeration_swiginit(self, _pymdlsdk.new_IValue_enumeration(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_enumeration

    def __deref__(self):
        return _pymdlsdk.IValue_enumeration___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_enumeration___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_enumeration_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_enumeration___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_enumeration___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_enumeration_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_enumeration_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_enumeration__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_enumeration_get_type(self)

    def get_value(self):
        r""" Returns the (integer) value of this enum value."""
        return _pymdlsdk.IValue_enumeration_get_value(self)

    def get_index(self):
        r""" Returns the index of this enum value."""
        return _pymdlsdk.IValue_enumeration_get_index(self)

    def set_value(self, value):
        r"""
        Sets the enum value by integer in linear time.

        If there are multiple indices with the same value the one with the smallest index is chosen.

        :rtype: int
        :return: 0 in case of success, -1 if ``value`` is not valid for this enum type
        """
        return _pymdlsdk.IValue_enumeration_set_value(self, value)

    def set_index(self, index):
        r"""
        Sets the enum value by index.

        :rtype: int
        :return: 0 in case of success, -1 if ``index`` is not valid for this enum type
        """
        return _pymdlsdk.IValue_enumeration_set_index(self, index)

    def get_name(self):
        r""" Returns the string representation of this enum value."""
        return _pymdlsdk.IValue_enumeration_get_name(self)

    def set_name(self, name):
        r"""
        Sets the enum value by string representation in linear time.

        :rtype: int
        :return: 0 in case of success, -1 if ``name`` is not valid for this enum type
        """
        return _pymdlsdk.IValue_enumeration_set_name(self, name)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_enumeration_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_enumeration__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_enumeration__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_enumeration__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_enumeration_get_iid(self)

# Register IValue_enumeration in _pymdlsdk:
_pymdlsdk.IValue_enumeration_swigregister(IValue_enumeration)

def IValue_enumeration_IID():
    return _pymdlsdk.IValue_enumeration_IID()

def IValue_enumeration__get_interface(iface):
    return _pymdlsdk.IValue_enumeration__get_interface(iface)

class IValue_factory(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_factory_swiginit(self, _pymdlsdk.new_IValue_factory(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_factory

    def __deref__(self):
        return _pymdlsdk.IValue_factory___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_factory___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_factory_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_factory___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_factory___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_factory_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_factory_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_factory__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_type_factory(self):
        r""" Returns the type factory associated with this value factory."""
        return _pymdlsdk.IValue_factory_get_type_factory(self)

    def create_bool(self, value=False):
        r""" Creates a new value of type boolean."""
        return _pymdlsdk.IValue_factory_create_bool(self, value)

    def create_int(self, value=0):
        r""" Creates a new value of type integer."""
        return _pymdlsdk.IValue_factory_create_int(self, value)

    def create_enum(self, type, index=0):
        r""" Creates a new value of type enum, or returns ``NULL`` in case of errors."""
        return _pymdlsdk.IValue_factory_create_enum(self, type, index)

    def create_float(self, value=0.0):
        r""" Creates a new value of type float."""
        return _pymdlsdk.IValue_factory_create_float(self, value)

    def create_double(self, value=0.0):
        r""" Creates a new value of type double."""
        return _pymdlsdk.IValue_factory_create_double(self, value)

    def create_string(self, *args):
        r"""
        Creates a new value of type string.

        :type value: string, optional
        :param value:   The value ``NULL`` is handled like the empty string.
        """
        return _pymdlsdk.IValue_factory_create_string(self, *args)

    def create_vector(self, type):
        r""" Creates a new value of type vector, or returns ``NULL`` in case of errors."""
        return _pymdlsdk.IValue_factory_create_vector(self, type)

    def create_matrix(self, type):
        r""" Creates a new value of type matrix, or returns ``NULL`` in case of errors."""
        return _pymdlsdk.IValue_factory_create_matrix(self, type)

    def create_color(self, red=0.0, green=0.0, blue=0.0):
        r""" Creates a new value of type color."""
        return _pymdlsdk.IValue_factory_create_color(self, red, green, blue)

    def create_array(self, type):
        r""" Creates a new value of type array, or returns ``NULL`` in case of errors."""
        return _pymdlsdk.IValue_factory_create_array(self, type)

    def create_struct(self, type):
        r""" Creates a new value of type struct, or returns ``NULL`` in case of errors."""
        return _pymdlsdk.IValue_factory_create_struct(self, type)

    def create_texture(self, type, value):
        r""" Creates a new texture value, or returns ``NULL`` in case of errors."""
        return _pymdlsdk.IValue_factory_create_texture(self, type, value)

    def create_light_profile(self, value):
        r""" Creates a new light profile value, or returns ``NULL`` in case of errors."""
        return _pymdlsdk.IValue_factory_create_light_profile(self, value)

    def create_bsdf_measurement(self, value):
        r""" Creates a new BSDF measurement value, or returns ``NULL`` in case of errors."""
        return _pymdlsdk.IValue_factory_create_bsdf_measurement(self, value)

    def create_invalid_df(self, type):
        r""" Creates a new invalid distribution function value."""
        return _pymdlsdk.IValue_factory_create_invalid_df(self, type)

    def create(self, *args):
        r"""
        *Overload 1:*
        Creates a default-constructed value of the given type.

        |

        *Overload 2:*
        Creates a value observing the range of an ``"::anno::soft_range()"`` or an
        ``"::anno::hard_range()"`` annotation.

        The type of the value is determined by the parameter types of the annotation.

        |

        *Overload 3:*
        Creates a value observing a potentially present range annotation.

        This method is a convenience wrapper around the other two (non-template) overloads.

        If ``annotation_block`` contains an ``"::anno::soft_range()"`` or an ``"::anno::hard_range()"``
        annotation, then this method calls the annotation-based overload with that annotation (where
        ``"::anno::soft_range()"`` has priority over ``"::anno::hard_range()"``). Otherwise, it calls
        the type-based overload with the given value type.
        """
        return _pymdlsdk.IValue_factory_create(self, *args)

    def create_value_list(self):
        r""" Creates a new value list."""
        return _pymdlsdk.IValue_factory_create_value_list(self)

    def clone(self, *args):
        r"""
        *Overload 1:*
        Clones the given value.

        Note that referenced DB elements, e.g., resources, are not copied, but shared.

        |

        *Overload 2:*
        Clones the given value list.

        Note that referenced DB elements, e.g., resources, are not copied, but shared.
        """
        return _pymdlsdk.IValue_factory_clone(self, *args)

    def compare(self, *args):
        r"""
        *Overload 1:*
        Compares two instances of #mi::neuraylib::IValue.

        The comparison operator for instances of #mi::neuraylib::IValue is defined as follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Otherwise, the types of ``lhs`` and ``rhs`` are compared. If they are different, the result
          is determined by that comparison.
        - Next, the kind of the values are compared. If they are different, the result is determined
          by ``operator``< on the #mi::neuraylib::IValue::Kind values.
        - Finally, the values are compared as follows:
          - For atomic types, their values are compared using ``operator``< or ``strcmp()``, with the
            exception of enums, for which the indices rather than the values are compared.
          - For compounds, the compound size is compared using ``operator``< (the compound size might
            be different for dynamic arrays). If both compounds are of equal size, the compounds
            elements are compared in lexicographic order.
          - For resources, the values are compared using ``strcmp()``.

        :type lhs: :py:class:`IValue`
        :param lhs:          The left-hand side operand for the comparison.
        :type rhs: :py:class:`IValue`
        :param rhs:          The right-hand side operand for the comparison.
        :type epsilon: float, optional
        :param epsilon:      Maximum difference for floating point values to consider them as equal.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.

        |

        *Overload 2:*
        Compares two instances of #mi::neuraylib::IValue_list.

        The comparison operator for instances of #mi::neuraylib::IValue_list is defined as follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Next, the list sizes are compared using ``operator``<().
        - Next, the lists are traversed by increasing index and the names are compared
          using ``strcmp()``.
        - Finally, the list elements are enumerated by increasing index and the values are compared.

        :type lhs: :py:class:`IValue_list`
        :param lhs:          The left-hand side operand for the comparison.
        :type rhs: :py:class:`IValue_list`
        :param rhs:          The right-hand side operand for the comparison.
        :type epsilon: float, optional
        :param epsilon:      Maximum difference for floating point values to consider them as equal.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.

        |

        *Overload 3:*
        Compares two instances of #mi::neuraylib::IValue_list.

        The comparison operator for instances of #mi::neuraylib::IValue_list is defined as follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Next, the list sizes are compared using ``operator``<().
        - Next, the lists are traversed by increasing index and the names are compared
          using ``strcmp()``.
        - Finally, the list elements are enumerated by increasing index and the values are compared.

        :type lhs: :py:class:`IValue_list`
        :param lhs:          The left-hand side operand for the comparison.
        :type rhs: :py:class:`IValue_list`
        :param rhs:          The right-hand side operand for the comparison.
        :param epsilon:      Maximum difference for floating point values to consider them as equal.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.
        """
        return _pymdlsdk.IValue_factory_compare(self, *args)

    def dump(self, *args):
        r"""
        *Overload 1:*
         Returns a textual representation of a value.

         The textual representation is of the form "type name = value" if ``name`` is not ``NULL``, and
         of the form "value" if ``name`` is ``NULL``. The representation of the value might contain
         line breaks, for example for structures, enums, and arrays. Subsequent lines have a suitable
         indentation. The assumed indentation level of the first line is specified by ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 2:*
         Returns a textual representation of a value list.

         The representation of the value list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 3:*
         Returns a textual representation of a value list.

         The representation of the value list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.
        """
        return _pymdlsdk.IValue_factory_dump(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_factory_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_factory__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_factory__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_factory_get_iid(self)

# Register IValue_factory in _pymdlsdk:
_pymdlsdk.IValue_factory_swigregister(IValue_factory)

def IValue_factory_IID():
    return _pymdlsdk.IValue_factory_IID()

def IValue_factory__get_interface(iface):
    return _pymdlsdk.IValue_factory__get_interface(iface)

class IValue_float(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_float_swiginit(self, _pymdlsdk.new_IValue_float(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_float

    def __deref__(self):
        return _pymdlsdk.IValue_float___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_float___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_float_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_float___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_float___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_float_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_float_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_float__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_float_get_type(self)

    def get_value(self):
        r""" Returns the value."""
        return _pymdlsdk.IValue_float_get_value(self)

    def set_value(self, value):
        r""" Sets the value."""
        return _pymdlsdk.IValue_float_set_value(self, value)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_float_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_float__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_float__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_float__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_float_get_iid(self)

# Register IValue_float in _pymdlsdk:
_pymdlsdk.IValue_float_swigregister(IValue_float)

def IValue_float_IID():
    return _pymdlsdk.IValue_float_IID()

def IValue_float__get_interface(iface):
    return _pymdlsdk.IValue_float__get_interface(iface)

class IValue_int(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_int_swiginit(self, _pymdlsdk.new_IValue_int(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_int

    def __deref__(self):
        return _pymdlsdk.IValue_int___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_int___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_int_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_int___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_int___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_int_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_int_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_int__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_int_get_type(self)

    def get_value(self):
        r""" Returns the value."""
        return _pymdlsdk.IValue_int_get_value(self)

    def set_value(self, value):
        r""" Sets the value."""
        return _pymdlsdk.IValue_int_set_value(self, value)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_int_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_int__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_int__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_int__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_int_get_iid(self)

# Register IValue_int in _pymdlsdk:
_pymdlsdk.IValue_int_swigregister(IValue_int)

def IValue_int_IID():
    return _pymdlsdk.IValue_int_IID()

def IValue_int__get_interface(iface):
    return _pymdlsdk.IValue_int__get_interface(iface)

class IValue_invalid_df(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_invalid_df_swiginit(self, _pymdlsdk.new_IValue_invalid_df(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_invalid_df

    def __deref__(self):
        return _pymdlsdk.IValue_invalid_df___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_invalid_df___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_invalid_df_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_invalid_df___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_invalid_df___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_invalid_df_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_invalid_df_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_invalid_df__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_invalid_df_get_type(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_invalid_df_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_invalid_df__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_invalid_df__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_invalid_df__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_invalid_df_get_iid(self)

# Register IValue_invalid_df in _pymdlsdk:
_pymdlsdk.IValue_invalid_df_swigregister(IValue_invalid_df)

def IValue_invalid_df_IID():
    return _pymdlsdk.IValue_invalid_df_IID()

def IValue_invalid_df__get_interface(iface):
    return _pymdlsdk.IValue_invalid_df__get_interface(iface)

class IValue_light_profile(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_light_profile_swiginit(self, _pymdlsdk.new_IValue_light_profile(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_light_profile

    def __deref__(self):
        return _pymdlsdk.IValue_light_profile___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_light_profile___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_light_profile_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_light_profile___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_light_profile___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_light_profile_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_light_profile_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_light_profile__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_light_profile_get_type(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_light_profile_compare_iid(self, iid)

    def get_value(self):
        r"""
        Returns the name of the DB element representing this resource.

        :rtype: string
        :return: The name of the DB element, or ``NULL`` if no valid resource is set.
        """
        return _pymdlsdk.IValue_light_profile_get_value(self)

    def set_value(self, value):
        r"""
        Sets the name of the DB element representing this resource.

        Pointing this instance to a different DB element resets the MDL file path returned by
        #get_file_path().

        :type value: string
        :param value:   The name of the resource, or ``NULL`` to release the current resource.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: There is no DB element with that name.
                           - -2: The DB element has not the correct type for this resource.
        """
        return _pymdlsdk.IValue_light_profile_set_value(self, value)

    def get_file_path(self):
        r"""
        Returns the absolute MDL file path of the resource, or ``NULL`` if not known.

        Notes: The value returned here is not a property of this object, but a property of the
              referenced resource.
        """
        return _pymdlsdk.IValue_light_profile_get_file_path(self)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_light_profile__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_light_profile__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_light_profile__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_light_profile_get_iid(self)

# Register IValue_light_profile in _pymdlsdk:
_pymdlsdk.IValue_light_profile_swigregister(IValue_light_profile)

def IValue_light_profile_IID():
    return _pymdlsdk.IValue_light_profile_IID()

def IValue_light_profile__get_interface(iface):
    return _pymdlsdk.IValue_light_profile__get_interface(iface)

class IValue_list(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_list_swiginit(self, _pymdlsdk.new_IValue_list(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_list

    def __deref__(self):
        return _pymdlsdk.IValue_list___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_list___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_list_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_list___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_list___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_list_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_list_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_list__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_size(self):
        r""" Returns the number of elements."""
        return _pymdlsdk.IValue_list_get_size(self)

    def get_index(self, name):
        r""" Returns the index for the given name, or -1 if there is no such value."""
        return _pymdlsdk.IValue_list_get_index(self, name)

    def get_name(self, index):
        r""" Returns the name for the given index, or ``NULL`` if there is no such value."""
        return _pymdlsdk.IValue_list_get_name(self, index)

    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value for ``index``, or ``NULL`` if there is no such value.

        |

        *Overload 2:*
        Returns the value for ``name``, or ``NULL`` if there is no such value.
        """
        return _pymdlsdk.IValue_list_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets a value at a given index.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: ``index`` is out of bounds.

        |

        *Overload 2:*
        Sets a value identified by name.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is no value mapped to ``name`` in the list.
        """
        return _pymdlsdk.IValue_list_set_value(self, *args)

    def add_value(self, name, value):
        r"""
        Adds a value at the end of the list.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is already a value mapped to ``name`` in the list.
        """
        return _pymdlsdk.IValue_list_add_value(self, name, value)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_list_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_list__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_list__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_list_get_iid(self)

# Register IValue_list in _pymdlsdk:
_pymdlsdk.IValue_list_swigregister(IValue_list)

def IValue_list_IID():
    return _pymdlsdk.IValue_list_IID()

def IValue_list__get_interface(iface):
    return _pymdlsdk.IValue_list__get_interface(iface)

class IValue_matrix(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_matrix_swiginit(self, _pymdlsdk.new_IValue_matrix(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_matrix

    def __deref__(self):
        return _pymdlsdk.IValue_matrix___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_matrix___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_matrix_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_matrix___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_matrix___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_matrix_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_matrix_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_matrix__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_value(self, *args):
        return  self._get_value(*args)

    def get_value_as(self, type, *args):
        iinterface = self._get_value(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_matrix_get_type(self)

    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.

        |

        *Overload 2:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk.IValue_matrix__get_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_matrix_compare_iid(self, iid)

    def get_size(self):
        r""" Returns the number of components in this compound value."""
        return _pymdlsdk.IValue_matrix_get_size(self)

    def set_value(self, index, value):
        r"""
        Sets the value at ``index``.

        :type index: int
        :param index:   The index of the field.
        :type value: :py:class:`IValue`
        :param value:   The new value of the field.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: ``index`` is out of bounds.
                           - -3: Incorrect type of ``value``.
        """
        return _pymdlsdk.IValue_matrix_set_value(self, index, value)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_matrix__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_matrix__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_matrix__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_matrix_get_iid(self)

# Register IValue_matrix in _pymdlsdk:
_pymdlsdk.IValue_matrix_swigregister(IValue_matrix)

def IValue_matrix_IID():
    return _pymdlsdk.IValue_matrix_IID()

def IValue_matrix__get_interface(iface):
    return _pymdlsdk.IValue_matrix__get_interface(iface)

class IValue_resource(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_resource_swiginit(self, _pymdlsdk.new_IValue_resource(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_resource

    def __deref__(self):
        return _pymdlsdk.IValue_resource___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_resource___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_resource_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_resource___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_resource___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_resource_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_resource_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_resource__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_resource_get_type(self)

    def get_value(self):
        r"""
        Returns the name of the DB element representing this resource.

        :rtype: string
        :return: The name of the DB element, or ``NULL`` if no valid resource is set.
        """
        return _pymdlsdk.IValue_resource_get_value(self)

    def set_value(self, value):
        r"""
        Sets the name of the DB element representing this resource.

        Pointing this instance to a different DB element resets the MDL file path returned by
        #get_file_path().

        :type value: string
        :param value:   The name of the resource, or ``NULL`` to release the current resource.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: There is no DB element with that name.
                           - -2: The DB element has not the correct type for this resource.
        """
        return _pymdlsdk.IValue_resource_set_value(self, value)

    def get_file_path(self):
        r"""
        Returns the absolute MDL file path of the resource, or ``NULL`` if not known.

        Notes: The value returned here is not a property of this object, but a property of the
              referenced resource.
        """
        return _pymdlsdk.IValue_resource_get_file_path(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_resource_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_resource__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_resource__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_resource__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_resource_get_iid(self)

# Register IValue_resource in _pymdlsdk:
_pymdlsdk.IValue_resource_swigregister(IValue_resource)

def IValue_resource_IID():
    return _pymdlsdk.IValue_resource_IID()

def IValue_resource__get_interface(iface):
    return _pymdlsdk.IValue_resource__get_interface(iface)

class IValue_string(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_string_swiginit(self, _pymdlsdk.new_IValue_string(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_string

    def __deref__(self):
        return _pymdlsdk.IValue_string___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_string___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_string_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_string___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_string___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_string_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_string_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_string__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_string_get_type(self)

    def get_value(self):
        r""" Returns the value."""
        return _pymdlsdk.IValue_string_get_value(self)

    def set_value(self, value):
        r""" Sets the value."""
        return _pymdlsdk.IValue_string_set_value(self, value)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_string_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_string__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_string__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_string__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_string_get_iid(self)

# Register IValue_string in _pymdlsdk:
_pymdlsdk.IValue_string_swigregister(IValue_string)

def IValue_string_IID():
    return _pymdlsdk.IValue_string_IID()

def IValue_string__get_interface(iface):
    return _pymdlsdk.IValue_string__get_interface(iface)

class IValue_string_localized(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_string_localized_swiginit(self, _pymdlsdk.new_IValue_string_localized(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_string_localized

    def __deref__(self):
        return _pymdlsdk.IValue_string_localized___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_string_localized___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_string_localized_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_string_localized___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_string_localized___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_string_localized_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_string_localized_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_string_localized__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_original_value(self):
        r"""
        Returns the original value of a localized string.
        While IValue_string::value() returns the translated string.
        """
        return _pymdlsdk.IValue_string_localized_get_original_value(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_string_localized_compare_iid(self, iid)

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_string_localized_get_type(self)

    def get_value(self):
        r""" Returns the value."""
        return _pymdlsdk.IValue_string_localized_get_value(self)

    def set_value(self, value):
        r""" Sets the value."""
        return _pymdlsdk.IValue_string_localized_set_value(self, value)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_string_localized__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_string_localized__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_string_localized__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_string_localized_get_iid(self)

# Register IValue_string_localized in _pymdlsdk:
_pymdlsdk.IValue_string_localized_swigregister(IValue_string_localized)

def IValue_string_localized_IID():
    return _pymdlsdk.IValue_string_localized_IID()

def IValue_string_localized__get_interface(iface):
    return _pymdlsdk.IValue_string_localized__get_interface(iface)

class IValue_structure(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_structure_swiginit(self, _pymdlsdk.new_IValue_structure(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_structure

    def __deref__(self):
        return _pymdlsdk.IValue_structure___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_structure___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_structure_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_structure___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_structure___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_structure_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_structure_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_structure__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_value(self, *args):
        return  self._get_value(*args)

    def get_value_as(self, type, *args):
        iinterface = self._get_value(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_field(self, *args):
        return  self._get_field(*args)

    def get_field_as(self, type, *args):
        iinterface = self._get_field(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_structure_get_type(self)

    def _get_field(self, *args):
        r"""
        *Overload 1:*
        Returns a field by name in linear time.

        :type name: string
        :param name:    The name of the field.
        :rtype: :py:class:`IValue`
        :return: The value of the field, or ``NULL`` if there is no such field.

        |

        *Overload 2:*
        Returns a field by name in linear time.

        :type name: string
        :param name:    The name of the field.
        :rtype: :py:class:`IValue`
        :return: The value of the field, or ``NULL`` if there is no such field.
        """
        return _pymdlsdk.IValue_structure__get_field(self, *args)

    def set_field(self, name, value):
        r"""
        Sets a field by name in linear time.

        :type name: string
        :param name:    The name of the field.
        :type value: :py:class:`IValue`
        :param value:   The new value of the field.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: There is no such field of the given name.
                           - -3: Incorrect type of ``value``.
        """
        return _pymdlsdk.IValue_structure_set_field(self, name, value)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_structure_compare_iid(self, iid)

    def get_size(self):
        r""" Returns the number of components in this compound value."""
        return _pymdlsdk.IValue_structure_get_size(self)

    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.

        |

        *Overload 2:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk.IValue_structure__get_value(self, *args)

    def set_value(self, index, value):
        r"""
        Sets the value at ``index``.

        :type index: int
        :param index:   The index of the field.
        :type value: :py:class:`IValue`
        :param value:   The new value of the field.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: ``index`` is out of bounds.
                           - -3: Incorrect type of ``value``.
        """
        return _pymdlsdk.IValue_structure_set_value(self, index, value)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_structure__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_structure__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_structure__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_structure_get_iid(self)

# Register IValue_structure in _pymdlsdk:
_pymdlsdk.IValue_structure_swigregister(IValue_structure)

def IValue_structure_IID():
    return _pymdlsdk.IValue_structure_IID()

def IValue_structure__get_interface(iface):
    return _pymdlsdk.IValue_structure__get_interface(iface)

class IValue_texture(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_texture_swiginit(self, _pymdlsdk.new_IValue_texture(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_texture

    def __deref__(self):
        return _pymdlsdk.IValue_texture___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_texture___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_texture_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_texture___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_texture___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_texture_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_texture_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_texture__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_texture_get_type(self)

    def get_gamma(self):
        r"""
        Returns the gamma value of this texture.

        Notes: : A gamma value of 0 corresponds to the default gamma value for the given texture
               kind.
        """
        return _pymdlsdk.IValue_texture_get_gamma(self)

    def get_selector(self):
        r""" Returns the selector of this texture, or ``NULL``."""
        return _pymdlsdk.IValue_texture_get_selector(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_texture_compare_iid(self, iid)

    def get_value(self):
        r"""
        Returns the name of the DB element representing this resource.

        :rtype: string
        :return: The name of the DB element, or ``NULL`` if no valid resource is set.
        """
        return _pymdlsdk.IValue_texture_get_value(self)

    def set_value(self, value):
        r"""
        Sets the name of the DB element representing this resource.

        Pointing this instance to a different DB element resets the MDL file path returned by
        #get_file_path().

        :type value: string
        :param value:   The name of the resource, or ``NULL`` to release the current resource.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: There is no DB element with that name.
                           - -2: The DB element has not the correct type for this resource.
        """
        return _pymdlsdk.IValue_texture_set_value(self, value)

    def get_file_path(self):
        r"""
        Returns the absolute MDL file path of the resource, or ``NULL`` if not known.

        Notes: The value returned here is not a property of this object, but a property of the
              referenced resource.
        """
        return _pymdlsdk.IValue_texture_get_file_path(self)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_texture__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_texture__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_texture__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_texture_get_iid(self)

# Register IValue_texture in _pymdlsdk:
_pymdlsdk.IValue_texture_swigregister(IValue_texture)

def IValue_texture_IID():
    return _pymdlsdk.IValue_texture_IID()

def IValue_texture__get_interface(iface):
    return _pymdlsdk.IValue_texture__get_interface(iface)

class IValue_vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_vector_swiginit(self, _pymdlsdk.new_IValue_vector(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_vector

    def __deref__(self):
        return _pymdlsdk.IValue_vector___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_vector___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_vector_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_vector___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_vector___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_vector_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_vector_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_vector__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_value(self, *args):
        return  self._get_value(*args)

    def get_value_as(self, type, *args):
        iinterface = self._get_value(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_vector_get_type(self)

    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.

        |

        *Overload 2:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk.IValue_vector__get_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_vector_compare_iid(self, iid)

    def get_size(self):
        r""" Returns the number of components in this compound value."""
        return _pymdlsdk.IValue_vector_get_size(self)

    def set_value(self, index, value):
        r"""
        Sets the value at ``index``.

        :type index: int
        :param index:   The index of the field.
        :type value: :py:class:`IValue`
        :param value:   The new value of the field.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: ``index`` is out of bounds.
                           - -3: Incorrect type of ``value``.
        """
        return _pymdlsdk.IValue_vector_set_value(self, index, value)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_vector__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_vector__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_vector__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_vector_get_iid(self)

# Register IValue_vector in _pymdlsdk:
_pymdlsdk.IValue_vector_swigregister(IValue_vector)

def IValue_vector_IID():
    return _pymdlsdk.IValue_vector_IID()

def IValue_vector__get_interface(iface):
    return _pymdlsdk.IValue_vector__get_interface(iface)


def _print_open_handle_statistic():
    return _pymdlsdk._print_open_handle_statistic()

def _enable_print_ref_counts(arg1):
    return _pymdlsdk._enable_print_ref_counts(arg1)

def attach_ineuray(ptr_as_uint64):
    return _pymdlsdk.attach_ineuray(ptr_as_uint64)

def attach_itransaction(ptr_as_uint64):
    return _pymdlsdk.attach_itransaction(ptr_as_uint64)

def load_and_get_ineuray(arg1):
    return _pymdlsdk.load_and_get_ineuray(arg1)

def load_plugin(arg1, arg2):
    return _pymdlsdk.load_plugin(arg1, arg2)

def unload():
    return _pymdlsdk.unload()


